{"id": "rull_linter/B007-B008-B009-B010-B012", "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom B007 (unused-loop-control-variable)\n\nDefinition: Checks for unused variables in loops (e.g., for and while statements).\n\nRationale: Defining a variable in a loop statement that is never used can confuse\nreaders.\n\n\nIf the variable is intended to be unused (e.g., to facilitate\ndestructuring of a tuple or other object), prefix it with an underscore\nto indicate the intent. Otherwise, remove the variable entirely.\n\nExample:\nfor i, j in foo:\n    bar(i)\n\n\n\nUse instead:\n\n\nfor i, _j in foo:\n    bar(i)\n\n# Idiom B008 (function-call-in-default-argument)\n\nDefinition: Checks for function calls in default function arguments.\n\nRationale: Any function call that's used in a default argument will only be performed\nonce, at definition time. The returned value will then be reused by all\ncalls to the function, which can lead to unexpected behaviour.\n\n\nCalls can be marked as an exception to this rule with the\nlint.flake8-bugbear.extend-immutable-calls configuration option.\n\n\nArguments with immutable type annotations will be ignored by this rule.\nTypes outside of the standard library can be marked as immutable with the\nlint.flake8-bugbear.extend-immutable-calls configuration option as well.\n\nExample:\ndef create_list() -> list[int]:\n    return [1, 2, 3]\n\n\ndef mutable_default(arg: list[int] = create_list()) -> list[int]:\n    arg.append(4)\n    return arg\n\n\n\nUse instead:\n\n\ndef better(arg: list[int] | None = None) -> list[int]:\n    if arg is None:\n        arg = create_list()\n\n    arg.append(4)\n    return arg\n\n\n\nIf the use of a singleton is intentional, assign the result call to a\nmodule-level variable, and use that variable in the default argument:\n\n\nERROR = ValueError(\"Hosts weren't successfully added\")\n\n\ndef add_host(error: Exception = ERROR) -> None: ...\n\n# Idiom B009 (get-attr-with-constant)\n\nDefinition: Checks for uses of getattr that take a constant attribute value as an\nargument (e.g., getattr(obj, \"foo\")).\n\nRationale: getattr is used to access attributes dynamically. If the attribute is\ndefined as a constant, it is no safer than a typical property access. When\npossible, prefer property access over getattr calls, as the former is\nmore concise and idiomatic.\n\nExample:\ngetattr(obj, \"foo\")\n\n\n\nUse instead:\n\n\nobj.foo\n\n# Idiom B010 (set-attr-with-constant)\n\nDefinition: Checks for uses of setattr that take a constant attribute value as an\nargument (e.g., setattr(obj, \"foo\", 42)).\n\nRationale: setattr is used to set attributes dynamically. If the attribute is\ndefined as a constant, it is no safer than a typical property access. When\npossible, prefer property access over setattr calls, as the former is\nmore concise and idiomatic.\n\nExample:\nsetattr(obj, \"foo\", 42)\n\n\n\nUse instead:\n\n\nobj.foo = 42\n\n# Idiom B012 (jump-statement-in-finally)\n\nDefinition: Checks for break, continue, and return statements in finally\nblocks.\n\nRationale: The use of break, continue, and return statements in finally blocks\ncan cause exceptions to be silenced.\n\n\nfinally blocks execute regardless of whether an exception is raised. If a\nbreak, continue, or return statement is reached in a finally block,\nany exception raised in the try or except blocks will be silenced.\n\nExample:\ndef speed(distance, time):\n    try:\n        return distance / time\n    except ZeroDivisionError:\n        raise ValueError(\"Time cannot be zero\")\n    finally:\n        return 299792458  # `ValueError` is silenced\n\n\n\nUse instead:\n\n\ndef speed(distance, time):\n    try:\n        return distance / time\n    except ZeroDivisionError:\n        raise ValueError(\"Time cannot be zero\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed within a given Python code to figure out whether the idiom is present in the code.", "response": "To identify whether any of the specified idioms are present in a given Python code, you need to closely analyze certain code constructs or patterns. Here's a list of constructs to look for based on each idiom:\n\n1. **Idiom B007 (unused-loop-control-variable)**\n   - Look for `for` or `while` loops where variables are defined in the loop declaration.\n   - Check if all defined loop control variables are used within the loop body.\n   - Look for loop variables that are prefixed with an underscore if they are intentionally unused.\n\n2. **Idiom B008 (function-call-in-default-argument)**\n   - Search for function definitions where parameters have default values.\n   - Check if any of the default values are the result of a function call.\n   - Verify if the return value of the function call is potentially mutable and assess if it could lead to unexpected behavior.\n\n3. **Idiom B009 (get-attr-with-constant)**\n   - Identify uses of the `getattr` function.\n   - Look for cases where the second argument (attribute name) is a constant string.\n   - Evaluate if the same result can be achieved with a direct property access (`obj.attribute`).\n\n4. **Idiom B010 (set-attr-with-constant)**\n   - Identify uses of the `setattr` function.\n   - Check for cases where the second argument is a constant attribute name (a fixed string).\n   - Consider replacing dynamic attribute setting with a direct property assignment (`obj.attribute = value`).\n\n5. **Idiom B012 (jump-statement-in-finally)**\n   - Look for `finally` blocks within `try`...`except`...`finally` constructs.\n   - Search for `break`, `continue`, or `return` statements within these `finally` blocks.\n   - Assess whether the use of such jump statements could potentially silence exceptions raised in the `try` or `except` blocks.\n\nBy scrutinizing these specific constructs, you can determine the presence of each particular idiom in a Python codebase and evaluate whether the code should be refactored to adhere to these idiomatic practices."}
{"id": "rull_linter/N801-N802-N803-N804-N805", "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom N801 (invalid-class-name)\n\nDefinition: Checks for class names that do not follow the CamelCase convention.\n\nRationale: PEP 8 recommends the use of the CapWords (or CamelCase) convention\nfor class names:\n\n\n\nClass names should normally use the CapWords convention.\nThe naming convention for functions may be used instead in cases where the interface is\ndocumented and used primarily as a callable.\nNote that there is a separate convention for builtin names: most builtin names are single\nwords (or two words run together), with the CapWords convention used only for exception\nnames and builtin constants.\n\nExample:\nclass my_class:\n    pass\n\n\n\nUse instead:\n\n\nclass MyClass:\n    pass\n\n# Idiom N802 (invalid-function-name)\n\nDefinition: Checks for functions names that do not follow the snake_case naming\nconvention.\n\nRationale: PEP 8 recommends that function names follow snake_case:\n\n\n\nFunction names should be lowercase, with words separated by underscores as necessary to\nimprove readability. mixedCase is allowed only in contexts where that\u2019s already the\nprevailing style (e.g. threading.py), to retain backwards compatibility.\n\n\n\nNames can be excluded from this rule using the lint.pep8-naming.ignore-names\nor lint.pep8-naming.extend-ignore-names configuration options. For example,\nto ignore all functions starting with test_ from this rule, set the\nlint.pep8-naming.extend-ignore-names option to [\"test_*\"].\n\nExample:\ndef myFunction():\n    pass\n\n\n\nUse instead:\n\n\ndef my_function():\n    pass\n\n# Idiom N803 (invalid-argument-name)\n\nDefinition: Checks for argument names that do not follow the snake_case convention.\n\nRationale: PEP 8 recommends that function names should be lower case and separated\nby underscores (also known as snake_case).\n\n\n\nFunction names should be lowercase, with words separated by underscores\nas necessary to improve readability.\nVariable names follow the same convention as function names.\nmixedCase is allowed only in contexts where that\u2019s already the\nprevailing style (e.g. threading.py), to retain backwards compatibility.\n\nExample:\ndef my_function(A, myArg):\n    pass\n\n\n\nUse instead:\n\n\ndef my_function(a, my_arg):\n    pass\n\n# Idiom N804 (invalid-first-argument-name-for-class-method)\n\nDefinition: Checks for class methods that use a name other than cls for their\nfirst argument.\n\nRationale: PEP 8 recommends the use of cls as the first argument for all class\nmethods:\n\n\n\nAlways use cls for the first argument to class methods.\nIf a function argument\u2019s name clashes with a reserved keyword, it is generally better to\nappend a single trailing underscore rather than use an abbreviation or spelling corruption.\nThus class_ is better than clss. (Perhaps better is to avoid such clashes by using a synonym.)\n\n\n\nNames can be excluded from this rule using the lint.pep8-naming.ignore-names\nor lint.pep8-naming.extend-ignore-names configuration options. For example,\nto allow the use of klass as the first argument to class methods, set\nthe lint.pep8-naming.extend-ignore-names option to [\"klass\"].\n\nExample:\nclass Example:\n    @classmethod\n    def function(self, data): ...\n\n\n\nUse instead:\n\n\nclass Example:\n    @classmethod\n    def function(cls, data): ...\n\n# Idiom N805 (invalid-first-argument-name-for-method)\n\nDefinition: Checks for instance methods that use a name other than self for their\nfirst argument.\n\nRationale: PEP 8 recommends the use of self as first argument for all instance\nmethods:\n\n\n\nAlways use self for the first argument to instance methods.\nIf a function argument\u2019s name clashes with a reserved keyword, it is generally better to\nappend a single trailing underscore rather than use an abbreviation or spelling corruption.\nThus class_ is better than clss. (Perhaps better is to avoid such clashes by using a synonym.)\n\n\n\nNames can be excluded from this rule using the lint.pep8-naming.ignore-names\nor lint.pep8-naming.extend-ignore-names configuration options. For example,\nto allow the use of this as the first argument to instance methods, set\nthe lint.pep8-naming.extend-ignore-names option to [\"this\"].\n\nExample:\nclass Example:\n    def function(cls, data): ...\n\n\n\nUse instead:\n\n\nclass Example:\n    def function(self, data): ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed within a given Python code to figure out whether the idiom is present in the code.", "response": "Based on the idioms provided, here is an exhaustive list of code constructs that should be closely analyzed within a given Python code to determine whether these idioms are present:\n\n1. **Class Definitions:**\n   - Identify class definitions to check if the class name follows the CamelCase convention (Idiom N801).\n\n2. **Function Definitions:**\n   - Identify function definitions to verify that the function name follows the snake_case convention (Idiom N802).\n\n3. **Function Arguments:**\n   - Within each function definition, examine the names of the arguments to ensure they follow snake_case (Idiom N803).\n\n4. **Class Method Definitions:**\n   - Identify class methods (decorated with `@classmethod`) and check that the first argument is named `cls` (Idiom N804).\n\n5. **Instance Method Definitions:**\n   - Identify instance methods and verify that the first argument is named `self` (Idiom N805).\n\nFor each of these constructs, the following specific checks must be applied:\n\n- For **class names** (N801): Ensure the class names are written in CamelCase. Classes should be defined using `class ClassName:`.\n\n- For **function names** (N802): Ensure the names are written in snake_case, such as `def function_name():`.\n\n- For **function arguments** (N803): Check that argument names also follow snake_case, like `def function_name(arg_one, arg_two):`.\n\n- For **class methods** (N804): Verify that the class method's first argument is named `cls`. This includes methods decorated with `@classmethod`.\n\n- For **instance methods** (N805): Ensure the first argument of instance methods is `self`. This pertains to regular methods within a class that do not have specific decorators like `@classmethod`.\n\nWhen analyzing a given Python code, identifying these constructs and applying the respective checks will help determine compliance with PEP 8 conventions described by the provided idioms."}
{"id": "rull_linter/UP007-UP008-UP009-UP010-UP011", "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom UP007 (non-pep604-annotation-union)\n\nDefinition: Check for type annotations that can be rewritten based on PEP 604 syntax.\n\nRationale: PEP 604 introduced a new syntax for union type annotations based on the\n| operator. This syntax is more concise and readable than the previous\ntyping.Union and typing.Optional syntaxes.\n\n\nThis rule is enabled when targeting Python 3.10 or later (see:\ntarget-version). By default, it's also enabled for earlier Python\nversions if from __future__ import annotations is present, as\n__future__ annotations are not evaluated at runtime. If your code relies\non runtime type annotations (either directly or via a library like\nPydantic), you can disable this behavior for Python versions prior to 3.10\nby setting lint.pyupgrade.keep-runtime-typing to true.\n\nExample:\nfrom typing import Union\n\nfoo: Union[int, str] = 1\n\n\n\nUse instead:\n\n\nfoo: int | str = 1\n\n# Idiom UP008 (super-call-with-parameters)\n\nDefinition: Checks for super calls that pass redundant arguments.\n\nRationale: In Python 3, super can be invoked without any arguments when: (1) the\nfirst argument is __class__, and (2) the second argument is equivalent to\nthe first argument of the enclosing method.\n\n\nWhen possible, omit the arguments to super to make the code more concise\nand maintainable.\n\nExample:\nclass A:\n    def foo(self):\n        pass\n\n\nclass B(A):\n    def bar(self):\n        super(B, self).foo()\n\n\n\nUse instead:\n\n\nclass A:\n    def foo(self):\n        pass\n\n\nclass B(A):\n    def bar(self):\n        super().foo()\n\n# Idiom UP009 (utf8-encoding-declaration)\n\nDefinition: Checks for unnecessary UTF-8 encoding declarations.\n\nRationale: PEP 3120 makes UTF-8 the default encoding, so a UTF-8 encoding\ndeclaration is unnecessary.\n\nExample:\n# -*- coding: utf-8 -*-\nprint(\"Hello, world!\")\n\n\n\nUse instead:\n\n\nprint(\"Hello, world!\")\n\n# Idiom UP010 (unnecessary-future-import)\n\nDefinition: Checks for unnecessary __future__ imports.\n\nRationale: The __future__ module is used to enable features that are not yet\navailable in the current Python version. If a feature is already\navailable in the minimum supported Python version, importing it\nfrom __future__ is unnecessary and should be removed to avoid\nconfusion.\n\nExample:\nfrom __future__ import print_function\n\nprint(\"Hello, world!\")\n\n\n\nUse instead:\n\n\nprint(\"Hello, world!\")\n\n# Idiom UP011 (lru-cache-without-parameters)\n\nDefinition: Checks for unnecessary parentheses on functools.lru_cache decorators.\n\nRationale: Since Python 3.8, functools.lru_cache can be used as a decorator without\ntrailing parentheses, as long as no arguments are passed to it.\n\nExample:\nimport functools\n\n\n@functools.lru_cache()\ndef foo(): ...\n\n\n\nUse instead:\n\n\nimport functools\n\n\n@functools.lru_cache\ndef foo(): ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed within a given Python code to figure out whether the idiom is present in the code.", "response": "To identify the presence of these idioms in a given Python codebase, examine the following constructs and scenarios:\n\n1. **Type Annotations (UP007)**\n   - Look for type annotations using `typing.Union` and `typing.Optional`.\n   - Examine whether these can be replaced with the concise `|` syntax available in Python 3.10 or later.\n   - Check if `from __future__ import annotations` is used, as it enables PEP 604 syntax for versions earlier than 3.10.\n\n2. **Super Calls (UP008)**\n   - Identify `super` calls in class methods, particularly those with arguments.\n   - Verify if the arguments passed to `super` are redundant (i.e., `super(ClassName, self)`).\n   - Determine if the Python version supports argument-less `super()` (generally Python 3+).\n\n3. **Encoding Declarations (UP009)**\n   - Search for encoding declarations at the top of Python files: `# -*- coding: utf-8 -*-`.\n   - Confirm the Python version being used, as UTF-8 is the default encoding from Python 3.0 onwards, making this declaration unnecessary.\n\n4. **Future Imports (UP010)**\n   - Look for `from __future__ import ...` statements.\n   - Cross-reference these imports with the minimal supported Python version to see if they are still needed (e.g., `print_function` for Python 3+).\n\n5. **LRU Cache Decorator (UP011)**\n   - Check for the use of the `functools.lru_cache` decorator.\n   - Determine if the trailing parentheses are used without arguments, which are unnecessary in Python 3.8+.\n   - Confirm the Python version being used to leverage this improvement.\n\nBy analyzing the code for these constructs, you can identify opportunities to refactor the code in accordance with the specified idioms, improving readability, maintainability, and performance according to Python best practices."}
{"id": "rull_linter/ERA001-C901-I001-I002-BLE001", "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom ERA001 (commented-out-code)\n\nDefinition: Checks for commented-out Python code.\n\nRationale: Commented-out code is dead code, and is often included inadvertently.\nIt should be removed.\n\nExample:\n# print(\"Hello, world!\")\n\n# Idiom C901 (complex-structure)\n\nDefinition: Checks for functions with a high McCabe complexity.\n\nRationale: The McCabe complexity of a function is a measure of the complexity of\nthe control flow graph of the function. It is calculated by adding\none to the number of decision points in the function. A decision\npoint is a place in the code where the program has a choice of two\nor more paths to follow.\n\n\nFunctions with a high complexity are hard to understand and maintain.\n\nExample:\ndef foo(a, b, c):\n    if a:\n        if b:\n            if c:\n                return 1\n            else:\n                return 2\n        else:\n            return 3\n    else:\n        return 4\n\n\n\nUse instead:\n\n\ndef foo(a, b, c):\n    if not a:\n        return 4\n    if not b:\n        return 3\n    if not c:\n        return 2\n    return 1\n\n# Idiom I001 (unsorted-imports)\n\nDefinition: De-duplicates, groups, and sorts imports based on the provided isort settings.\n\nRationale: Consistency is good. Use a common convention for imports to make your code\nmore readable and idiomatic.\n\nExample:\nimport pandas\nimport numpy as np\n\n\n\nUse instead:\n\n\nimport numpy as np\nimport pandas\n\n# Idiom I002 (missing-required-import)\n\nDefinition: Adds any required imports, as specified by the user, to the top of the\nfile.\n\nRationale: In some projects, certain imports are required to be present in all\nfiles. For example, some projects assume that\nfrom __future__ import annotations is enabled,\nand thus require that import to be\npresent in all files. Omitting a \"required\" import (as specified by\nthe user) can cause errors or unexpected behavior.\n\nExample:\nimport typing\n\n\n\nUse instead:\n\n\nfrom __future__ import annotations\n\nimport typing\n\n# Idiom BLE001 (blind-except)\n\nDefinition: Checks for except clauses that catch all exceptions. This includes\nbare except, except BaseException and except Exception.\n\nRationale: Overly broad except clauses can lead to unexpected behavior, such as\ncatching KeyboardInterrupt or SystemExit exceptions that prevent the\nuser from exiting the program.\n\n\nInstead of catching all exceptions, catch only those that are expected to\nbe raised in the try block.\n\nExample:\ntry:\n    foo()\nexcept BaseException:\n    ...\n\n\n\nUse instead:\n\n\ntry:\n    foo()\nexcept FileNotFoundError:\n    ...\n\n\n\nExceptions that are re-raised will not be flagged, as they're expected to\nbe caught elsewhere:\n\n\ntry:\n    foo()\nexcept BaseException:\n    raise\n\n\n\nExceptions that are logged via logging.exception() or logging.error()\nwith exc_info enabled will not be flagged, as this is a common pattern\nfor propagating exception traces:\n\n\ntry:\n    foo()\nexcept BaseException:\n    logging.exception(\"Something went wrong\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed within a given Python code to figure out whether the idiom is present in the code.", "response": "To analyze Python code for the presence of the listed idioms, you would need to look for the following specific constructs:\n\n1. **Idiom ERA001 (commented-out-code)**\n   - Look for lines that start with `#` (ignoring any leading whitespace) followed by what appears to be Python code. This may include:\n     - Function calls, e.g., `# foo()`\n     - Print statements, e.g., `# print(\"Hello, world!\")`\n     - Variable assignments, e.g., `# x = 42`\n     - Control structures, e.g., `# if a > b:`\n\n2. **Idiom C901 (complex-structure)**\n   - Calculate the McCabe complexity of functions:\n     - Identify decision points which include `if`, `for`, `while`, `try`, `except`, and `with` statements, along with boolean operators like `and`, `or` within conditionals.\n     - Flag functions with a high count of decision points to indicate high complexity.\n   - Example patterns to analyze:\n     - Nested conditionals\n     - Loops and multiple branches\n\n3. **Idiom I001 (unsorted-imports)**\n   - Inspect the import statements at the top of a file:\n     - Check that they are sorted alphabetically or according to a specified order.\n     - Ensure imports are grouped logically (standard library, third-party, local application).\n\n4. **Idiom I002 (missing-required-import)**\n   - Verify the presence of specified required imports at the top of the file:\n     - Look for custom or `__future__` imports that must be included in every file.\n   - Common example:\n     - `from __future__ import annotations`\n\n5. **Idiom BLE001 (blind-except)**\n   - Identify and evaluate `except` clauses:\n     - Look for bare `except:` or `except BaseException:` or `except Exception:`\n     - Suggest narrowing the exception type to specific, expected exceptions (like `FileNotFoundError`).\n   - Recognize exceptions that are re-raised or logged with `logging.exception()` or `logging.error()` which are exceptions to the rule.\n\nBy applying checks for these constructs, one can effectively identify the presence of these idioms in a given Python codebase."}
{"id": "rull_linter/B002-B003-B004-B005-B006", "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom B002 (unary-prefix-increment-decrement)\n\nDefinition: Checks for the attempted use of the unary prefix increment (++) or\ndecrement operator (--).\n\nRationale: Python does not support the unary prefix increment or decrement operator.\nWriting ++n is equivalent to +(+(n)) and writing --n is equivalent to\n-(-(n)). In both cases, it is equivalent to n.\n\nExample:\n++x\n--y\n\n\n\nUse instead:\n\n\nx += 1\ny -= 1\n\n# Idiom B003 (assignment-to-os-environ)\n\nDefinition: Checks for assignments to os.environ.\n\nRationale: In Python, os.environ is a mapping that represents the environment of the\ncurrent process.\n\n\nHowever, reassigning to os.environ does not clear the environment. Instead,\nit merely updates the os.environ for the current process. This can lead to\nunexpected behavior, especially when running the program in a subprocess.\n\n\nInstead, use os.environ.clear() to clear the environment, or use the\nenv argument of subprocess.Popen to pass a custom environment to\na subprocess.\n\nExample:\nimport os\n\nos.environ = {\"foo\": \"bar\"}\n\n\n\nUse instead:\n\n\nimport os\n\nos.environ.clear()\nos.environ[\"foo\"] = \"bar\"\n\n# Idiom B004 (unreliable-callable-check)\n\nDefinition: Checks for uses of hasattr to test if an object is callable (e.g.,\nhasattr(obj, \"__call__\")).\n\nRationale: Using hasattr is an unreliable mechanism for testing if an object is\ncallable. If obj implements a custom __getattr__, or if its __call__\nis itself not callable, you may get misleading results.\n\n\nInstead, use callable(obj) to test if obj is callable.\n\nExample:\nhasattr(obj, \"__call__\")\n\n\n\nUse instead:\n\n\ncallable(obj)\n\n# Idiom B005 (strip-with-multi-characters)\n\nDefinition: Checks for uses of multi-character strings in .strip(), .lstrip(), and\n.rstrip() calls.\n\nRationale: All characters in the call to .strip(), .lstrip(), or .rstrip() are\nremoved from the leading and trailing ends of the string. If the string\ncontains multiple characters, the reader may be misled into thinking that\na prefix or suffix is being removed, rather than a set of characters.\n\n\nIn Python 3.9 and later, you can use str.removeprefix and\nstr.removesuffix to remove an exact prefix or suffix from a string,\nrespectively, which should be preferred when possible.\n\nExample:\n\"text.txt\".strip(\".txt\")  # \"e\"\n\n\n\nUse instead:\n\n\n\"text.txt\".removesuffix(\".txt\")  # \"text\"\n\n# Idiom B006 (mutable-argument-default)\n\nDefinition: Checks for uses of mutable objects as function argument defaults.\n\nRationale: Function defaults are evaluated once, when the function is defined.\n\n\nThe same mutable object is then shared across all calls to the function.\nIf the object is modified, those modifications will persist across calls,\nwhich can lead to unexpected behavior.\n\n\nInstead, prefer to use immutable data structures, or take None as a\ndefault, and initialize a new mutable object inside the function body\nfor each call.\n\n\nArguments with immutable type annotations will be ignored by this rule.\nTypes outside of the standard library can be marked as immutable with the\nlint.flake8-bugbear.extend-immutable-calls configuration option.\n\nExample:\ndef add_to_list(item, some_list=[]):\n    some_list.append(item)\n    return some_list\n\n\nl1 = add_to_list(0)  # [0]\nl2 = add_to_list(1)  # [0, 1]\n\n\n\nUse instead:\n\n\ndef add_to_list(item, some_list=None):\n    if some_list is None:\n        some_list = []\n    some_list.append(item)\n    return some_list\n\n\nl1 = add_to_list(0)  # [0]\nl2 = add_to_list(1)  # [1]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed within a given Python code to figure out whether the idiom is present in the code.", "response": "To identify the presence of the specified idioms in a given Python code, we need to scrutinize the code for specific constructs or patterns associated with each idiom. Below is an exhaustive list of such constructs and patterns:\n\n1. **Idiom B002 (unary-prefix-increment-decrement)**:\n   - Look for occurrences of `++` or `--` before a variable name.\n   - Example constructs to analyze:\n     - `++variable_name`\n     - `--variable_name`\n\n2. **Idiom B003 (assignment-to-os-environ)**:\n   - Look for direct assignments to `os.environ`.\n   - Ensure that `os.environ` is not mistakenly cleared or overwritten without using `os.environ.clear()`.\n   - Example constructs to analyze:\n     - `os.environ = {...}`\n     - Verifying correct use of `os.environ.clear()` when attempting to clear the environment settings.\n\n3. **Idiom B004 (unreliable-callable-check)**:\n   - Look for calls to `hasattr` with `\"__call__\"` as an argument to determine if an object is callable.\n   - Example constructs to analyze:\n     - `hasattr(obj, \"__call__\")`\n\n4. **Idiom B005 (strip-with-multi-characters)**:\n   - Look for uses of `.strip()`, `.lstrip()`, or `.rstrip()` with string arguments containing multiple characters.\n   - Check for the opportunity to replace it with `str.removeprefix` or `str.removesuffix` when a specific prefix or suffix is being removed.\n   - Example constructs to analyze:\n     - `\"some_string\".strip(\"multi_characters\")`\n     - `\"some_string\".lstrip(\"multi_characters\")`\n     - `\"some_string\".rstrip(\"multi_characters\")`\n\n5. **Idiom B006 (mutable-argument-default)**:\n   - Look for function definitions with mutable default arguments, such as lists or dictionaries.\n   - Example constructs to analyze:\n     - `def function_name(arg=[])`\n     - `def function_name(arg={})`\n   - Verify if `None` is used as a default and then replaced with a new mutable object within the function.\n\nBy reviewing these specific constructs within Python code, we can identify the presence of the idioms and ensure that the code follows best practices to avoid potential bugs or maintain confusion."}
{"id": "rull_linter/N806-N807-N811-N812-N813", "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom N806 (non-lowercase-variable-in-function)\n\nDefinition: Checks for the use of non-lowercase variable names in functions.\n\nRationale: PEP 8 recommends that all function variables use lowercase names:\n\n\n\nFunction names should be lowercase, with words separated by underscores as necessary to\nimprove readability. Variable names follow the same convention as function names. mixedCase\nis allowed only in contexts where that's already the prevailing style (e.g. threading.py),\nto retain backwards compatibility.\n\nExample:\ndef my_function(a):\n    B = a + 3\n    return B\n\n\n\nUse instead:\n\n\ndef my_function(a):\n    b = a + 3\n    return b\n\n# Idiom N807 (dunder-function-name)\n\nDefinition: Checks for functions with \"dunder\" names (that is, names with two\nleading and trailing underscores) that are not documented.\n\nRationale: PEP 8 recommends that only documented \"dunder\" methods are used:\n\n\n\n...\"magic\" objects or attributes that live in user-controlled\nnamespaces. E.g. __init__, __import__ or __file__. Never invent\nsuch names; only use them as documented.\n\nExample:\ndef __my_function__():\n    pass\n\n\n\nUse instead:\n\n\ndef my_function():\n    pass\n\n# Idiom N811 (constant-imported-as-non-constant)\n\nDefinition: Checks for constant imports that are aliased to non-constant-style\nnames.\n\nRationale: PEP 8 recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\nExample:\nfrom example import CONSTANT_VALUE as ConstantValue\n\n\n\nUse instead:\n\n\nfrom example import CONSTANT_VALUE\n\n# Idiom N812 (lowercase-imported-as-non-lowercase)\n\nDefinition: Checks for lowercase imports that are aliased to non-lowercase names.\n\nRationale: PEP 8 recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\nExample:\nfrom example import myclassname as MyClassName\n\n\n\nUse instead:\n\n\nfrom example import myclassname\n\n# Idiom N813 (camelcase-imported-as-lowercase)\n\nDefinition: Checks for CamelCase imports that are aliased to lowercase names.\n\nRationale: PEP 8 recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\nExample:\nfrom example import MyClassName as myclassname\n\n\n\nUse instead:\n\n\nfrom example import MyClassName\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed within a given Python code to figure out whether the idiom is present in the code.", "response": "To identify the presence of the listed idioms in a given Python code, the following constructs and patterns should be closely analyzed:\n\n1. **Variable Naming within Functions**:\n    - Check all variable names declared within functions to see if any are not in lowercase (Idiom N806).\n    - Example: `B = a + 3` should be `b = a + 3`.\n\n2. **Function Naming and Documentation**:\n    - Look for function names that are surrounded by double underscores (dunder) and verify that they are documented if they are not standard Python dunder methods (Idiom N807).\n    - Example: `def __my_function__():` should be replaced by `def my_function():` unless it is a documented use of a dunder method.\n\n3. **Import Aliases for Constants**:\n    - Check imports that involve constants and ensure their aliases, if any, also reflect a constant-style naming (Idiom N811).\n    - Example: `from example import CONSTANT_VALUE as ConstantValue` should be `from example import CONSTANT_VALUE`.\n\n4. **Import Aliases for Lowercase Identifiers**:\n    - Inspect imports involving identifiers that are in lowercase and verify that any aliases also use lowercase naming (Idiom N812).\n    - Example: `from example import myclassname as MyClassName` should be `from example import myclassname`.\n\n5. **Import Aliases for CamelCase Identifiers**:\n    - Review imports involving CamelCase identifiers to ensure that any alias maintains CamelCase style (Idiom N813).\n    - Example: `from example import MyClassName as myclassname` should be `from example import MyClassName`.\n\nIn summary, during code review or static analysis, you should specifically look for:\n- Variable names within functions that are not all lowercase.\n- Dunder function names without appropriate documentation.\n- Import statements where the alias naming style does not match the imported entity:\n   - Constants imported as non-constant aliases.\n   - Lowercase names imported as non-lowercase aliases.\n   - CamelCase names imported as lowercase aliases.\n\nThis systematic analysis will help in identifying and rectifying the presence of these idioms which deviate from the PEP 8 recommendations."}
{"id": "rull_linter/UP001-UP003-UP004-UP005-UP006", "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom UP001 (useless-metaclass-type)\n\nDefinition: Checks for the use of __metaclass__ = type in class definitions.\n\nRationale: Since Python 3, __metaclass__ = type is implied and can thus be omitted.\n\nExample:\nclass Foo:\n    __metaclass__ = type\n\n\n\nUse instead:\n\n\nclass Foo: ...\n\n# Idiom UP003 (type-of-primitive)\n\nDefinition: Checks for uses of type that take a primitive as an argument.\n\nRationale: type() returns the type of a given object. A type of a primitive can\nalways be known in advance and accessed directly, which is more concise\nand explicit than using type().\n\nExample:\ntype(1)\n\n\n\nUse instead:\n\n\nint\n\n# Idiom UP004 (useless-object-inheritance)\n\nDefinition: Checks for classes that inherit from object.\n\nRationale: Since Python 3, all classes inherit from object by default, so object can\nbe omitted from the list of base classes.\n\nExample:\nclass Foo(object): ...\n\n\n\nUse instead:\n\n\nclass Foo: ...\n\n# Idiom UP005 (deprecated-unittest-alias)\n\nDefinition: Checks for uses of deprecated methods from the unittest module.\n\nRationale: The unittest module has deprecated aliases for some of its methods.\nThe deprecated aliases were removed in Python 3.12. Instead of aliases,\nuse their non-deprecated counterparts.\n\nExample:\nfrom unittest import TestCase\n\n\nclass SomeTest(TestCase):\n    def test_something(self):\n        self.assertEquals(1, 1)\n\n\n\nUse instead:\n\n\nfrom unittest import TestCase\n\n\nclass SomeTest(TestCase):\n    def test_something(self):\n        self.assertEqual(1, 1)\n\n# Idiom UP006 (non-pep585-annotation)\n\nDefinition: Checks for the use of generics that can be replaced with standard library\nvariants based on PEP 585.\n\nRationale: PEP 585 enabled collections in the Python standard library (like list)\nto be used as generics directly, instead of importing analogous members\nfrom the typing module (like typing.List).\n\n\nWhen available, the PEP 585 syntax should be used instead of importing\nmembers from the typing module, as it's more concise and readable.\nImporting those members from typing is considered deprecated as of PEP\n585.\n\n\nThis rule is enabled when targeting Python 3.9 or later (see:\ntarget-version). By default, it's also enabled for earlier Python\nversions if from __future__ import annotations is present, as\n__future__ annotations are not evaluated at runtime. If your code relies\non runtime type annotations (either directly or via a library like\nPydantic), you can disable this behavior for Python versions prior to 3.9\nby setting lint.pyupgrade.keep-runtime-typing to true.\n\nExample:\nfrom typing import List\n\nfoo: List[int] = [1, 2, 3]\n\n\n\nUse instead:\n\n\nfoo: list[int] = [1, 2, 3]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed within a given Python code to figure out whether the idiom is present in the code.", "response": "To effectively analyze a given Python code for the presence of specified idioms, the following constructs should be closely scrutinized:\n\n1. **Class Definitions and Metaclasses:**\n   - Look for the usage of `__metaclass__ = type` within class definitions. This applies to **Idiom UP001**.\n\n2. **Type Checking on Primitives:**\n   - Identify constructs that use `type()` with primitive types as arguments (e.g., `type(1)`, `type(\"string\")`). These should be replaced with the respective type name (e.g., `int`, `str`). This applies to **Idiom UP003**.\n\n3. **Inheritance from `object`:**\n   - Examine class definitions that explicitly inherit from `object` (e.g., `class Foo(object):`). This can be omitted in Python 3 and later. This applies to **Idiom UP004**.\n\n4. **Deprecated `unittest` Methods:**\n   - Check for uses of deprecated `unittest` aliases like `assertEquals`, which should be replaced by their non-deprecated counterparts like `assertEqual`. This applies to **Idiom UP005**.\n\n5. **Generics and Type Annotations:**\n   - Look for imports from the `typing` module for generics that can be replaced with standard library equivalents as per PEP 585 (e.g., `from typing import List` with `List[int]` being replaced by `list[int]`). This applies to **Idiom UP006**.\n   - Additionally, check for the presence of `from __future__ import annotations` in Python versions before 3.9, which allows using new annotation syntax without runtime evaluation.\n\nBy closely analyzing these constructs, one can identify instances of the specified idioms within Python code, encouraging more modern, efficient, and clear coding practices."}
{"id": "rull_linter/E402-E701-E721-E741-E743", "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom E402 (module-import-not-at-top-of-file)\n\nDefinition: Checks for imports that are not at the top of the file.\n\nRationale: According to PEP 8, \"imports are always put at the top of the file, just after any\nmodule comments and docstrings, and before module globals and constants.\"\n\n\nThis rule makes an exception for both sys.path modifications (allowing for\nsys.path.insert, sys.path.append, etc.) and os.environ modifications\nbetween imports.\n\nExample:\n\"One string\"\n\"Two string\"\na = 1\nimport os\nfrom sys import x\n\n\n\nUse instead:\n\n\nimport os\nfrom sys import x\n\n\"One string\"\n\"Two string\"\na = 1\n\n# Idiom E701 (multiple-statements-on-one-line-colon)\n\nDefinition: Checks for compound statements (multiple statements on the same line).\n\nRationale: According to PEP 8, \"compound statements are generally discouraged\".\n\nExample:\nif foo == \"blah\": do_blah_thing()\n\n\n\nUse instead:\n\n\nif foo == \"blah\":\n    do_blah_thing()\n\n# Idiom E721 (type-comparison)\n\nDefinition: Checks for object type comparisons using == and other comparison\noperators.\n\nRationale: Unlike a direct type comparison, isinstance will also check if an object\nis an instance of a class or a subclass thereof.\n\n\nIf you want to check for an exact type match, use is or is not.\n\nExample:\nif type(obj) == type(1):\n    pass\n\nif type(obj) == int:\n    pass\n\n\n\nUse instead:\n\n\nif isinstance(obj, int):\n    pass\n\n# Idiom E741 (ambiguous-variable-name)\n\nDefinition: Checks for the use of the characters 'l', 'O', or 'I' as variable names.\n\n\nNote: This rule is automatically disabled for all stub files\n(files with .pyi extensions). The rule has little relevance for authors\nof stubs: a well-written stub should aim to faithfully represent the\ninterface of the equivalent .py file as it exists at runtime, including any\nambiguously named variables in the runtime module.\n\nRationale: In some fonts, these characters are indistinguishable from the\nnumerals one and zero. When tempted to use 'l', use 'L' instead.\n\nExample:\nl = 0\nO = 123\nI = 42\n\n\n\nUse instead:\n\n\nL = 0\no = 123\ni = 42\n\n# Idiom E743 (ambiguous-function-name)\n\nDefinition: Checks for the use of the characters 'l', 'O', or 'I' as function names.\n\nRationale: In some fonts, these characters are indistinguishable from the\nnumerals one and zero. When tempted to use 'l', use 'L' instead.\n\nExample:\ndef l(x): ...\n\n\n\nUse instead:\n\n\ndef long_name(x): ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed within a given Python code to figure out whether the idiom is present in the code.", "response": "To effectively analyze Python code for the presence of the specified idioms, we need to look for certain constructs or patterns. Here's an exhaustive list of constructs that should be closely analyzed:\n\n1. **Imports and Their Placement (Idiom E402):**\n   - Look for any `import` statements not located at the top of the file (ignoring those following `sys.path` and `os.environ` modifications). \n   - Check for misplaced imports that appear after variable definitions, function definitions, or executable code segments.\n\n2. **Compound Statements (Idiom E701):**\n   - Identify any lines containing multiple statements, especially those separated by a semicolon (`;`) or using a colon (`:`) for multiple statements on the same line.\n   - Pay particular attention to control structures like `if`, `for`, `while`, `try`, etc., with statements directly following a colon.\n\n3. **Type Comparisons (Idiom E721):**\n   - Locate any usage of `type(obj) ==` or `type(obj) !=`.\n   - Check comparisons using `==`, `!=`, `<`, `<=`, `>`, `>=` with `type()` function calls.\n   - Determine if `isinstance()` could be used instead.\n\n4. **Ambiguous Variable Names (Idiom E741):**\n   - Check for usage of single-character variable names 'l', 'O', or 'I'.\n   - Analyze all variable declaration and usage points to ensure names are clear and not using these ambiguous characters.\n\n5. **Ambiguous Function Names (Idiom E743):**\n   - Inspect any function definitions using the names 'l', 'O', or 'I'.\n   - Confirm that function names are descriptive and do not utilize ambiguous naming conventions.\n\nFor a thorough check, automated tools like linters (e.g., `flake8`, `pylint`) are helpful as they are designed to catch these and other stylistic issues in Python code. Nonetheless, manual code review can also be effective, particularly when integrated with these automated checks, ensuring that all facets of these idioms are observed."}
{"id": "rull_linter/F405-F501-F502-F601-F621", "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom F405 (undefined-local-with-import-star-usage)\n\nDefinition: Checks for names that might be undefined, but may also be defined in a\nwildcard import.\n\nRationale: Wildcard imports (e.g., from module import *) make it hard to determine\nwhich symbols are available in the current namespace. If a module contains\na wildcard import, and a name in the current namespace has not been\nexplicitly defined or imported, then it's unclear whether the name is\nundefined or was imported by the wildcard import.\n\n\nIf the name is defined in via a wildcard import, that member should be\nimported explicitly to avoid confusion.\n\n\nIf the name is not defined in a wildcard import, it should be defined or\nimported.\n\nExample:\nfrom math import *\n\n\ndef area(radius):\n    return pi * radius**2\n\n\n\nUse instead:\n\n\nfrom math import pi\n\n\ndef area(radius):\n    return pi * radius**2\n\n# Idiom F501 (percent-format-invalid-format)\n\nDefinition: Checks for invalid printf-style format strings.\n\nRationale: Conversion specifiers are required for printf-style format strings. These\nspecifiers must contain a % character followed by a conversion type.\n\nExample:\n\"Hello, %\" % \"world\"\n\n\n\nUse instead:\n\n\n\"Hello, %s\" % \"world\"\n\n# Idiom F502 (percent-format-expected-mapping)\n\nDefinition: Checks for named placeholders in printf-style format strings without\nmapping-type values.\n\nRationale: When using named placeholders in printf-style format strings, the values\nmust be a map type (such as a dictionary). Otherwise, the expression will\nraise a TypeError.\n\nExample:\n\"%(greeting)s, %(name)s\" % (\"Hello\", \"World\")\n\n\n\nUse instead:\n\n\n\"%(greeting)s, %(name)s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n\n\n\nOr:\n\n\n\"%s, %s\" % (\"Hello\", \"World\")\n\n# Idiom F601 (multi-value-repeated-key-literal)\n\nDefinition: Checks for dictionary literals that associate multiple values with the\nsame key.\n\nRationale: Dictionary keys should be unique. If a key is associated with multiple values,\nthe earlier values will be overwritten. Including multiple values for the\nsame key in a dictionary literal is likely a mistake.\n\nExample:\nfoo = {\n    \"bar\": 1,\n    \"baz\": 2,\n    \"baz\": 3,\n}\nfoo[\"baz\"]  # 3\n\n\n\nUse instead:\n\n\nfoo = {\n    \"bar\": 1,\n    \"baz\": 2,\n}\nfoo[\"baz\"]  # 2\n\n# Idiom F621 (expressions-in-star-assignment)\n\nDefinition: Checks for the use of too many expressions in starred assignment statements.\n\nRationale: In assignment statements, starred expressions can be used to unpack iterables.\n\n\nIn Python 3, no more than 1 \\<< 8 assignments are allowed before a starred\nexpression, and no more than 1 \\<< 24 expressions are allowed after a starred\nexpression.\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed within a given Python code to figure out whether the idiom is present in the code.", "response": "To effectively analyze Python code for the presence of the given idioms, we can compile a list of specific code constructs and patterns associated with each idiom. This list can guide the review process to identify potential issues or violations:\n\n1. **Idiom F405 (undefined-local-with-import-star-usage)**\n   - Look for wildcard imports using `from module import *`.\n   - Check for variable or function usage in the code that hasn't been explicitly defined or imported.\n   - Analyze if those undeclared names could be part of the wildcard import and recommend explicit imports for clarity.\n\n2. **Idiom F501 (percent-format-invalid-format)**\n   - Scan for string interpolation using the `%` operator.\n   - Identify instances where the placeholder `%` is used without a conversion type, e.g., `\"%\"` instead of `\"%s\"`, `\"%d\"`, etc.\n   - Validate that every `%` is followed by an appropriate conversion specifier.\n\n3. **Idiom F502 (percent-format-expected-mapping)**\n   - Identify printf-style strings that use named placeholders, e.g., `\"%(key)s\"`.\n   - Check whether the corresponding substitution is a mapping type (e.g., a dictionary).\n   - Ensure that named placeholders are not erroneously paired with tuple-like values unless tuple-style placeholders (e.g., `%s`) are used.\n\n4. **Idiom F601 (multi-value-repeated-key-literal)**\n   - Analyze dictionary literals to check for repeated keys.\n   - Ensure each key in a dictionary literal is unique.\n   - Highlight cases where multiple values are associated with the same key as potential logical errors.\n\n5. **Idiom F621 (expressions-in-star-assignment)**\n   - Look for assignment statements that use the unpacking operator (`*`).\n   - Verify that the number of expressions before the `*` does not exceed 256 (`<< 8`).\n   - Verify that the number of expressions after the `*` does not exceed 16,777,215 (`<< 24`).\n   - Ensure starred expressions are used within allowable limits to prevent syntax errors.\n\nBy focusing on these constructs and patterns, a thorough analysis can be conducted to detect violations of the idioms and to suggest possible corrections or improvements in the code."}
{"id": "rull_linter/UP044-UP045-UP046-UP047-UP040", "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom UP044 (non-pep646-unpack)\n\nDefinition: Checks for uses of Unpack[] on Python 3.11 and above, and suggests\nusing * instead.\n\nRationale: PEP 646 introduced a new syntax for unpacking sequences based on the *\noperator. This syntax is more concise and readable than the previous\nUnpack[] syntax.\n\nExample:\nfrom typing import Unpack\n\n\ndef foo(*args: Unpack[tuple[int, ...]]) -> None:\n    pass\n\n\n\nUse instead:\n\n\ndef foo(*args: *tuple[int, ...]) -> None:\n    pass\n\n# Idiom UP045 (non-pep604-annotation-optional)\n\nDefinition: Check for typing.Optional annotations that can be rewritten based on PEP 604 syntax.\n\nRationale: PEP 604 introduced a new syntax for union type annotations based on the\n| operator. This syntax is more concise and readable than the previous\ntyping.Optional syntax.\n\n\nThis rule is enabled when targeting Python 3.10 or later (see:\ntarget-version). By default, it's also enabled for earlier Python\nversions if from __future__ import annotations is present, as\n__future__ annotations are not evaluated at runtime. If your code relies\non runtime type annotations (either directly or via a library like\nPydantic), you can disable this behavior for Python versions prior to 3.10\nby setting lint.pyupgrade.keep-runtime-typing to true.\n\nExample:\nfrom typing import Optional\n\nfoo: Optional[int] = None\n\n\n\nUse instead:\n\n\nfoo: int | None = None\n\n# Idiom UP046 (non-pep695-generic-class)\n\nDefinition: Checks for use of standalone type variables and parameter specifications in generic classes.\n\nRationale: Special type parameter syntax was introduced in Python 3.12 by PEP 695 for defining generic\nclasses. This syntax is easier to read and provides cleaner support for generics.\n\nExample:\nfrom typing import TypeVar\n\nT = TypeVar(\"T\")\n\n\nclass GenericClass(Generic[T]):\n    var: T\n\n\n\nUse instead:\n\n\nclass GenericClass[T]:\n    var: T\n\n# Idiom UP047 (non-pep695-generic-function)\n\nDefinition: Checks for use of standalone type variables and parameter specifications in generic functions.\n\nRationale: Special type parameter syntax was introduced in Python 3.12 by PEP 695 for defining generic\nfunctions. This syntax is easier to read and provides cleaner support for generics.\n\nExample:\nfrom typing import TypeVar\n\nT = TypeVar(\"T\")\n\n\ndef generic_function(var: T) -> T:\n    return var\n\n\n\nUse instead:\n\n\ndef generic_function[T](var: T) -> T:\n    return var\n\n# Idiom UP040 (non-pep695-type-alias)\n\nDefinition: Checks for use of TypeAlias annotations and TypeAliasType assignments\nfor declaring type aliases.\n\nRationale: The type keyword was introduced in Python 3.12 by PEP 695 for defining\ntype aliases. The type keyword is easier to read and provides cleaner\nsupport for generics.\n\nExample:\nListOfInt: TypeAlias = list[int]\nPositiveInt = TypeAliasType(\"PositiveInt\", Annotated[int, Gt(0)])\n\n\n\nUse instead:\n\n\ntype ListOfInt = list[int]\ntype PositiveInt = Annotated[int, Gt(0)]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed within a given Python code to figure out whether the idiom is present in the code.", "response": "To determine whether any of the provided idioms are present in a given Python code, you should closely analyze the following specific constructs for each idiom:\n\n1. **Idiom UP044 (non-pep646-unpack)**:\n   - Look for usage of the `Unpack[]` type hint, especially in function arguments.\n   - Check if the Python version is 3.11 or above (since this idiom targets the syntax introduced by PEP 646).\n\n2. **Idiom UP045 (non-pep604-annotation-optional)**:\n   - Identify any annotations using `typing.Optional`.\n   - Check if the Python version is 3.10 or above, or check for `from __future__ import annotations`, which allows using PEP 604 syntax in earlier versions.\n   - Note if `lint.pyupgrade.keep-runtime-typing` is set to true, which affects behavior prior to Python 3.10.\n\n3. **Idiom UP046 (non-pep695-generic-class)**:\n   - Look for use of `TypeVar` and `ParameterSpec` in generic class definitions.\n   - Check if the Python version is 3.12 or above, as PEP 695 introduces syntax changes in this version.\n\n4. **Idiom UP047 (non-pep695-generic-function)**:\n   - Identify uses of `TypeVar` and `ParameterSpec` in generic function definitions.\n   - Check for compatibility with Python version 3.12 or above, where the new syntax from PEP 695 can be applied.\n\n5. **Idiom UP040 (non-pep695-type-alias)**:\n   - Look for `TypeAlias` annotations and `TypeAliasType` assignments.\n   - Consider transition to using the `type` keyword for defining type aliases in Python 3.12 or above.\n\nBy focusing on these constructs, you can effectively determine the presence of each idiom within a codebase and suggest appropriate idiomatic changes for enhanced readability and maintainability."}
