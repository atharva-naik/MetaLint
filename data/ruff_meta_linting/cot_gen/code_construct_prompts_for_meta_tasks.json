[
    {
        "id": "rull_linter/FURB161-FURB162-FURB163-FURB164",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom FURB161 (bit-count)\n\nDefinition: Checks for uses of bin(...).count(\"1\") to perform a population count.\n\nRationale: In Python 3.10, a bit_count() method was added to the int class,\nwhich is more concise and efficient than converting to a binary\nrepresentation via bin(...).\n\nExample:\nx = bin(123).count(\"1\")\ny = bin(0b1111011).count(\"1\")\n\n\n\nUse instead:\n\n\nx = (123).bit_count()\ny = 0b1111011.bit_count()\n\n# Idiom FURB162 (fromisoformat-replace-z)\n\nDefinition: Checks for datetime.fromisoformat() calls\nwhere the only argument is an inline replacement\nof Z with a zero offset timezone.\n\nRationale: On Python 3.11 and later, datetime.fromisoformat() can handle most ISO 8601\nformats including ones affixed with Z, so such an operation is unnecessary.\n\n\nMore information on unsupported formats\ncan be found in the official documentation.\n\nExample:\nfrom datetime import datetime\n\n\ndate = \"2025-01-01T00:00:00Z\"\n\ndatetime.fromisoformat(date.replace(\"Z\", \"+00:00\"))\ndatetime.fromisoformat(date[:-1] + \"-00\")\ndatetime.fromisoformat(date.strip(\"Z\", \"-0000\"))\ndatetime.fromisoformat(date.rstrip(\"Z\", \"-00:00\"))\n\n\n\nUse instead:\n\n\nfrom datetime import datetime\n\n\ndate = \"2025-01-01T00:00:00Z\"\n\ndatetime.fromisoformat(date)\n\n# Idiom FURB163 (redundant-log-base)\n\nDefinition: Checks for math.log calls with a redundant base.\n\nRationale: The default base of math.log is e, so specifying it explicitly is\nredundant.\n\n\nInstead of passing 2 or 10 as the base, use math.log2 or math.log10\nrespectively, as these dedicated variants are typically more accurate\nthan math.log.\n\nExample:\nimport math\n\nmath.log(4, math.e)\nmath.log(4, 2)\nmath.log(4, 10)\n\n\n\nUse instead:\n\n\nimport math\n\nmath.log(4)\nmath.log2(4)\nmath.log10(4)\n\n# Idiom FURB164 (unnecessary-from-float)\n\nDefinition: Checks for unnecessary from_float and from_decimal usages to construct\nDecimal and Fraction instances.\n\nRationale: Since Python 3.2, the Fraction and Decimal classes can be constructed\nby passing float or decimal instances to the constructor directly. As such,\nthe use of from_float and from_decimal methods is unnecessary, and\nshould be avoided in favor of the more concise constructor syntax.\n\nExample:\nDecimal.from_float(4.2)\nDecimal.from_float(float(\"inf\"))\nFraction.from_float(4.2)\nFraction.from_decimal(Decimal(\"4.2\"))\n\n\n\nUse instead:\n\n\nDecimal(4.2)\nDecimal(\"inf\")\nFraction(4.2)\nFraction(Decimal(4.2))\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/RET505-RET506-RET507-RET508",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom RET505 (superfluous-else-return)\n\nDefinition: Checks for else statements with a return statement in the preceding\nif block.\n\nRationale: The else statement is not needed as the return statement will always\nbreak out of the enclosing function. Removing the else will reduce\nnesting and make the code more readable.\n\nExample:\ndef foo(bar, baz):\n    if bar:\n        return 1\n    else:\n        return baz\n\n\n\nUse instead:\n\n\ndef foo(bar, baz):\n    if bar:\n        return 1\n    return baz\n\n# Idiom RET506 (superfluous-else-raise)\n\nDefinition: Checks for else statements with a raise statement in the preceding if\nblock.\n\nRationale: The else statement is not needed as the raise statement will always\nbreak out of the current scope. Removing the else will reduce nesting\nand make the code more readable.\n\nExample:\ndef foo(bar, baz):\n    if bar == \"Specific Error\":\n        raise Exception(bar)\n    else:\n        raise Exception(baz)\n\n\n\nUse instead:\n\n\ndef foo(bar, baz):\n    if bar == \"Specific Error\":\n        raise Exception(bar)\n    raise Exception(baz)\n\n# Idiom RET507 (superfluous-else-continue)\n\nDefinition: Checks for else statements with a continue statement in the preceding\nif block.\n\nRationale: The else statement is not needed, as the continue statement will always\ncontinue onto the next iteration of a loop. Removing the else will reduce\nnesting and make the code more readable.\n\nExample:\ndef foo(bar, baz):\n    for i in bar:\n        if i < baz:\n            continue\n        else:\n            x = 0\n\n\n\nUse instead:\n\n\ndef foo(bar, baz):\n    for i in bar:\n        if i < baz:\n            continue\n        x = 0\n\n# Idiom RET508 (superfluous-else-break)\n\nDefinition: Checks for else statements with a break statement in the preceding if\nblock.\n\nRationale: The else statement is not needed, as the break statement will always\nbreak out of the loop. Removing the else will reduce nesting and make the\ncode more readable.\n\nExample:\ndef foo(bar, baz):\n    for i in bar:\n        if i > baz:\n            break\n        else:\n            x = 0\n\n\n\nUse instead:\n\n\ndef foo(bar, baz):\n    for i in bar:\n        if i > baz:\n            break\n        x = 0\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLR5501-PLR6104-PLR6201-PLR6301",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLR5501 (collapsible-else-if)\n\nDefinition: Checks for else blocks that consist of a single if statement.\n\nRationale: If an else block contains a single if statement, it can be collapsed\ninto an elif, thus reducing the indentation level.\n\nExample:\ndef check_sign(value: int) -> None:\n    if value > 0:\n        print(\"Number is positive.\")\n    else:\n        if value < 0:\n            print(\"Number is negative.\")\n        else:\n            print(\"Number is zero.\")\n\n\n\nUse instead:\n\n\ndef check_sign(value: int) -> None:\n    if value > 0:\n        print(\"Number is positive.\")\n    elif value < 0:\n        print(\"Number is negative.\")\n    else:\n        print(\"Number is zero.\")\n\n# Idiom PLR6104 (non-augmented-assignment)\n\nDefinition: Checks for assignments that can be replaced with augmented assignment\nstatements.\n\nRationale: If the right-hand side of an assignment statement consists of a binary\noperation in which one operand is the same as the assignment target,\nit can be rewritten as an augmented assignment. For example, x = x + 1\ncan be rewritten as x += 1.\n\n\nWhen performing such an operation, an augmented assignment is more concise\nand idiomatic.\n\nExample:\nx = x + 1\n\n\n\nUse instead:\n\n\nx += 1\n\n# Idiom PLR6201 (literal-membership)\n\nDefinition: Checks for membership tests on list and tuple literals.\n\nRationale: When testing for membership in a static sequence, prefer a set literal\nover a list or tuple, as Python optimizes set membership tests.\n\nExample:\n1 in [1, 2, 3]\n\n\n\nUse instead:\n\n\n1 in {1, 2, 3}\n\n# Idiom PLR6301 (no-self-use)\n\nDefinition: Checks for the presence of unused self parameter in methods definitions.\n\nRationale: Unused self parameters are usually a sign of a method that could be\nreplaced by a function, class method, or static method.\n\nExample:\nclass Person:\n    def greeting(self):\n        print(\"Greetings friend!\")\n\n\n\nUse instead:\n\n\ndef greeting():\n    print(\"Greetings friend!\")\n\n\n\nor\n\n\nclass Person:\n    @staticmethod\n    def greeting():\n        print(\"Greetings friend!\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLW1509-PLW1510-PLW1514-PLW1641",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLW1509 (subprocess-popen-preexec-fn)\n\nDefinition: Checks for uses of subprocess.Popen with a preexec_fn argument.\n\nRationale: The preexec_fn argument is unsafe within threads as it can lead to\ndeadlocks. Furthermore, preexec_fn is targeted for deprecation.\n\n\nInstead, consider using task-specific arguments such as env,\nstart_new_session, and process_group. These are not prone to deadlocks\nand are more explicit.\n\nExample:\nimport os, subprocess\n\nsubprocess.Popen(foo, preexec_fn=os.setsid)\nsubprocess.Popen(bar, preexec_fn=os.setpgid(0, 0))\n\n\n\nUse instead:\n\n\nimport subprocess\n\nsubprocess.Popen(foo, start_new_session=True)\nsubprocess.Popen(bar, process_group=0)  # Introduced in Python 3.11\n\n# Idiom PLW1510 (subprocess-run-without-check)\n\nDefinition: Checks for uses of subprocess.run without an explicit check argument.\n\nRationale: By default, subprocess.run does not check the return code of the process\nit runs. This can lead to silent failures.\n\n\nInstead, consider using check=True to raise an exception if the process\nfails, or set check=False explicitly to mark the behavior as intentional.\n\nExample:\nimport subprocess\n\nsubprocess.run([\"ls\", \"nonexistent\"])  # No exception raised.\n\n\n\nUse instead:\n\n\nimport subprocess\n\nsubprocess.run([\"ls\", \"nonexistent\"], check=True)  # Raises exception.\n\n\n\nOr:\n\n\nimport subprocess\n\nsubprocess.run([\"ls\", \"nonexistent\"], check=False)  # Explicitly no check.\n\n# Idiom PLW1514 (unspecified-encoding)\n\nDefinition: Checks for uses of open and related calls without an explicit encoding\nargument.\n\nRationale: Using open in text mode without an explicit encoding can lead to\nnon-portable code, with differing behavior across platforms. While readers\nmay assume that UTF-8 is the default encoding, in reality, the default\nis locale-specific.\n\n\nInstead, consider using the encoding parameter to enforce a specific\nencoding. PEP 597 recommends the use of encoding=\"utf-8\" as a default,\nand suggests that it may become the default in future versions of Python.\n\n\nIf a locale-specific encoding is intended, use encoding=\"locale\" on\nPython 3.10 and later, or locale.getpreferredencoding() on earlier versions,\nto make the encoding explicit.\n\nExample:\nopen(\"file.txt\")\n\n\n\nUse instead:\n\n\nopen(\"file.txt\", encoding=\"utf-8\")\n\n# Idiom PLW1641 (eq-without-hash)\n\nDefinition: Checks for classes that implement __eq__ but not __hash__.\n\nRationale: A class that implements __eq__ but not __hash__ will have its hash\nmethod implicitly set to None, regardless of if a super class defines\n__hash__. This will cause the class to be unhashable, will in turn\ncause issues when using the class as a key in a dictionary or a member\nof a set.\n\nExample:\nclass Person:\n    def __init__(self):\n        self.name = \"monty\"\n\n    def __eq__(self, other):\n        return isinstance(other, Person) and other.name == self.name\n\n\n\nUse instead:\n\n\nclass Person:\n    def __init__(self):\n        self.name = \"monty\"\n\n    def __eq__(self, other):\n        return isinstance(other, Person) and other.name == self.name\n\n    def __hash__(self):\n        return hash(self.name)\n\n\n\nThis issue is particularly tricky with inheritance. Even if a parent class correctly implements\nboth __eq__ and __hash__, overriding __eq__ in a child class without also implementing\n__hash__ will make the child class unhashable:\n\n\nclass Person:\n    def __init__(self):\n        self.name = \"monty\"\n\n    def __eq__(self, other):\n        return isinstance(other, Person) and other.name == self.name\n\n    def __hash__(self):\n        return hash(self.name)\n\n\nclass Developer(Person):\n    def __init__(self):\n        super().__init__()\n        self.language = \"python\"\n\n    def __eq__(self, other):\n        return (\n            super().__eq__(other)\n            and isinstance(other, Developer)\n            and self.language == other.language\n        )\n\n\nhash(Developer())  # TypeError: unhashable type: 'Developer'\n\n\n\nOne way to fix this is to retain the implementation of __hash__ from the parent class:\n\n\nclass Developer(Person):\n    def __init__(self):\n        super().__init__()\n        self.language = \"python\"\n\n    def __eq__(self, other):\n        return (\n            super().__eq__(other)\n            and isinstance(other, Developer)\n            and self.language == other.language\n        )\n\n    __hash__ = Person.__hash__\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PYI016-PYI017-PYI018-PYI019-PYI020",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PYI016 (duplicate-union-member)\n\nDefinition: Checks for duplicate union members.\n\nRationale: Duplicate union members are redundant and should be removed.\n\nExample:\nfoo: str | str\n\n\n\nUse instead:\n\n\nfoo: str\n\n# Idiom PYI017 (complex-assignment-in-stub)\n\nDefinition: Checks for assignments with multiple or non-name targets in stub files.\n\nRationale: In general, stub files should be thought of as \"data files\" for a type\nchecker, and are not intended to be executed. As such, it's useful to\nenforce that only a subset of Python syntax is allowed in a stub file, to\nensure that everything in the stub is unambiguous for the type checker.\n\n\nThe need to perform multi-assignment, or assignment to a non-name target,\nlikely indicates a misunderstanding of how stub files are intended to be\nused.\n\nExample:\nfrom typing import TypeAlias\n\na = b = int\n\nclass Klass: ...\n\nKlass.X: TypeAlias = int\n\n\n\nUse instead:\n\n\nfrom typing import TypeAlias\n\na: TypeAlias = int\nb: TypeAlias = int\n\nclass Klass:\n    X: TypeAlias = int\n\n# Idiom PYI018 (unused-private-type-var)\n\nDefinition: Checks for the presence of unused private TypeVar, ParamSpec or\nTypeVarTuple declarations.\n\nRationale: A private TypeVar that is defined but not used is likely a mistake. It\nshould either be used, made public, or removed to avoid confusion. A type\nvariable is considered \"private\" if its name starts with an underscore.\n\nExample:\nimport typing\nimport typing_extensions\n\n_T = typing.TypeVar(\"_T\")\n_Ts = typing_extensions.TypeVarTuple(\"_Ts\")\n\n# Idiom PYI019 (custom-type-var-for-self)\n\nDefinition: Checks for methods that use custom TypeVars in their\nannotations when they could use Self instead.\n\nRationale: While the semantics are often identical, using Self is more intuitive\nand succinct (per PEP 673) than a custom TypeVar. For example, the\nuse of Self will typically allow for the omission of type parameters\non the self and cls arguments.\n\n\nThis check currently applies to instance methods that return self,\nclass methods that return an instance of cls, class methods that return\ncls, and __new__ methods.\n\nExample:\nfrom typing import TypeVar\n\n_S = TypeVar(\"_S\", bound=\"Foo\")\n\nclass Foo:\n    def __new__(cls: type[_S], *args: str, **kwargs: int) -> _S: ...\n    def foo(self: _S, arg: bytes) -> _S: ...\n    @classmethod\n    def bar(cls: type[_S], arg: int) -> _S: ...\n\n\n\nUse instead:\n\n\nfrom typing import Self\n\nclass Foo:\n    def __new__(cls, *args: str, **kwargs: int) -> Self: ...\n    def foo(self, arg: bytes) -> Self: ...\n    @classmethod\n    def bar(cls, arg: int) -> Self: ...\n\n# Idiom PYI020 (quoted-annotation-in-stub)\n\nDefinition: Checks for quoted type annotations in stub (.pyi) files, which should be avoided.\n\nRationale: Stub files natively support forward references in all contexts, as stubs\nare never executed at runtime. (They should be thought of as \"data files\"\nfor type checkers and IDEs.) As such, quotes are never required for type\nannotations in stub files, and should be omitted.\n\nExample:\ndef function() -> \"int\": ...\n\n\n\nUse instead:\n\n\ndef function() -> int: ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/UP023-UP024-UP025-UP026-UP028",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom UP023 (deprecated-c-element-tree)\n\nDefinition: Checks for uses of the xml.etree.cElementTree module.\n\nRationale: In Python 3.3, xml.etree.cElementTree was deprecated in favor of\nxml.etree.ElementTree.\n\nExample:\nfrom xml.etree import cElementTree\n\n\n\nUse instead:\n\n\nfrom xml.etree import ElementTree\n\n# Idiom UP024 (os-error-alias)\n\nDefinition: Checks for uses of exceptions that alias OSError.\n\nRationale: OSError is the builtin error type used for exceptions that relate to the\noperating system.\n\n\nIn Python 3.3, a variety of other exceptions, like WindowsError were\naliased to OSError. These aliases remain in place for compatibility with\nolder versions of Python, but may be removed in future versions.\n\n\nPrefer using OSError directly, as it is more idiomatic and future-proof.\n\nExample:\nraise IOError\n\n\n\nUse instead:\n\n\nraise OSError\n\n# Idiom UP025 (unicode-kind-prefix)\n\nDefinition: Checks for uses of the Unicode kind prefix (u) in strings.\n\nRationale: In Python 3, all strings are Unicode by default. The Unicode kind prefix is\nunnecessary and should be removed to avoid confusion.\n\nExample:\nu\"foo\"\n\n\n\nUse instead:\n\n\n\"foo\"\n\n# Idiom UP026 (deprecated-mock-import)\n\nDefinition: Checks for imports of the mock module that should be replaced with\nunittest.mock.\n\nRationale: Since Python 3.3, mock has been a part of the standard library as\nunittest.mock. The mock package is deprecated; use unittest.mock\ninstead.\n\nExample:\nimport mock\n\n\n\nUse instead:\n\n\nfrom unittest import mock\n\n# Idiom UP028 (yield-in-for-loop)\n\nDefinition: Checks for for loops that can be replaced with yield from expressions.\n\nRationale: If a for loop only contains a yield statement, it can be replaced with a\nyield from expression, which is more concise and idiomatic.\n\nExample:\nfor x in foo:\n    yield x\n\nglobal y\nfor y in foo:\n    yield y\n\n\n\nUse instead:\n\n\nyield from foo\n\nfor _element in foo:\n    y = _element\n    yield y\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/ERA001-C901-I001-I002-BLE001",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom ERA001 (commented-out-code)\n\nDefinition: Checks for commented-out Python code.\n\nRationale: Commented-out code is dead code, and is often included inadvertently.\nIt should be removed.\n\nExample:\n# print(\"Hello, world!\")\n\n# Idiom C901 (complex-structure)\n\nDefinition: Checks for functions with a high McCabe complexity.\n\nRationale: The McCabe complexity of a function is a measure of the complexity of\nthe control flow graph of the function. It is calculated by adding\none to the number of decision points in the function. A decision\npoint is a place in the code where the program has a choice of two\nor more paths to follow.\n\n\nFunctions with a high complexity are hard to understand and maintain.\n\nExample:\ndef foo(a, b, c):\n    if a:\n        if b:\n            if c:\n                return 1\n            else:\n                return 2\n        else:\n            return 3\n    else:\n        return 4\n\n\n\nUse instead:\n\n\ndef foo(a, b, c):\n    if not a:\n        return 4\n    if not b:\n        return 3\n    if not c:\n        return 2\n    return 1\n\n# Idiom I001 (unsorted-imports)\n\nDefinition: De-duplicates, groups, and sorts imports based on the provided isort settings.\n\nRationale: Consistency is good. Use a common convention for imports to make your code\nmore readable and idiomatic.\n\nExample:\nimport pandas\nimport numpy as np\n\n\n\nUse instead:\n\n\nimport numpy as np\nimport pandas\n\n# Idiom I002 (missing-required-import)\n\nDefinition: Adds any required imports, as specified by the user, to the top of the\nfile.\n\nRationale: In some projects, certain imports are required to be present in all\nfiles. For example, some projects assume that\nfrom __future__ import annotations is enabled,\nand thus require that import to be\npresent in all files. Omitting a \"required\" import (as specified by\nthe user) can cause errors or unexpected behavior.\n\nExample:\nimport typing\n\n\n\nUse instead:\n\n\nfrom __future__ import annotations\n\nimport typing\n\n# Idiom BLE001 (blind-except)\n\nDefinition: Checks for except clauses that catch all exceptions. This includes\nbare except, except BaseException and except Exception.\n\nRationale: Overly broad except clauses can lead to unexpected behavior, such as\ncatching KeyboardInterrupt or SystemExit exceptions that prevent the\nuser from exiting the program.\n\n\nInstead of catching all exceptions, catch only those that are expected to\nbe raised in the try block.\n\nExample:\ntry:\n    foo()\nexcept BaseException:\n    ...\n\n\n\nUse instead:\n\n\ntry:\n    foo()\nexcept FileNotFoundError:\n    ...\n\n\n\nExceptions that are re-raised will not be flagged, as they're expected to\nbe caught elsewhere:\n\n\ntry:\n    foo()\nexcept BaseException:\n    raise\n\n\n\nExceptions that are logged via logging.exception() or logging.error()\nwith exc_info enabled will not be flagged, as this is a common pattern\nfor propagating exception traces:\n\n\ntry:\n    foo()\nexcept BaseException:\n    logging.exception(\"Something went wrong\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PTH201-PTH202-PTH203-PTH204-PTH205",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PTH201 (path-constructor-current-directory)\n\nDefinition: Checks for pathlib.Path objects that are initialized with the current\ndirectory.\n\nRationale: The Path() constructor defaults to the current directory, so passing it\nin explicitly (as \".\") is unnecessary.\n\nExample:\nfrom pathlib import Path\n\n_ = Path(\".\")\n\n\n\nUse instead:\n\n\nfrom pathlib import Path\n\n_ = Path()\n\n# Idiom PTH202 (os-path-getsize)\n\nDefinition: Checks for uses of os.path.getsize.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os.path.\n\n\nWhen possible, using Path object methods such as Path.stat() can\nimprove readability over the os.path module's counterparts (e.g.,\nos.path.getsize()).\n\nExample:\nimport os\n\nos.path.getsize(__file__)\n\n\n\nUse instead:\n\n\nfrom pathlib import Path\n\nPath(__file__).stat().st_size\n\n# Idiom PTH203 (os-path-getatime)\n\nDefinition: Checks for uses of os.path.getatime.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os.path.\n\n\nWhen possible, using Path object methods such as Path.stat() can\nimprove readability over the os.path module's counterparts (e.g.,\nos.path.getatime()).\n\nExample:\nimport os\n\nos.path.getatime(__file__)\n\n\n\nUse instead:\n\n\nfrom pathlib import Path\n\nPath(__file__).stat().st_atime\n\n# Idiom PTH204 (os-path-getmtime)\n\nDefinition: Checks for uses of os.path.getmtime.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os.path.\n\n\nWhen possible, using Path object methods such as Path.stat() can\nimprove readability over the os.path module's counterparts (e.g.,\nos.path.getmtime()).\n\nExample:\nimport os\n\nos.path.getmtime(__file__)\n\n\n\nUse instead:\n\n\nfrom pathlib import Path\n\nPath(__file__).stat().st_mtime\n\n# Idiom PTH205 (os-path-getctime)\n\nDefinition: Checks for uses of os.path.getctime.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os.path.\n\n\nWhen possible, using Path object methods such as Path.stat() can\nimprove readability over the os.path module's counterparts (e.g.,\nos.path.getctime()).\n\nExample:\nimport os\n\nos.path.getctime(__file__)\n\n\n\nUse instead:\n\n\nfrom pathlib import Path\n\nPath(__file__).stat().st_ctime\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/SLOT000-SLOT001-SLOT002",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom SLOT000 (no-slots-in-str-subclass)\n\nDefinition: Checks for subclasses of str that lack a __slots__ definition.\n\nRationale: In Python, the __slots__ attribute allows you to explicitly define the\nattributes (instance variables) that a class can have. By default, Python\nuses a dictionary to store an object's attributes, which incurs some memory\noverhead. However, when __slots__ is defined, Python uses a more compact\ninternal structure to store the object's attributes, resulting in memory\nsavings.\n\n\nSubclasses of str inherit all the attributes and methods of the built-in\nstr class. Since strings are typically immutable, they don't require\nadditional attributes beyond what the str class provides. Defining\n__slots__ for subclasses of str prevents the creation of a dictionary\nfor each instance, reducing memory consumption.\n\nExample:\nclass Foo(str):\n    pass\n\n\n\nUse instead:\n\n\nclass Foo(str):\n    __slots__ = ()\n\n# Idiom SLOT001 (no-slots-in-tuple-subclass)\n\nDefinition: Checks for subclasses of tuple that lack a __slots__ definition.\n\nRationale: In Python, the __slots__ attribute allows you to explicitly define the\nattributes (instance variables) that a class can have. By default, Python\nuses a dictionary to store an object's attributes, which incurs some memory\noverhead. However, when __slots__ is defined, Python uses a more compact\ninternal structure to store the object's attributes, resulting in memory\nsavings.\n\n\nSubclasses of tuple inherit all the attributes and methods of the\nbuilt-in tuple class. Since tuples are typically immutable, they don't\nrequire additional attributes beyond what the tuple class provides.\nDefining __slots__ for subclasses of tuple prevents the creation of a\ndictionary for each instance, reducing memory consumption.\n\nExample:\nclass Foo(tuple):\n    pass\n\n\n\nUse instead:\n\n\nclass Foo(tuple):\n    __slots__ = ()\n\n# Idiom SLOT002 (no-slots-in-namedtuple-subclass)\n\nDefinition: Checks for subclasses of collections.namedtuple or typing.NamedTuple\nthat lack a __slots__ definition.\n\nRationale: In Python, the __slots__ attribute allows you to explicitly define the\nattributes (instance variables) that a class can have. By default, Python\nuses a dictionary to store an object's attributes, which incurs some memory\noverhead. However, when __slots__ is defined, Python uses a more compact\ninternal structure to store the object's attributes, resulting in memory\nsavings.\n\n\nSubclasses of namedtuple inherit all the attributes and methods of the\nbuilt-in namedtuple class. Since tuples are typically immutable, they\ndon't require additional attributes beyond what the namedtuple class\nprovides. Defining __slots__ for subclasses of namedtuple prevents the\ncreation of a dictionary for each instance, reducing memory consumption.\n\nExample:\nfrom collections import namedtuple\n\n\nclass Foo(namedtuple(\"foo\", [\"str\", \"int\"])):\n    pass\n\n\n\nUse instead:\n\n\nfrom collections import namedtuple\n\n\nclass Foo(namedtuple(\"foo\", [\"str\", \"int\"])):\n    __slots__ = ()\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/W291-W292-W293",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom W291 (trailing-whitespace)\n\nDefinition: Checks for superfluous trailing whitespace.\n\nRationale: According to PEP 8, \"avoid trailing whitespace anywhere. Because it\u2019s usually\ninvisible, it can be confusing\"\n\nExample:\nspam(1) \\n#\n\n\n\nUse instead:\n\n\nspam(1)\\n#\n\n# Idiom W292 (missing-newline-at-end-of-file)\n\nDefinition: Checks for files missing a new line at the end of the file.\n\nRationale: Trailing blank lines in a file are superfluous.\n\n\nHowever, the last line of the file should end with a newline.\n\nExample:\nspam(1)\n\n\n\nUse instead:\n\n\nspam(1)\\n\n\n# Idiom W293 (blank-line-with-whitespace)\n\nDefinition: Checks for superfluous whitespace in blank lines.\n\nRationale: According to PEP 8, \"avoid trailing whitespace anywhere. Because it\u2019s usually\ninvisible, it can be confusing\"\n\nExample:\nclass Foo(object):\\n    \\n    bang = 12\n\n\n\nUse instead:\n\n\nclass Foo(object):\\n\\n    bang = 12\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/F525-F541-F601-F602-F621",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom F525 (string-dot-format-mixing-automatic)\n\nDefinition: Checks for str.format calls that mix automatic and manual numbering.\n\nRationale: In str.format calls, mixing automatic and manual numbering will raise a\nValueError at runtime.\n\nExample:\n\"{0}, {}\".format(\"Hello\", \"World\")\n\n\n\nUse instead:\n\n\n\"{0}, {1}\".format(\"Hello\", \"World\")\n\n\n\nOr:\n\n\n\"{}, {}\".format(\"Hello\", \"World\")\n\n# Idiom F541 (f-string-missing-placeholders)\n\nDefinition: Checks for f-strings that do not contain any placeholder expressions.\n\nRationale: f-strings are a convenient way to format strings, but they are not\nnecessary if there are no placeholder expressions to format. In this\ncase, a regular string should be used instead, as an f-string without\nplaceholders can be confusing for readers, who may expect such a\nplaceholder to be present.\n\n\nAn f-string without any placeholders could also indicate that the\nauthor forgot to add a placeholder expression.\n\nExample:\nf\"Hello, world!\"\n\n\n\nUse instead:\n\n\n\"Hello, world!\"\n\n\n\nNote: to maintain compatibility with PyFlakes, this rule only flags\nf-strings that are part of an implicit concatenation if none of the\nf-string segments contain placeholder expressions.\n\n\nFor example:\n\n\n# Will not be flagged.\n(\n    f\"Hello,\"\n    f\" {name}!\"\n)\n\n# Will be flagged.\n(\n    f\"Hello,\"\n    f\" World!\"\n)\n\n\n\nSee #10885 for more.\n\n# Idiom F601 (multi-value-repeated-key-literal)\n\nDefinition: Checks for dictionary literals that associate multiple values with the\nsame key.\n\nRationale: Dictionary keys should be unique. If a key is associated with multiple values,\nthe earlier values will be overwritten. Including multiple values for the\nsame key in a dictionary literal is likely a mistake.\n\nExample:\nfoo = {\n    \"bar\": 1,\n    \"baz\": 2,\n    \"baz\": 3,\n}\nfoo[\"baz\"]  # 3\n\n\n\nUse instead:\n\n\nfoo = {\n    \"bar\": 1,\n    \"baz\": 2,\n}\nfoo[\"baz\"]  # 2\n\n# Idiom F602 (multi-value-repeated-key-variable)\n\nDefinition: Checks for dictionary keys that are repeated with different values.\n\nRationale: Dictionary keys should be unique. If a key is repeated with a different\nvalue, the first values will be overwritten and the key will correspond to\nthe last value. This is likely a mistake.\n\nExample:\nfoo = {\n    bar: 1,\n    baz: 2,\n    baz: 3,\n}\nfoo[baz]  # 3\n\n\n\nUse instead:\n\n\nfoo = {\n    bar: 1,\n    baz: 2,\n}\nfoo[baz]  # 2\n\n# Idiom F621 (expressions-in-star-assignment)\n\nDefinition: Checks for the use of too many expressions in starred assignment statements.\n\nRationale: In assignment statements, starred expressions can be used to unpack iterables.\n\n\nIn Python 3, no more than 1 \\<< 8 assignments are allowed before a starred\nexpression, and no more than 1 \\<< 24 expressions are allowed after a starred\nexpression.\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/AIR001-AIR002-AIR301-AIR302-AIR311",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom AIR001 (airflow-variable-name-task-id-mismatch)\n\nDefinition: Checks that the task variable name matches the task_id value for\nAirflow Operators.\n\nRationale: When initializing an Airflow Operator, for consistency, the variable\nname should match the task_id value. This makes it easier to\nfollow the flow of the DAG.\n\nExample:\nfrom airflow.operators import PythonOperator\n\n\nincorrect_name = PythonOperator(task_id=\"my_task\")\n\n\n\nUse instead:\n\n\nfrom airflow.operators import PythonOperator\n\n\nmy_task = PythonOperator(task_id=\"my_task\")\n\n# Idiom AIR002 (airflow-dag-no-schedule-argument)\n\nDefinition: Checks for a DAG() class or @dag() decorator without an explicit\nschedule (or schedule_interval for Airflow 1) parameter.\n\nRationale: The default value of the schedule parameter on Airflow 2 and\nschedule_interval on Airflow 1 is timedelta(days=1), which is almost\nnever what a user is looking for. Airflow 3 changed the default value to None,\nand would break existing dags using the implicit default.\n\n\nIf your dag does not have an explicit schedule / schedule_interval argument,\nAirflow 2 schedules a run for it every day (at the time determined by start_date).\nSuch a dag will no longer be scheduled on Airflow 3 at all, without any\nexceptions or other messages visible to the user.\n\nExample:\nfrom airflow import DAG\n\n\n# Using the implicit default schedule.\ndag = DAG(dag_id=\"my_dag\")\n\n\n\nUse instead:\n\n\nfrom datetime import timedelta\n\nfrom airflow import DAG\n\n\ndag = DAG(dag_id=\"my_dag\", schedule=timedelta(days=1))\n\n# Idiom AIR301 (airflow3-removal)\n\nDefinition: Checks for uses of deprecated Airflow functions and values.\n\nRationale: Airflow 3.0 removed various deprecated functions, members, and other\nvalues. Some have more modern replacements. Others are considered too niche\nand not worth to be maintained in Airflow.\n\nExample:\nfrom airflow.utils.dates import days_ago\n\n\nyesterday = days_ago(today, 1)\n\n\n\nUse instead:\n\n\nfrom datetime import timedelta\n\n\nyesterday = today - timedelta(days=1)\n\n# Idiom AIR302 (airflow3-moved-to-provider)\n\nDefinition: Checks for uses of Airflow functions and values that have been moved to it providers.\n(e.g., apache-airflow-providers-fab)\n\nRationale: Airflow 3.0 moved various deprecated functions, members, and other\nvalues to its providers. The user needs to install the corresponding provider and replace\nthe original usage with the one in the provider\n\nExample:\nfrom airflow.auth.managers.fab.fab_auth_manage import FabAuthManager\n\n\n\nUse instead:\n\n\nfrom airflow.providers.fab.auth_manager.fab_auth_manage import FabAuthManager\n\n# Idiom AIR311 (airflow3-suggested-update)\n\nDefinition: Checks for uses of deprecated Airflow functions and values that still have\na compatibility layer.\n\nRationale: Airflow 3.0 removed various deprecated functions, members, and other\nvalues. Some have more modern replacements. Others are considered too niche\nand not worth to be maintained in Airflow.\nEven though these symbols still work fine on Airflow 3.0, they are expected to be removed in a future version.\nThe user is suggested to replace the original usage with the new ones.\n\nExample:\nfrom airflow import Dataset\n\n\nDataset(uri=\"test://test/\")\n\n\n\nUse instead:\n\n\nfrom airflow.sdk import Asset\n\n\nAsset(uri=\"test://test/\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/UP029-UP030-UP031-UP032-UP033",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom UP029 (unnecessary-builtin-import)\n\nDefinition: Checks for unnecessary imports of builtins.\n\nRationale: Builtins are always available. Importing them is unnecessary and should be\nremoved to avoid confusion.\n\nExample:\nfrom builtins import str\n\nstr(1)\n\n\n\nUse instead:\n\n\nstr(1)\n\n# Idiom UP030 (format-literals)\n\nDefinition: Checks for unnecessary positional indices in format strings.\n\nRationale: In Python 3.1 and later, format strings can use implicit positional\nreferences. For example, \"{0}, {1}\".format(\"Hello\", \"World\") can be\nrewritten as \"{}, {}\".format(\"Hello\", \"World\").\n\n\nIf the positional indices appear exactly in-order, they can be omitted\nin favor of automatic indices to improve readability.\n\nExample:\n\"{0}, {1}\".format(\"Hello\", \"World\")  # \"Hello, World\"\n\n\n\nUse instead:\n\n\n\"{}, {}\".format(\"Hello\", \"World\")  # \"Hello, World\"\n\n# Idiom UP031 (printf-string-formatting)\n\nDefinition: Checks for printf-style string formatting, and offers to replace it with\nstr.format calls.\n\nRationale: printf-style string formatting has a number of quirks, and leads to less\nreadable code than using str.format calls or f-strings. In general, prefer\nthe newer str.format and f-strings constructs over printf-style string\nformatting.\n\nExample:\n\"%s, %s\" % (\"Hello\", \"World\")  # \"Hello, World\"\n\n\n\nUse instead:\n\n\n\"{}, {}\".format(\"Hello\", \"World\")  # \"Hello, World\"\n\n\n\nf\"{'Hello'}, {'World'}\"  # \"Hello, World\"\n\n# Idiom UP032 (f-string)\n\nDefinition: Checks for str.format calls that can be replaced with f-strings.\n\nRationale: f-strings are more readable and generally preferred over str.format\ncalls.\n\nExample:\n\"{}\".format(foo)\n\n\n\nUse instead:\n\n\nf\"{foo}\"\n\n# Idiom UP033 (lru-cache-with-maxsize-none)\n\nDefinition: Checks for uses of functools.lru_cache that set maxsize=None.\n\nRationale: Since Python 3.9, functools.cache can be used as a drop-in replacement\nfor functools.lru_cache(maxsize=None). When possible, prefer\nfunctools.cache as it is more readable and idiomatic.\n\nExample:\nimport functools\n\n\n@functools.lru_cache(maxsize=None)\ndef foo(): ...\n\n\n\nUse instead:\n\n\nimport functools\n\n\n@functools.cache\ndef foo(): ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLE2502-PLE2512-PLE2513-PLE2514",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLE2502 (bidirectional-unicode)\n\nDefinition: Checks for bidirectional unicode characters.\n\nRationale: The interaction between bidirectional unicode characters and the\nsurrounding code can be surprising to those that are unfamiliar\nwith right-to-left writing systems.\n\n\nIn some cases, bidirectional unicode characters can also be used to\nobfuscate code and introduce or mask security vulnerabilities.\n\nExample:\ns = \"\u05d0\" * 100  #  \"\u05d0\" is assigned\nprint(s)  # prints a 100-character string\n\n# Idiom PLE2512 (invalid-character-sub)\n\nDefinition: Checks for strings that contain the raw control character SUB.\n\nRationale: Control characters are displayed differently by different text editors and\nterminals.\n\n\nBy using the \\x1A sequence in lieu of the SUB control character, the\nstring will contain the same value, but will render visibly in all editors.\n\nExample:\nx = \"\"\n\n\n\nUse instead:\n\n\nx = \"\\x1a\"\n\n# Idiom PLE2513 (invalid-character-esc)\n\nDefinition: Checks for strings that contain the raw control character ESC.\n\nRationale: Control characters are displayed differently by different text editors and\nterminals.\n\n\nBy using the \\x1B sequence in lieu of the SUB control character, the\nstring will contain the same value, but will render visibly in all editors.\n\nExample:\nx = \"\"\n\n\n\nUse instead:\n\n\nx = \"\\x1b\"\n\n# Idiom PLE2514 (invalid-character-nul)\n\nDefinition: Checks for strings that contain the raw control character NUL (0 byte).\n\nRationale: Control characters are displayed differently by different text editors and\nterminals.\n\n\nBy using the \\0 sequence in lieu of the NUL control character, the\nstring will contain the same value, but will render visibly in all editors.\n\nExample:\nx = \"\"\n\n\n\nUse instead:\n\n\nx = \"\\0\"\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/RUF001-RUF002-RUF003-RUF005-RUF006",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom RUF001 (ambiguous-unicode-character-string)\n\nDefinition: Checks for ambiguous Unicode characters in strings.\n\nRationale: Some Unicode characters are visually similar to ASCII characters, but have\ndifferent code points. For example, GREEK CAPITAL LETTER ALPHA (U+0391)\nis visually similar, but not identical, to the ASCII character A.\n\n\nThe use of ambiguous Unicode characters can confuse readers, cause subtle\nbugs, and even make malicious code look harmless.\n\n\nIn preview, this rule will also flag Unicode characters that are\nconfusable with other, non-preferred Unicode characters. For example, the\nspec recommends GREEK CAPITAL LETTER OMEGA over OHM SIGN.\n\n\nYou can omit characters from being flagged as ambiguous via the\nlint.allowed-confusables setting.\n\nExample:\nprint(\"\u0397ello, world!\")  # \"\u0397\" is the Greek eta (`U+0397`).\n\n\n\nUse instead:\n\n\nprint(\"Hello, world!\")  # \"H\" is the Latin capital H (`U+0048`).\n\n# Idiom RUF002 (ambiguous-unicode-character-docstring)\n\nDefinition: Checks for ambiguous Unicode characters in docstrings.\n\nRationale: Some Unicode characters are visually similar to ASCII characters, but have\ndifferent code points. For example, GREEK CAPITAL LETTER ALPHA (U+0391)\nis visually similar, but not identical, to the ASCII character A.\n\n\nThe use of ambiguous Unicode characters can confuse readers, cause subtle\nbugs, and even make malicious code look harmless.\n\n\nIn preview, this rule will also flag Unicode characters that are\nconfusable with other, non-preferred Unicode characters. For example, the\nspec recommends GREEK CAPITAL LETTER OMEGA over OHM SIGN.\n\n\nYou can omit characters from being flagged as ambiguous via the\nlint.allowed-confusables setting.\n\nExample:\n\"\"\"A lovely docstring (with a `U+FF09` parenthesis\uff09.\"\"\"\n\n\n\nUse instead:\n\n\n\"\"\"A lovely docstring (with no strange parentheses).\"\"\"\n\n# Idiom RUF003 (ambiguous-unicode-character-comment)\n\nDefinition: Checks for ambiguous Unicode characters in comments.\n\nRationale: Some Unicode characters are visually similar to ASCII characters, but have\ndifferent code points. For example, GREEK CAPITAL LETTER ALPHA (U+0391)\nis visually similar, but not identical, to the ASCII character A.\n\n\nThe use of ambiguous Unicode characters can confuse readers, cause subtle\nbugs, and even make malicious code look harmless.\n\n\nIn preview, this rule will also flag Unicode characters that are\nconfusable with other, non-preferred Unicode characters. For example, the\nspec recommends GREEK CAPITAL LETTER OMEGA over OHM SIGN.\n\n\nYou can omit characters from being flagged as ambiguous via the\nlint.allowed-confusables setting.\n\nExample:\nfoo()  # n\u043eqa  # \"\u043e\" is Cyrillic (`U+043E`)\n\n\n\nUse instead:\n\n\nfoo()  # noqa  # \"o\" is Latin (`U+006F`)\n\n# Idiom RUF005 (collection-literal-concatenation)\n\nDefinition: Checks for uses of the + operator to concatenate collections.\n\nRationale: In Python, the + operator can be used to concatenate collections (e.g.,\nx + y to concatenate the lists x and y).\n\n\nHowever, collections can be concatenated more efficiently using the\nunpacking operator (e.g., [*x, *y] to concatenate x and y).\n\n\nPrefer the unpacking operator to concatenate collections, as it is more\nreadable and flexible. The * operator can unpack any iterable, whereas\n+ operates only on particular sequences which, in many cases, must be of\nthe same type.\n\nExample:\nfoo = [2, 3, 4]\nbar = [1] + foo + [5, 6]\n\n\n\nUse instead:\n\n\nfoo = [2, 3, 4]\nbar = [1, *foo, 5, 6]\n\n# Idiom RUF006 (asyncio-dangling-task)\n\nDefinition: Checks for asyncio.create_task and asyncio.ensure_future calls\nthat do not store a reference to the returned result.\n\nRationale: Per the asyncio documentation, the event loop only retains a weak\nreference to tasks. If the task returned by asyncio.create_task and\nasyncio.ensure_future is not stored in a variable, or a collection,\nor otherwise referenced, it may be garbage collected at any time. This\ncan lead to unexpected and inconsistent behavior, as your tasks may or\nmay not run to completion.\n\nExample:\nimport asyncio\n\nfor i in range(10):\n    # This creates a weak reference to the task, which may be garbage\n    # collected at any time.\n    asyncio.create_task(some_coro(param=i))\n\n\n\nUse instead:\n\n\nimport asyncio\n\nbackground_tasks = set()\n\nfor i in range(10):\n    task = asyncio.create_task(some_coro(param=i))\n\n    # Add task to the set. This creates a strong reference.\n    background_tasks.add(task)\n\n    # To prevent keeping references to finished tasks forever,\n    # make each task remove its own reference from the set after\n    # completion:\n    task.add_done_callback(background_tasks.discard)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/AIR312-FAST001-FAST002-FAST003",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom AIR312 (airflow3-suggested-to-move-to-provider)\n\nDefinition: Checks for uses of Airflow functions and values that have been moved to its providers\nbut still have a compatibility layer (e.g., apache-airflow-providers-standard).\n\nRationale: Airflow 3.0 moved various deprecated functions, members, and other\nvalues to its providers. Even though these symbols still work fine on Airflow 3.0,\nthey are expected to be removed in a future version. The user is suggested to install\nthe corresponding provider and replace the original usage with the one in the provider.\n\nExample:\nfrom airflow.operators.python import PythonOperator\n\n\n\nUse instead:\n\n\nfrom airflow.providers.standard.operators.python import PythonOperator\n\n# Idiom FAST001 (fast-api-redundant-response-model)\n\nDefinition: Checks for FastAPI routes that use the optional response_model parameter\nwith the same type as the return type.\n\nRationale: FastAPI routes automatically infer the response model type from the return\ntype, so specifying it explicitly is redundant.\n\n\nThe response_model parameter is used to override the default response\nmodel type. For example, response_model can be used to specify that\na non-serializable response type should instead be serialized via an\nalternative type.\n\n\nFor more information, see the FastAPI documentation.\n\nExample:\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n\n\n@app.post(\"/items/\", response_model=Item)\nasync def create_item(item: Item) -> Item:\n    return item\n\n\n\nUse instead:\n\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n\n\n@app.post(\"/items/\")\nasync def create_item(item: Item) -> Item:\n    return item\n\n# Idiom FAST002 (fast-api-non-annotated-dependency)\n\nDefinition: Identifies FastAPI routes with deprecated uses of Depends or similar.\n\nRationale: The FastAPI documentation recommends the use of typing.Annotated\nfor defining route dependencies and parameters, rather than using Depends,\nQuery or similar as a default value for a parameter. Using this approach\neverywhere helps ensure consistency and clarity in defining dependencies\nand parameters.\n\n\nAnnotated was added to the typing module in Python 3.9; however,\nthe third-party typing_extensions package\nprovides a backport that can be used on older versions of Python.\n\nExample:\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nasync def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):\n    return {\"q\": q, \"skip\": skip, \"limit\": limit}\n\n\n@app.get(\"/items/\")\nasync def read_items(commons: dict = Depends(common_parameters)):\n    return commons\n\n\n\nUse instead:\n\n\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nasync def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):\n    return {\"q\": q, \"skip\": skip, \"limit\": limit}\n\n\n@app.get(\"/items/\")\nasync def read_items(commons: Annotated[dict, Depends(common_parameters)]):\n    return commons\n\n# Idiom FAST003 (fast-api-unused-path-parameter)\n\nDefinition: Identifies FastAPI routes that declare path parameters in the route path\nthat are not included in the function signature.\n\nRationale: Path parameters are used to extract values from the URL path.\n\n\nIf a path parameter is declared in the route path but not in the function\nsignature, it will not be accessible in the function body, which is likely\na mistake.\n\n\nIf a path parameter is declared in the route path, but as a positional-only\nargument in the function signature, it will also not be accessible in the\nfunction body, as FastAPI will not inject the parameter.\n\nExample:\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/things/{thing_id}\")\nasync def read_thing(query: str): ...\n\n\n\nUse instead:\n\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/things/{thing_id}\")\nasync def read_thing(thing_id: int, query: str): ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/UP007-UP008-UP009-UP010-UP011",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom UP007 (non-pep604-annotation-union)\n\nDefinition: Check for type annotations that can be rewritten based on PEP 604 syntax.\n\nRationale: PEP 604 introduced a new syntax for union type annotations based on the\n| operator. This syntax is more concise and readable than the previous\ntyping.Union and typing.Optional syntaxes.\n\n\nThis rule is enabled when targeting Python 3.10 or later (see:\ntarget-version). By default, it's also enabled for earlier Python\nversions if from __future__ import annotations is present, as\n__future__ annotations are not evaluated at runtime. If your code relies\non runtime type annotations (either directly or via a library like\nPydantic), you can disable this behavior for Python versions prior to 3.10\nby setting lint.pyupgrade.keep-runtime-typing to true.\n\nExample:\nfrom typing import Union\n\nfoo: Union[int, str] = 1\n\n\n\nUse instead:\n\n\nfoo: int | str = 1\n\n# Idiom UP008 (super-call-with-parameters)\n\nDefinition: Checks for super calls that pass redundant arguments.\n\nRationale: In Python 3, super can be invoked without any arguments when: (1) the\nfirst argument is __class__, and (2) the second argument is equivalent to\nthe first argument of the enclosing method.\n\n\nWhen possible, omit the arguments to super to make the code more concise\nand maintainable.\n\nExample:\nclass A:\n    def foo(self):\n        pass\n\n\nclass B(A):\n    def bar(self):\n        super(B, self).foo()\n\n\n\nUse instead:\n\n\nclass A:\n    def foo(self):\n        pass\n\n\nclass B(A):\n    def bar(self):\n        super().foo()\n\n# Idiom UP009 (utf8-encoding-declaration)\n\nDefinition: Checks for unnecessary UTF-8 encoding declarations.\n\nRationale: PEP 3120 makes UTF-8 the default encoding, so a UTF-8 encoding\ndeclaration is unnecessary.\n\nExample:\n# -*- coding: utf-8 -*-\nprint(\"Hello, world!\")\n\n\n\nUse instead:\n\n\nprint(\"Hello, world!\")\n\n# Idiom UP010 (unnecessary-future-import)\n\nDefinition: Checks for unnecessary __future__ imports.\n\nRationale: The __future__ module is used to enable features that are not yet\navailable in the current Python version. If a feature is already\navailable in the minimum supported Python version, importing it\nfrom __future__ is unnecessary and should be removed to avoid\nconfusion.\n\nExample:\nfrom __future__ import print_function\n\nprint(\"Hello, world!\")\n\n\n\nUse instead:\n\n\nprint(\"Hello, world!\")\n\n# Idiom UP011 (lru-cache-without-parameters)\n\nDefinition: Checks for unnecessary parentheses on functools.lru_cache decorators.\n\nRationale: Since Python 3.8, functools.lru_cache can be used as a decorator without\ntrailing parentheses, as long as no arguments are passed to it.\n\nExample:\nimport functools\n\n\n@functools.lru_cache()\ndef foo(): ...\n\n\n\nUse instead:\n\n\nimport functools\n\n\n@functools.lru_cache\ndef foo(): ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/T201-T203-INP001",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom T201 (print)\n\nDefinition: Checks for print statements.\n\nRationale: print statements are useful in some situations (e.g., debugging), but\nshould typically be omitted from production code. print statements can\nlead to the accidental inclusion of sensitive information in logs, and are\nnot configurable by clients, unlike logging statements.\n\nExample:\ndef add_numbers(a, b):\n    print(f\"The sum of {a} and {b} is {a + b}\")\n    return a + b\n\n\n\nUse instead:\n\n\ndef add_numbers(a, b):\n    return a + b\n\n# Idiom T203 (p-print)\n\nDefinition: Checks for pprint statements.\n\nRationale: Like print statements, pprint statements are useful in some situations\n(e.g., debugging), but should typically be omitted from production code.\npprint statements can lead to the accidental inclusion of sensitive\ninformation in logs, and are not configurable by clients, unlike logging\nstatements.\n\nExample:\nimport pprint\n\n\ndef merge_dicts(dict_a, dict_b):\n    dict_c = {**dict_a, **dict_b}\n    pprint.pprint(dict_c)\n    return dict_c\n\n\n\nUse instead:\n\n\ndef merge_dicts(dict_a, dict_b):\n    dict_c = {**dict_a, **dict_b}\n    return dict_c\n\n# Idiom INP001 (implicit-namespace-package)\n\nDefinition: Checks for packages that are missing an __init__.py file.\n\nRationale: Python packages are directories that contain a file named __init__.py.\nThe existence of this file indicates that the directory is a Python\npackage, and so it can be imported the same way a module can be\nimported.\n\n\nDirectories that lack an __init__.py file can still be imported, but\nthey're indicative of a special kind of package, known as a \"namespace\npackage\" (see: PEP 420).\nNamespace packages are less widely used, so a package that lacks an\n__init__.py file is typically meant to be a regular package, and\nthe absence of the __init__.py file is probably an oversight.\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/DJ008-DJ012-DJ013",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom DJ008 (django-model-without-dunder-str)\n\nDefinition: Checks that a __str__ method is defined in Django models.\n\nRationale: Django models should define a __str__ method to return a string representation\nof the model instance, as Django calls this method to display the object in\nthe Django Admin and elsewhere.\n\n\nModels without a __str__ method will display a non-meaningful representation\nof the object in the Django Admin.\n\nExample:\nfrom django.db import models\n\n\nclass MyModel(models.Model):\n    field = models.CharField(max_length=255)\n\n\n\nUse instead:\n\n\nfrom django.db import models\n\n\nclass MyModel(models.Model):\n    field = models.CharField(max_length=255)\n\n    def __str__(self):\n        return f\"{self.field}\"\n\n# Idiom DJ012 (django-unordered-body-content-in-model)\n\nDefinition: Checks for the order of Model's inner classes, methods, and fields as per\nthe Django Style Guide.\n\nRationale: The Django Style Guide specifies that the order of Model inner classes,\nattributes and methods should be as follows:\n\n\n\nAll database fields\nCustom manager attributes\nclass Meta\ndef __str__()\ndef save()\ndef get_absolute_url()\nAny custom methods\n\nExample:\nfrom django.db import models\n\n\nclass StrBeforeFieldModel(models.Model):\n    class Meta:\n        verbose_name = \"test\"\n        verbose_name_plural = \"tests\"\n\n    def __str__(self):\n        return \"foobar\"\n\n    first_name = models.CharField(max_length=32)\n    last_name = models.CharField(max_length=40)\n\n\n\nUse instead:\n\n\nfrom django.db import models\n\n\nclass StrBeforeFieldModel(models.Model):\n    first_name = models.CharField(max_length=32)\n    last_name = models.CharField(max_length=40)\n\n    class Meta:\n        verbose_name = \"test\"\n        verbose_name_plural = \"tests\"\n\n    def __str__(self):\n        return \"foobar\"\n\n# Idiom DJ013 (django-non-leading-receiver-decorator)\n\nDefinition: Checks that Django's @receiver decorator is listed first, prior to\nany other decorators.\n\nRationale: Django's @receiver decorator is special in that it does not return\na wrapped function. Rather, @receiver connects the decorated function\nto a signal. If any other decorators are listed before @receiver,\nthe decorated function will not be connected to the signal.\n\nExample:\nfrom django.dispatch import receiver\nfrom django.db.models.signals import post_save\n\n\n@transaction.atomic\n@receiver(post_save, sender=MyModel)\ndef my_handler(sender, instance, created, **kwargs):\n    pass\n\n\n\nUse instead:\n\n\nfrom django.dispatch import receiver\nfrom django.db.models.signals import post_save\n\n\n@receiver(post_save, sender=MyModel)\n@transaction.atomic\ndef my_handler(sender, instance, created, **kwargs):\n    pass\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/D100-D101-D102-D103-D104",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom D100 (undocumented-public-module)\n\nDefinition: Checks for undocumented public module definitions.\n\nRationale: Public modules should be documented via docstrings to outline their purpose\nand contents.\n\n\nGenerally, module docstrings should describe the purpose of the module and\nlist the classes, exceptions, functions, and other objects that are exported\nby the module, alongside a one-line summary of each.\n\n\nIf the module is a script, the docstring should be usable as its \"usage\"\nmessage.\n\n\nIf the codebase adheres to a standard format for module docstrings, follow\nthat format for consistency.\n\nExample:\nclass FasterThanLightError(ZeroDivisionError): ...\n\n\ndef calculate_speed(distance: float, time: float) -> float: ...\n\n\n\nUse instead:\n\n\n\"\"\"Utility functions and classes for calculating speed.\n\nThis module provides:\n- FasterThanLightError: exception when FTL speed is calculated;\n- calculate_speed: calculate speed given distance and time.\n\"\"\"\n\n\nclass FasterThanLightError(ZeroDivisionError): ...\n\n\ndef calculate_speed(distance: float, time: float) -> float: ...\n\n# Idiom D101 (undocumented-public-class)\n\nDefinition: Checks for undocumented public class definitions.\n\nRationale: Public classes should be documented via docstrings to outline their purpose\nand behavior.\n\n\nGenerally, a class docstring should describe the class's purpose and list\nits public attributes and methods.\n\n\nIf the codebase adheres to a standard format for class docstrings, follow\nthat format for consistency.\n\nExample:\nclass Player:\n    def __init__(self, name: str, points: int = 0) -> None:\n        self.name: str = name\n        self.points: int = points\n\n    def add_points(self, points: int) -> None:\n        self.points += points\n\n\n\nUse instead (in the NumPy docstring format):\n\n\nclass Player:\n    \"\"\"A player in the game.\n\n    Attributes\n    ----------\n    name : str\n        The name of the player.\n    points : int\n        The number of points the player has.\n\n    Methods\n    -------\n    add_points(points: int) -> None\n        Add points to the player's score.\n    \"\"\"\n\n    def __init__(self, name: str, points: int = 0) -> None:\n        self.name: str = name\n        self.points: int = points\n\n    def add_points(self, points: int) -> None:\n        self.points += points\n\n\n\nOr (in the Google docstring format):\n\n\nclass Player:\n    \"\"\"A player in the game.\n\n    Attributes:\n        name: The name of the player.\n        points: The number of points the player has.\n    \"\"\"\n\n    def __init__(self, name: str, points: int = 0) -> None:\n        self.name: str = name\n        self.points: int = points\n\n    def add_points(self, points: int) -> None:\n        self.points += points\n\n# Idiom D102 (undocumented-public-method)\n\nDefinition: Checks for undocumented public method definitions.\n\nRationale: Public methods should be documented via docstrings to outline their purpose\nand behavior.\n\n\nGenerally, a method docstring should describe the method's behavior,\narguments, side effects, exceptions, return values, and any other\ninformation that may be relevant to the user.\n\n\nIf the codebase adheres to a standard format for method docstrings, follow\nthat format for consistency.\n\nExample:\nclass Cat(Animal):\n    def greet(self, happy: bool = True):\n        if happy:\n            print(\"Meow!\")\n        else:\n            raise ValueError(\"Tried to greet an unhappy cat.\")\n\n\n\nUse instead (in the NumPy docstring format):\n\n\nclass Cat(Animal):\n    def greet(self, happy: bool = True):\n        \"\"\"Print a greeting from the cat.\n\n        Parameters\n        ----------\n        happy : bool, optional\n            Whether the cat is happy, is True by default.\n\n        Raises\n        ------\n        ValueError\n            If the cat is not happy.\n        \"\"\"\n        if happy:\n            print(\"Meow!\")\n        else:\n            raise ValueError(\"Tried to greet an unhappy cat.\")\n\n\n\nOr (in the Google docstring format):\n\n\nclass Cat(Animal):\n    def greet(self, happy: bool = True):\n        \"\"\"Print a greeting from the cat.\n\n        Args:\n            happy: Whether the cat is happy, is True by default.\n\n        Raises:\n            ValueError: If the cat is not happy.\n        \"\"\"\n        if happy:\n            print(\"Meow!\")\n        else:\n            raise ValueError(\"Tried to greet an unhappy cat.\")\n\n# Idiom D103 (undocumented-public-function)\n\nDefinition: Checks for undocumented public function definitions.\n\nRationale: Public functions should be documented via docstrings to outline their\npurpose and behavior.\n\n\nGenerally, a function docstring should describe the function's behavior,\narguments, side effects, exceptions, return values, and any other\ninformation that may be relevant to the user.\n\n\nIf the codebase adheres to a standard format for function docstrings, follow\nthat format for consistency.\n\nExample:\ndef calculate_speed(distance: float, time: float) -> float:\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n\n\nUse instead (using the NumPy docstring format):\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n\n\nOr, using the Google docstring format:\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n# Idiom D104 (undocumented-public-package)\n\nDefinition: Checks for undocumented public package definitions.\n\nRationale: Public packages should be documented via docstrings to outline their\npurpose and contents.\n\n\nGenerally, package docstrings should list the modules and subpackages that\nare exported by the package.\n\n\nIf the codebase adheres to a standard format for package docstrings, follow\nthat format for consistency.\n\nExample:\n__all__ = [\"Player\", \"Game\"]\n\n\n\nUse instead:\n\n\n\"\"\"Game and player management package.\n\nThis package provides classes for managing players and games.\n\"\"\"\n\n__all__ = [\"player\", \"game\"]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLR1714-PLR1716-PLR1722-PLR1730",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLR1714 (repeated-equality-comparison)\n\nDefinition: Checks for repeated equality comparisons that can be rewritten as a membership\ntest.\n\n\nThis rule will try to determine if the values are hashable\nand the fix will use a set if they are. If unable to determine, the fix\nwill use a tuple and suggest the use of a set.\n\nRationale: To check if a variable is equal to one of many values, it is common to\nwrite a series of equality comparisons (e.g.,\nfoo == \"bar\" or foo == \"baz\").\n\n\nInstead, prefer to combine the values into a collection and use the in\noperator to check for membership, which is more performant and succinct.\nIf the items are hashable, use a set for efficiency; otherwise, use a\ntuple.\n\nExample:\nfoo == \"bar\" or foo == \"baz\" or foo == \"qux\"\n\n\n\nUse instead:\n\n\nfoo in {\"bar\", \"baz\", \"qux\"}\n\n# Idiom PLR1716 (boolean-chained-comparison)\n\nDefinition: Check for chained boolean operations that can be simplified.\n\nRationale: Refactoring the code will improve readability for these cases.\n\nExample:\na = int(input())\nb = int(input())\nc = int(input())\nif a < b and b < c:\n    pass\n\n\n\nUse instead:\n\n\na = int(input())\nb = int(input())\nc = int(input())\nif a < b < c:\n    pass\n\n# Idiom PLR1722 (sys-exit-alias)\n\nDefinition: Checks for uses of the exit() and quit().\n\nRationale: exit and quit come from the site module, which is typically imported\nautomatically during startup. However, it is not guaranteed to be\nimported, and so using these functions may result in a NameError at\nruntime. Generally, these constants are intended to be used in an interactive\ninterpreter, and not in programs.\n\n\nPrefer sys.exit(), as the sys module is guaranteed to exist in all\ncontexts.\n\nExample:\nif __name__ == \"__main__\":\n    exit()\n\n\n\nUse instead:\n\n\nimport sys\n\nif __name__ == \"__main__\":\n    sys.exit()\n\n# Idiom PLR1730 (if-stmt-min-max)\n\nDefinition: Checks for if statements that can be replaced with min() or max()\ncalls.\n\nRationale: An if statement that selects the lesser or greater of two sub-expressions\ncan be replaced with a min() or max() call respectively. Where possible,\nprefer min() and max(), as they're more concise and readable than the\nequivalent if statements.\n\nExample:\nif score > highest_score:\n    highest_score = score\n\n\n\nUse instead:\n\n\nhighest_score = max(highest_score, score)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/S101-S102-S103-S104-S105",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom S101 (assert)\n\nDefinition: Checks for uses of the assert keyword.\n\nRationale: Assertions are removed when Python is run with optimization requested\n(i.e., when the -O flag is present), which is a common practice in\nproduction environments. As such, assertions should not be used for runtime\nvalidation of user input or to enforce interface constraints.\n\n\nConsider raising a meaningful error instead of using assert.\n\nExample:\nassert x > 0, \"Expected positive value.\"\n\n\n\nUse instead:\n\n\nif not x > 0:\n    raise ValueError(\"Expected positive value.\")\n\n# or even better:\nif x <= 0:\n    raise ValueError(\"Expected positive value.\")\n\n# Idiom S102 (exec-builtin)\n\nDefinition: Checks for uses of the builtin exec function.\n\nRationale: The exec() function is insecure as it allows for arbitrary code\nexecution.\n\nExample:\nexec(\"print('Hello World')\")\n\n# Idiom S103 (bad-file-permissions)\n\nDefinition: Checks for files with overly permissive permissions.\n\nRationale: Overly permissive file permissions may allow unintended access and\narbitrary code execution.\n\nExample:\nimport os\n\nos.chmod(\"/etc/secrets.txt\", 0o666)  # rw-rw-rw-\n\n\n\nUse instead:\n\n\nimport os\n\nos.chmod(\"/etc/secrets.txt\", 0o600)  # rw-------\n\n# Idiom S104 (hardcoded-bind-all-interfaces)\n\nDefinition: Checks for hardcoded bindings to all network interfaces (0.0.0.0).\n\nRationale: Binding to all network interfaces is insecure as it allows access from\nunintended interfaces, which may be poorly secured or unauthorized.\n\n\nInstead, bind to specific interfaces.\n\nExample:\nALLOWED_HOSTS = [\"0.0.0.0\"]\n\n\n\nUse instead:\n\n\nALLOWED_HOSTS = [\"127.0.0.1\", \"localhost\"]\n\n# Idiom S105 (hardcoded-password-string)\n\nDefinition: Checks for potential uses of hardcoded passwords in strings.\n\nRationale: Including a hardcoded password in source code is a security risk, as an\nattacker could discover the password and use it to gain unauthorized\naccess.\n\n\nInstead, store passwords and other secrets in configuration files,\nenvironment variables, or other sources that are excluded from version\ncontrol.\n\nExample:\nSECRET_KEY = \"hunter2\"\n\n\n\nUse instead:\n\n\nimport os\n\nSECRET_KEY = os.environ[\"SECRET_KEY\"]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PTH120-PTH121-PTH122-PTH123-PTH124",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PTH120 (os-path-dirname)\n\nDefinition: Checks for uses of os.path.dirname.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os.path. When possible, using Path object\nmethods such as Path.parent can improve readability over the os.path\nmodule's counterparts (e.g., os.path.dirname()).\n\n# Idiom PTH121 (os-path-samefile)\n\nDefinition: Checks for uses of os.path.samefile.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os.path. When possible, using Path object\nmethods such as Path.samefile() can improve readability over the os.path\nmodule's counterparts (e.g., os.path.samefile()).\n\n# Idiom PTH122 (os-path-splitext)\n\nDefinition: Checks for uses of os.path.splitext.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os.path. When possible, using Path object\nmethods such as Path.suffix and Path.stem can improve readability over\nthe os.path module's counterparts (e.g., os.path.splitext()).\n\n\nos.path.splitext() specifically returns a tuple of the file root and\nextension (e.g., given splitext('/foo/bar.py'), os.path.splitext()\nreturns (\"foo/bar\", \".py\"). These outputs can be reconstructed through a\ncombination of Path.suffix (\".py\"), Path.stem (\"bar\"), and\nPath.parent (\"foo\").\n\n# Idiom PTH123 (builtin-open)\n\nDefinition: Checks for uses of the open() builtin.\n\nRationale: pathlib offers a high-level API for path manipulation. When possible,\nusing Path object methods such as Path.open() can improve readability\nover the open builtin.\n\n# Idiom PTH124 (py-path)\n\nDefinition: Checks for uses of the py.path library.\n\nRationale: The py.path library is in maintenance mode. Instead, prefer the standard\nlibrary's pathlib module, or third-party modules like path (formerly\npy.path).\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/B012-B013-B014-B015-B016",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom B012 (jump-statement-in-finally)\n\nDefinition: Checks for break, continue, and return statements in finally\nblocks.\n\nRationale: The use of break, continue, and return statements in finally blocks\ncan cause exceptions to be silenced.\n\n\nfinally blocks execute regardless of whether an exception is raised. If a\nbreak, continue, or return statement is reached in a finally block,\nany exception raised in the try or except blocks will be silenced.\n\nExample:\ndef speed(distance, time):\n    try:\n        return distance / time\n    except ZeroDivisionError:\n        raise ValueError(\"Time cannot be zero\")\n    finally:\n        return 299792458  # `ValueError` is silenced\n\n\n\nUse instead:\n\n\ndef speed(distance, time):\n    try:\n        return distance / time\n    except ZeroDivisionError:\n        raise ValueError(\"Time cannot be zero\")\n\n# Idiom B013 (redundant-tuple-in-exception-handler)\n\nDefinition: Checks for single-element tuples in exception handlers (e.g.,\nexcept (ValueError,):).\n\n\nNote: Single-element tuples consisting of a starred expression\nare allowed.\n\nRationale: A tuple with a single element can be more concisely and idiomatically\nexpressed as a single value.\n\nExample:\ntry:\n    ...\nexcept (ValueError,):\n    ...\n\n\n\nUse instead:\n\n\ntry:\n    ...\nexcept ValueError:\n    ...\n\n# Idiom B014 (duplicate-handler-exception)\n\nDefinition: Checks for exception handlers that catch duplicate exceptions.\n\nRationale: Including the same exception multiple times in the same handler is redundant,\nas the first exception will catch the exception, making the second exception\nunreachable. The same applies to exception hierarchies, as a handler for a\nparent exception (like Exception) will also catch child exceptions (like\nValueError).\n\nExample:\ntry:\n    ...\nexcept (Exception, ValueError):  # `Exception` includes `ValueError`.\n    ...\n\n\n\nUse instead:\n\n\ntry:\n    ...\nexcept Exception:\n    ...\n\n# Idiom B015 (useless-comparison)\n\nDefinition: Checks for useless comparisons.\n\nRationale: Useless comparisons have no effect on the program, and are often included\nby mistake. If the comparison is intended to enforce an invariant, prepend\nthe comparison with an assert. Otherwise, remove it entirely.\n\nExample:\nfoo == bar\n\n\n\nUse instead:\n\n\nassert foo == bar, \"`foo` and `bar` should be equal.\"\n\n# Idiom B016 (raise-literal)\n\nDefinition: Checks for raise statements that raise a literal value.\n\nRationale: raise must be followed by an exception instance or an exception class,\nand exceptions must be instances of BaseException or a subclass thereof.\nRaising a literal will raise a TypeError at runtime.\n\nExample:\nraise \"foo\"\n\n\n\nUse instead:\n\n\nraise Exception(\"foo\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/F622-F631-F632-F633-F634",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom F622 (multiple-starred-expressions)\n\nDefinition: Checks for the use of multiple starred expressions in assignment statements.\n\nRationale: In assignment statements, starred expressions can be used to unpack iterables.\nIncluding more than one starred expression on the left-hand-side of an\nassignment will cause a SyntaxError, as it is unclear which expression\nshould receive the remaining values.\n\nExample:\n*foo, *bar, baz = (1, 2, 3)\n\n# Idiom F631 (assert-tuple)\n\nDefinition: Checks for assert statements that use non-empty tuples as test\nconditions.\n\nRationale: Non-empty tuples are always True, so an assert statement with a\nnon-empty tuple as its test condition will always pass. This is likely a\nmistake.\n\nExample:\nassert (some_condition,)\n\n\n\nUse instead:\n\n\nassert some_condition\n\n# Idiom F632 (is-literal)\n\nDefinition: Checks for is and is not comparisons against literals, like integers,\nstrings, or lists.\n\nRationale: The is and is not comparators operate on identity, in that they check\nwhether two objects are the same object. If the objects are not the same\nobject, the comparison will always be False. Using is and is not with\nconstant literals often works \"by accident\", but are not guaranteed to produce\nthe expected result.\n\n\nAs of Python 3.8, using is and is not with constant literals will produce\na SyntaxWarning.\n\n\nThis rule will also flag is and is not comparisons against non-constant\nliterals, like lists, sets, and dictionaries. While such comparisons will\nnot raise a SyntaxWarning, they are still likely to be incorrect, as they\nwill compare the identities of the objects instead of their values, which\nwill always evaluate to False.\n\n\nInstead, use == and != to compare literals, which will compare the\nvalues of the objects instead of their identities.\n\nExample:\nx = 200\nif x is 200:\n    print(\"It's 200!\")\n\n\n\nUse instead:\n\n\nx = 200\nif x == 200:\n    print(\"It's 200!\")\n\n# Idiom F633 (invalid-print-syntax)\n\nDefinition: Checks for print statements that use the >> syntax.\n\nRationale: In Python 2, the print statement can be used with the >> syntax to\nprint to a file-like object. This print >> sys.stderr syntax no\nlonger exists in Python 3, where print is only a function, not a\nstatement.\n\n\nInstead, use the file keyword argument to the print function, the\nsys.stderr.write function, or the logging module.\n\nExample:\nfrom __future__ import print_function\nimport sys\n\nprint >> sys.stderr, \"Hello, world!\"\n\n\n\nUse instead:\n\n\nprint(\"Hello, world!\", file=sys.stderr)\n\n\n\nOr:\n\n\nimport sys\n\nsys.stderr.write(\"Hello, world!\\n\")\n\n\n\nOr:\n\n\nimport logging\n\nlogging.error(\"Hello, world!\")\n\n# Idiom F634 (if-tuple)\n\nDefinition: Checks for if statements that use non-empty tuples as test conditions.\n\nRationale: Non-empty tuples are always True, so an if statement with a non-empty\ntuple as its test condition will always pass. This is likely a mistake.\n\nExample:\nif (False,):\n    print(\"This will always run\")\n\n\n\nUse instead:\n\n\nif False:\n    print(\"This will never run\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/TID251-TID252-TID253",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom TID251 (banned-api)\n\nDefinition: Checks for banned imports.\n\nRationale: Projects may want to ensure that specific modules or module members are\nnot imported or accessed.\n\n\nSecurity or other company policies may be a reason to impose\nrestrictions on importing external Python libraries. In some cases,\nprojects may adopt conventions around the use of certain modules or\nmodule members that are not enforceable by the language itself.\n\n\nThis rule enforces certain import conventions project-wide automatically.\n\n# Idiom TID252 (relative-imports)\n\nDefinition: Checks for relative imports.\n\nRationale: Absolute imports, or relative imports from siblings, are recommended by PEP 8:\n\n\n\nAbsolute imports are recommended, as they are usually more readable and tend to be better behaved...\nimport mypkg.sibling\nfrom mypkg import sibling\nfrom mypkg.sibling import example\n\nHowever, explicit relative imports are an acceptable alternative to absolute imports,\nespecially when dealing with complex package layouts where using absolute imports would be\nunnecessarily verbose:\nfrom . import sibling\nfrom .sibling import example\n\nExample:\nfrom .. import foo\n\n\n\nUse instead:\n\n\nfrom mypkg import foo\n\n# Idiom TID253 (banned-module-level-imports)\n\nDefinition: Checks for module-level imports that should instead be imported lazily\n(e.g., within a function definition, or an if TYPE_CHECKING: block, or\nsome other nested context).\n\nRationale: Some modules are expensive to import. For example, importing torch or\ntensorflow can introduce a noticeable delay in the startup time of a\nPython program.\n\n\nIn such cases, you may want to enforce that the module is imported lazily\nas needed, rather than at the top of the file. This could involve inlining\nthe import into the function that uses it, rather than importing it\nunconditionally, to ensure that the module is only imported when necessary.\n\nExample:\nimport tensorflow as tf\n\n\ndef show_version():\n    print(tf.__version__)\n\n\n\nUse instead:\n\n\ndef show_version():\n    import tensorflow as tf\n\n    print(tf.__version__)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/SIM118-SIM201-SIM202-SIM208-SIM210",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom SIM118 (in-dict-keys)\n\nDefinition: Checks for key-existence checks against dict.keys() calls.\n\nRationale: When checking for the existence of a key in a given dictionary, using\nkey in dict is more readable and efficient than key in dict.keys(),\nwhile having the same semantics.\n\nExample:\nkey in foo.keys()\n\n\n\nUse instead:\n\n\nkey in foo\n\n# Idiom SIM201 (negate-equal-op)\n\nDefinition: Checks for negated == operators.\n\nRationale: Negated == operators are less readable than != operators. When testing\nfor non-equality, it is more common to use != than ==.\n\nExample:\nnot a == b\n\n\n\nUse instead:\n\n\na != b\n\n# Idiom SIM202 (negate-not-equal-op)\n\nDefinition: Checks for negated != operators.\n\nRationale: Negated != operators are less readable than == operators, as they avoid a\ndouble negation.\n\nExample:\nnot a != b\n\n\n\nUse instead:\n\n\na == b\n\n# Idiom SIM208 (double-negation)\n\nDefinition: Checks for double negations (i.e., multiple not operators).\n\nRationale: A double negation is redundant and less readable than omitting the not\noperators entirely.\n\nExample:\nnot (not a)\n\n\n\nUse instead:\n\n\na\n\n# Idiom SIM210 (if-expr-with-true-false)\n\nDefinition: Checks for if expressions that can be replaced with bool() calls.\n\nRationale: if expressions that evaluate to True for a truthy condition an False\nfor a falsey condition can be replaced with bool() calls, which are more\nconcise and readable.\n\nExample:\nTrue if a else False\n\n\n\nUse instead:\n\n\nbool(a)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/ASYNC115-ASYNC116-ASYNC210-ASYNC220",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom ASYNC115 (async-zero-sleep)\n\nDefinition: Checks for uses of trio.sleep(0) or anyio.sleep(0).\n\nRationale: trio.sleep(0) is equivalent to calling trio.lowlevel.checkpoint().\nHowever, the latter better conveys the intent of the code.\n\nExample:\nimport trio\n\n\nasync def func():\n    await trio.sleep(0)\n\n\n\nUse instead:\n\n\nimport trio\n\n\nasync def func():\n    await trio.lowlevel.checkpoint()\n\n# Idiom ASYNC116 (long-sleep-not-forever)\n\nDefinition: Checks for uses of trio.sleep() or anyio.sleep() with a delay greater than 24 hours.\n\nRationale: Calling sleep() with a delay greater than 24 hours is usually intended\nto sleep indefinitely. Instead of using a large delay,\ntrio.sleep_forever() or anyio.sleep_forever() better conveys the intent.\n\nExample:\nimport trio\n\n\nasync def func():\n    await trio.sleep(86401)\n\n\n\nUse instead:\n\n\nimport trio\n\n\nasync def func():\n    await trio.sleep_forever()\n\n# Idiom ASYNC210 (blocking-http-call-in-async-function)\n\nDefinition: Checks that async functions do not contain blocking HTTP calls.\n\nRationale: Blocking an async function via a blocking HTTP call will block the entire\nevent loop, preventing it from executing other tasks while waiting for the\nHTTP response, negating the benefits of asynchronous programming.\n\n\nInstead of making a blocking HTTP call, use an asynchronous HTTP client\nlibrary such as aiohttp or httpx.\n\nExample:\nasync def fetch():\n    urllib.request.urlopen(\"https://example.com/foo/bar\").read()\n\n\n\nUse instead:\n\n\nasync def fetch():\n    async with aiohttp.ClientSession() as session:\n        async with session.get(\"https://example.com/foo/bar\") as resp:\n            ...\n\n# Idiom ASYNC220 (create-subprocess-in-async-function)\n\nDefinition: Checks that async functions do not create subprocesses with blocking methods.\n\nRationale: Blocking an async function via a blocking call will block the entire\nevent loop, preventing it from executing other tasks while waiting for the\ncall to complete, negating the benefits of asynchronous programming.\n\n\nInstead of making a blocking call, use an equivalent asynchronous library\nor function, like trio.run_process()\nor anyio.run_process().\n\nExample:\nasync def foo():\n    os.popen(cmd)\n\n\n\nUse instead:\n\n\nasync def foo():\n    asyncio.create_subprocess_shell(cmd)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/UP034-UP035-UP036-UP037-UP039",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom UP034 (extraneous-parentheses)\n\nDefinition: Checks for extraneous parentheses.\n\nRationale: Extraneous parentheses are redundant, and can be removed to improve\nreadability while retaining identical semantics.\n\nExample:\nprint((\"Hello, world\"))\n\n\n\nUse instead:\n\n\nprint(\"Hello, world\")\n\n# Idiom UP035 (deprecated-import)\n\nDefinition: Checks for uses of deprecated imports based on the minimum supported\nPython version.\n\nRationale: Deprecated imports may be removed in future versions of Python, and\nshould be replaced with their new equivalents.\n\n\nNote that, in some cases, it may be preferable to continue importing\nmembers from typing_extensions even after they're added to the Python\nstandard library, as typing_extensions can backport bugfixes and\noptimizations from later Python versions. This rule thus avoids flagging\nimports from typing_extensions in such cases.\n\nExample:\nfrom collections import Sequence\n\n\n\nUse instead:\n\n\nfrom collections.abc import Sequence\n\n# Idiom UP036 (outdated-version-block)\n\nDefinition: Checks for conditional blocks gated on sys.version_info comparisons\nthat are outdated for the minimum supported Python version.\n\nRationale: In Python, code can be conditionally executed based on the active\nPython version by comparing against the sys.version_info tuple.\n\n\nIf a code block is only executed for Python versions older than the\nminimum supported version, it should be removed.\n\nExample:\nimport sys\n\nif sys.version_info < (3, 0):\n    print(\"py2\")\nelse:\n    print(\"py3\")\n\n\n\nUse instead:\n\n\nprint(\"py3\")\n\n# Idiom UP037 (quoted-annotation)\n\nDefinition: Checks for the presence of unnecessary quotes in type annotations.\n\nRationale: In Python, type annotations can be quoted to avoid forward references.\n\n\nHowever, if from __future__ import annotations is present, Python\nwill always evaluate type annotations in a deferred manner, making\nthe quotes unnecessary.\n\n\nSimilarly, if the annotation is located in a typing-only context and\nwon't be evaluated by Python at runtime, the quotes will also be\nconsidered unnecessary. For example, Python does not evaluate type\nannotations on assignments in function bodies.\n\nExample:\nGiven:\n\n\nfrom __future__ import annotations\n\n\ndef foo(bar: \"Bar\") -> \"Bar\": ...\n\n\n\nUse instead:\n\n\nfrom __future__ import annotations\n\n\ndef foo(bar: Bar) -> Bar: ...\n\n\n\nGiven:\n\n\ndef foo() -> None:\n    bar: \"Bar\"\n\n\n\nUse instead:\n\n\ndef foo() -> None:\n    bar: Bar\n\n# Idiom UP039 (unnecessary-class-parentheses)\n\nDefinition: Checks for class definitions that include unnecessary parentheses after\nthe class name.\n\nRationale: If a class definition doesn't have any bases, the parentheses are\nunnecessary.\n\nExample:\nclass Foo():\n    ...\n\n\n\nUse instead:\n\n\nclass Foo:\n    ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PT001-PT002-PT003-PT006-PT007",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PT001 (pytest-fixture-incorrect-parentheses-style)\n\nDefinition: Checks for argument-free @pytest.fixture() decorators with or without\nparentheses, depending on the lint.flake8-pytest-style.fixture-parentheses\nsetting.\n\nRationale: If a @pytest.fixture() doesn't take any arguments, the parentheses are\noptional.\n\n\nEither removing those unnecessary parentheses or requiring them for all\nfixtures is fine, but it's best to be consistent. The rule defaults to\nremoving unnecessary parentheses, to match the documentation of the\nofficial pytest projects.\n\nExample:\nimport pytest\n\n\n@pytest.fixture()\ndef my_fixture(): ...\n\n\n\nUse instead:\n\n\nimport pytest\n\n\n@pytest.fixture\ndef my_fixture(): ...\n\n# Idiom PT002 (pytest-fixture-positional-args)\n\nDefinition: Checks for pytest.fixture calls with positional arguments.\n\nRationale: For clarity and consistency, prefer using keyword arguments to specify\nfixture configuration.\n\nExample:\nimport pytest\n\n\n@pytest.fixture(\"module\")\ndef my_fixture(): ...\n\n\n\nUse instead:\n\n\nimport pytest\n\n\n@pytest.fixture(scope=\"module\")\ndef my_fixture(): ...\n\n# Idiom PT003 (pytest-extraneous-scope-function)\n\nDefinition: Checks for pytest.fixture calls with scope=\"function\".\n\nRationale: scope=\"function\" can be omitted, as it is the default.\n\nExample:\nimport pytest\n\n\n@pytest.fixture(scope=\"function\")\ndef my_fixture(): ...\n\n\n\nUse instead:\n\n\nimport pytest\n\n\n@pytest.fixture()\ndef my_fixture(): ...\n\n# Idiom PT006 (pytest-parametrize-names-wrong-type)\n\nDefinition: Checks for the type of parameter names passed to pytest.mark.parametrize.\n\nRationale: The argnames argument of pytest.mark.parametrize takes a string or\na sequence of strings. For a single parameter, it's preferable to use a\nstring. For multiple parameters, it's preferable to use the style\nconfigured via the lint.flake8-pytest-style.parametrize-names-type setting.\n\nExample:\nimport pytest\n\n\n# single parameter, always expecting string\n@pytest.mark.parametrize((\"param\",), [1, 2, 3])\ndef test_foo(param): ...\n\n\n# multiple parameters, expecting tuple\n@pytest.mark.parametrize([\"param1\", \"param2\"], [(1, 2), (3, 4)])\ndef test_bar(param1, param2): ...\n\n\n# multiple parameters, expecting tuple\n@pytest.mark.parametrize(\"param1,param2\", [(1, 2), (3, 4)])\ndef test_baz(param1, param2): ...\n\n\n\nUse instead:\n\n\nimport pytest\n\n\n@pytest.mark.parametrize(\"param\", [1, 2, 3])\ndef test_foo(param): ...\n\n\n@pytest.mark.parametrize((\"param1\", \"param2\"), [(1, 2), (3, 4)])\ndef test_bar(param1, param2): ...\n\n# Idiom PT007 (pytest-parametrize-values-wrong-type)\n\nDefinition: Checks for the type of parameter values passed to pytest.mark.parametrize.\n\nRationale: The argvalues argument of pytest.mark.parametrize takes an iterator of\nparameter values, which can be provided as lists or tuples.\n\n\nTo aid in readability, it's recommended to use a consistent style for the\nlist of values rows, and, in the case of multiple parameters, for each row\nof values.\n\n\nThe style for the list of values rows can be configured via the\nlint.flake8-pytest-style.parametrize-values-type setting, while the\nstyle for each row of values can be configured via the\nlint.flake8-pytest-style.parametrize-values-row-type setting.\n\n\nFor example, lint.flake8-pytest-style.parametrize-values-type will lead to\nthe following expectations:\n\n\n\ntuple: @pytest.mark.parametrize(\"value\", (\"a\", \"b\", \"c\"))\nlist: @pytest.mark.parametrize(\"value\", [\"a\", \"b\", \"c\"])\n\n\n\nSimilarly, lint.flake8-pytest-style.parametrize-values-row-type will lead to\nthe following expectations:\n\n\n\ntuple: @pytest.mark.parametrize((\"key\", \"value\"), [(\"a\", \"b\"), (\"c\", \"d\")])\nlist: @pytest.mark.parametrize((\"key\", \"value\"), [[\"a\", \"b\"], [\"c\", \"d\"]])\n\nExample:\nimport pytest\n\n\n# expected list, got tuple\n@pytest.mark.parametrize(\"param\", (1, 2))\ndef test_foo(param): ...\n\n\n# expected top-level list, got tuple\n@pytest.mark.parametrize(\n    (\"param1\", \"param2\"),\n    (\n        (1, 2),\n        (3, 4),\n    ),\n)\ndef test_bar(param1, param2): ...\n\n\n# expected individual rows to be tuples, got lists\n@pytest.mark.parametrize(\n    (\"param1\", \"param2\"),\n    [\n        [1, 2],\n        [3, 4],\n    ],\n)\ndef test_baz(param1, param2): ...\n\n\n\nUse instead:\n\n\nimport pytest\n\n\n@pytest.mark.parametrize(\"param\", [1, 2, 3])\ndef test_foo(param): ...\n\n\n@pytest.mark.parametrize((\"param1\", \"param2\"), [(1, 2), (3, 4)])\ndef test_bar(param1, param2): ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/N812-N813-N814-N815",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom N812 (lowercase-imported-as-non-lowercase)\n\nDefinition: Checks for lowercase imports that are aliased to non-lowercase names.\n\nRationale: PEP 8 recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\nExample:\nfrom example import myclassname as MyClassName\n\n\n\nUse instead:\n\n\nfrom example import myclassname\n\n# Idiom N813 (camelcase-imported-as-lowercase)\n\nDefinition: Checks for CamelCase imports that are aliased to lowercase names.\n\nRationale: PEP 8 recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\nExample:\nfrom example import MyClassName as myclassname\n\n\n\nUse instead:\n\n\nfrom example import MyClassName\n\n# Idiom N814 (camelcase-imported-as-constant)\n\nDefinition: Checks for CamelCase imports that are aliased to constant-style names.\n\nRationale: PEP 8 recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\nExample:\nfrom example import MyClassName as MY_CLASS_NAME\n\n\n\nUse instead:\n\n\nfrom example import MyClassName\n\n# Idiom N815 (mixed-case-variable-in-class-scope)\n\nDefinition: Checks for class variable names that follow the mixedCase convention.\n\nRationale: PEP 8 recommends that variable names should be lower case and separated\nby underscores (also known as snake_case).\n\n\n\nFunction names should be lowercase, with words separated by underscores\nas necessary to improve readability.\nVariable names follow the same convention as function names.\nmixedCase is allowed only in contexts where that\u2019s already the\nprevailing style (e.g. threading.py), to retain backwards compatibility.\n\nExample:\nclass MyClass:\n    myVariable = \"hello\"\n    another_variable = \"world\"\n\n\n\nUse instead:\n\n\nclass MyClass:\n    my_variable = \"hello\"\n    another_variable = \"world\"\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/S610-S611-S612-S701-S702",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom S610 (django-extra)\n\nDefinition: Checks for uses of Django's extra function where one or more arguments\npassed are not literal expressions.\n\nRationale: Django's extra function can be used to execute arbitrary SQL queries,\nwhich can in turn lead to SQL injection vulnerabilities.\n\nExample:\nfrom django.contrib.auth.models import User\n\n# String interpolation creates a security loophole that could be used\n# for SQL injection:\nUser.objects.all().extra(select={\"test\": \"%secure\" % \"nos\"})\n\n\n\nUse instead:\n\n\nfrom django.contrib.auth.models import User\n\n# SQL injection is impossible if all arguments are literal expressions:\nUser.objects.all().extra(select={\"test\": \"secure\"})\n\n# Idiom S611 (django-raw-sql)\n\nDefinition: Checks for uses of Django's RawSQL function.\n\nRationale: Django's RawSQL function can be used to execute arbitrary SQL queries,\nwhich can in turn lead to SQL injection vulnerabilities.\n\nExample:\nfrom django.db.models.expressions import RawSQL\nfrom django.contrib.auth.models import User\n\nUser.objects.annotate(val=RawSQL(\"%s\" % input_param, []))\n\n# Idiom S612 (logging-config-insecure-listen)\n\nDefinition: Checks for insecure logging.config.listen calls.\n\nRationale: logging.config.listen starts a server that listens for logging\nconfiguration requests. This is insecure, as parts of the configuration are\npassed to the built-in eval function, which can be used to execute\narbitrary code.\n\nExample:\nimport logging\n\nlogging.config.listen(9999)\n\n# Idiom S701 (jinja2-autoescape-false)\n\nDefinition: Checks for jinja2 templates that use autoescape=False.\n\nRationale: jinja2 templates that use autoescape=False are vulnerable to cross-site\nscripting (XSS) attacks that allow attackers to execute arbitrary\nJavaScript.\n\n\nBy default, jinja2 sets autoescape to False, so it is important to\nset autoescape=True or use the select_autoescape function to mitigate\nXSS vulnerabilities.\n\nExample:\nimport jinja2\n\njinja2.Environment(loader=jinja2.FileSystemLoader(\".\"))\n\n\n\nUse instead:\n\n\nimport jinja2\n\njinja2.Environment(loader=jinja2.FileSystemLoader(\".\"), autoescape=True)\n\n# Idiom S702 (mako-templates)\n\nDefinition: Checks for uses of the mako templates.\n\nRationale: Mako templates allow HTML and JavaScript rendering by default, and are\ninherently open to XSS attacks. Ensure variables in all templates are\nproperly sanitized via the n, h or x flags (depending on context).\nFor example, to HTML escape the variable data, use ${ data |h }.\n\nExample:\nfrom mako.template import Template\n\nTemplate(\"hello\")\n\n\n\nUse instead:\n\n\nfrom mako.template import Template\n\nTemplate(\"hello |h\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/F509-F521-F522-F523-F524",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom F509 (percent-format-unsupported-format-character)\n\nDefinition: Checks for printf-style format strings with invalid format characters.\n\nRationale: In printf-style format strings, the % character is used to indicate\nplaceholders. If a % character is not followed by a valid format\ncharacter, it will raise a ValueError at runtime.\n\nExample:\n\"Hello, %S\" % \"world\"\n\n\n\nUse instead:\n\n\n\"Hello, %s\" % \"world\"\n\n# Idiom F521 (string-dot-format-invalid-format)\n\nDefinition: Checks for str.format calls with invalid format strings.\n\nRationale: Invalid format strings will raise a ValueError.\n\nExample:\n\"{\".format(foo)\n\n\n\nUse instead:\n\n\n\"{}\".format(foo)\n\n# Idiom F522 (string-dot-format-extra-named-arguments)\n\nDefinition: Checks for str.format calls with unused keyword arguments.\n\nRationale: Unused keyword arguments are redundant, and often indicative of a mistake.\nThey should be removed.\n\nExample:\n\"Hello, {name}\".format(greeting=\"Hello\", name=\"World\")\n\n\n\nUse instead:\n\n\n\"Hello, {name}\".format(name=\"World\")\n\n# Idiom F523 (string-dot-format-extra-positional-arguments)\n\nDefinition: Checks for str.format calls with unused positional arguments.\n\nRationale: Unused positional arguments are redundant, and often indicative of a mistake.\nThey should be removed.\n\nExample:\n\"Hello, {0}\".format(\"world\", \"!\")\n\n\n\nUse instead:\n\n\n\"Hello, {0}\".format(\"world\")\n\n# Idiom F524 (string-dot-format-missing-arguments)\n\nDefinition: Checks for str.format calls with placeholders that are missing arguments.\n\nRationale: In str.format calls, omitting arguments for placeholders will raise a\nKeyError at runtime.\n\nExample:\n\"{greeting}, {name}\".format(name=\"World\")\n\n\n\nUse instead:\n\n\n\"{greeting}, {name}\".format(greeting=\"Hello\", name=\"World\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PTH100-PTH101-PTH102-PTH103-PTH104",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PTH100 (os-path-abspath)\n\nDefinition: Checks for uses of os.path.abspath.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os.path. When possible, using Path object\nmethods such as Path.resolve() can improve readability over the os.path\nmodule's counterparts (e.g., os.path.abspath()).\n\n# Idiom PTH101 (os-chmod)\n\nDefinition: Checks for uses of os.chmod.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os. When possible, using Path object\nmethods such as Path.chmod() can improve readability over the os\nmodule's counterparts (e.g., os.chmod()).\n\n# Idiom PTH102 (os-mkdir)\n\nDefinition: Checks for uses of os.mkdir.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os. When possible, using Path object\nmethods such as Path.mkdir() can improve readability over the os\nmodule's counterparts (e.g., os.mkdir()).\n\n# Idiom PTH103 (os-makedirs)\n\nDefinition: Checks for uses of os.makedirs.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os. When possible, using Path object\nmethods such as Path.mkdir(parents=True) can improve readability over the\nos module's counterparts (e.g., os.makedirs().\n\n# Idiom PTH104 (os-rename)\n\nDefinition: Checks for uses of os.rename.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os. When possible, using Path object\nmethods such as Path.rename() can improve readability over the os\nmodule's counterparts (e.g., os.rename()).\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/SIM101-SIM102-SIM103-SIM105",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom SIM101 (duplicate-isinstance-call)\n\nDefinition: Checks for multiple isinstance calls on the same target.\n\nRationale: To check if an object is an instance of any one of multiple types\nor classes, it is unnecessary to use multiple isinstance calls, as\nthe second argument of the isinstance built-in function accepts a\ntuple of types and classes.\n\n\nUsing a single isinstance call implements the same behavior with more\nconcise code and clearer intent.\n\nExample:\nif isinstance(obj, int) or isinstance(obj, float):\n    pass\n\n\n\nUse instead:\n\n\nif isinstance(obj, (int, float)):\n    pass\n\n# Idiom SIM102 (collapsible-if)\n\nDefinition: Checks for nested if statements that can be collapsed into a single if\nstatement.\n\nRationale: Nesting if statements leads to deeper indentation and makes code harder to\nread. Instead, combine the conditions into a single if statement with an\nand operator.\n\nExample:\nif foo:\n    if bar:\n        ...\n\n\n\nUse instead:\n\n\nif foo and bar:\n    ...\n\n# Idiom SIM103 (needless-bool)\n\nDefinition: Checks for if statements that can be replaced with bool.\n\nRationale: if statements that return True for a truthy condition and False for\na falsy condition can be replaced with boolean casts.\n\nExample:\nGiven:\n\n\nif x > 0:\n    return True\nelse:\n    return False\n\n\n\nUse instead:\n\n\nreturn x > 0\n\n\n\nOr, given:\n\n\nif x > 0:\n    return True\nreturn False\n\n\n\nUse instead:\n\n\nreturn x > 0\n\n# Idiom SIM105 (suppressible-exception)\n\nDefinition: Checks for try-except-pass blocks that can be replaced with the\ncontextlib.suppress context manager.\n\nRationale: Using contextlib.suppress is more concise and directly communicates the\nintent of the code: to suppress a given exception.\n\n\nNote that contextlib.suppress is slower than using try-except-pass\ndirectly. For performance-critical code, consider retaining the\ntry-except-pass pattern.\n\nExample:\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n    pass\n\n\n\nUse instead:\n\n\nimport contextlib\n\nwith contextlib.suppress(ZeroDivisionError):\n    1 / 0\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/B901-B903-B904",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom B901 (return-in-generator)\n\nDefinition: Checks for return {value} statements in functions that also contain yield\nor yield from statements.\n\nRationale: Using return {value} in a generator function was syntactically invalid in\nPython 2. In Python 3 return {value} can be used in a generator; however,\nthe combination of yield and return can lead to confusing behavior, as\nthe return statement will cause the generator to raise StopIteration\nwith the value provided, rather than returning the value to the caller.\n\n\nFor example, given:\n\n\nfrom collections.abc import Iterable\nfrom pathlib import Path\n\n\ndef get_file_paths(file_types: Iterable[str] | None = None) -> Iterable[Path]:\n    dir_path = Path(\".\")\n    if file_types is None:\n        return dir_path.glob(\"*\")\n\n    for file_type in file_types:\n        yield from dir_path.glob(f\"*.{file_type}\")\n\n\n\nReaders might assume that get_file_paths() would return an iterable of\nPath objects in the directory; in reality, though, list(get_file_paths())\nevaluates to [], since the return statement causes the generator to raise\nStopIteration with the value dir_path.glob(\"*\"):\n\n\n>>> list(get_file_paths(file_types=[\"cfg\", \"toml\"]))\n[PosixPath('setup.cfg'), PosixPath('pyproject.toml')]\n>>> list(get_file_paths())\n[]\n\n\n\nFor intentional uses of return in a generator, consider suppressing this\ndiagnostic.\n\nExample:\nfrom collections.abc import Iterable\nfrom pathlib import Path\n\n\ndef get_file_paths(file_types: Iterable[str] | None = None) -> Iterable[Path]:\n    dir_path = Path(\".\")\n    if file_types is None:\n        return dir_path.glob(\"*\")\n\n    for file_type in file_types:\n        yield from dir_path.glob(f\"*.{file_type}\")\n\n\n\nUse instead:\n\n\nfrom collections.abc import Iterable\nfrom pathlib import Path\n\n\ndef get_file_paths(file_types: Iterable[str] | None = None) -> Iterable[Path]:\n    dir_path = Path(\".\")\n    if file_types is None:\n        yield from dir_path.glob(\"*\")\n    else:\n        for file_type in file_types:\n            yield from dir_path.glob(f\"*.{file_type}\")\n\n# Idiom B903 (class-as-data-structure)\n\nDefinition: Checks for classes that only have a public __init__ method,\nwithout base classes and decorators.\n\nRationale: Classes with just an __init__ are possibly better off\nbeing a dataclass or a namedtuple, which have less boilerplate.\n\nExample:\nclass Point:\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n\n\n\nUse instead:\n\n\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Point:\n    x: float\n    y: float\n\n# Idiom B904 (raise-without-from-inside-except)\n\nDefinition: Checks for raise statements in exception handlers that lack a from\nclause.\n\nRationale: In Python, raise can be used with or without an exception from which the\ncurrent exception is derived. This is known as exception chaining. When\nprinting the stack trace, chained exceptions are displayed in such a way\nso as make it easier to trace the exception back to its root cause.\n\n\nWhen raising an exception from within an except clause, always include a\nfrom clause to facilitate exception chaining. If the exception is not\nchained, it will be difficult to trace the exception back to its root cause.\n\nExample:\ntry:\n    ...\nexcept FileNotFoundError:\n    if ...:\n        raise RuntimeError(\"...\")\n    else:\n        raise UserWarning(\"...\")\n\n\n\nUse instead:\n\n\ntry:\n    ...\nexcept FileNotFoundError as exc:\n    if ...:\n        raise RuntimeError(\"...\") from None\n    else:\n        raise UserWarning(\"...\") from exc\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/SIM107-SIM108-SIM109-SIM110-SIM112",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom SIM107 (return-in-try-except-finally)\n\nDefinition: Checks for return statements in try-except and finally blocks.\n\nRationale: The return statement in a finally block will always be executed, even if\nan exception is raised in the try or except block. This can lead to\nunexpected behavior.\n\nExample:\ndef squared(n):\n    try:\n        sqr = n**2\n        return sqr\n    except Exception:\n        return \"An exception occurred\"\n    finally:\n        return -1  # Always returns -1.\n\n\n\nUse instead:\n\n\ndef squared(n):\n    try:\n        return_value = n**2\n    except Exception:\n        return_value = \"An exception occurred\"\n    finally:\n        return_value = -1\n    return return_value\n\n# Idiom SIM108 (if-else-block-instead-of-if-exp)\n\nDefinition: Check for if-else-blocks that can be replaced with a ternary operator.\nMoreover, in preview, check if these ternary expressions can be\nfurther simplified to binary expressions.\n\nRationale: if-else-blocks that assign a value to a variable in both branches can\nbe expressed more concisely by using a ternary or binary operator.\n\nExample:\nif foo:\n    bar = x\nelse:\n    bar = y\n\n\n\nUse instead:\n\n\nbar = x if foo else y\n\n\n\nOr, in preview:\n\n\nif cond:\n    z = cond\nelse:\n    z = other_cond\n\n\n\nUse instead:\n\n\nz = cond or other_cond\n\n# Idiom SIM109 (compare-with-tuple)\n\nDefinition: Checks for boolean expressions that contain multiple equality comparisons\nto the same value.\n\nRationale: To check if an object is equal to any one of multiple values, it's more\nconcise to use the in operator with a tuple of values.\n\nExample:\nif foo == x or foo == y:\n    ...\n\n\n\nUse instead:\n\n\nif foo in (x, y):\n    ...\n\n# Idiom SIM110 (reimplemented-builtin)\n\nDefinition: Checks for for loops that can be replaced with a builtin function, like\nany or all.\n\nRationale: Using a builtin function is more concise and readable.\n\nExample:\nfor item in iterable:\n    if predicate(item):\n        return True\nreturn False\n\n\n\nUse instead:\n\n\nreturn any(predicate(item) for item in iterable)\n\n# Idiom SIM112 (uncapitalized-environment-variables)\n\nDefinition: Check for environment variables that are not capitalized.\n\nRationale: By convention, environment variables should be capitalized.\n\n\nOn Windows, environment variables are case-insensitive and are converted to\nuppercase, so using lowercase environment variables can lead to subtle bugs.\n\nExample:\nimport os\n\nos.environ[\"foo\"]\n\n\n\nUse instead:\n\n\nimport os\n\nos.environ[\"FOO\"]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/YTT101-YTT102-YTT103-YTT201-YTT202",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom YTT101 (sys-version-slice3)\n\nDefinition: Checks for uses of sys.version[:3].\n\nRationale: If the current major or minor version consists of multiple digits,\nsys.version[:3] will truncate the version number (e.g., \"3.10\" would\nbecome \"3.1\"). This is likely unintended, and can lead to subtle bugs if\nthe version string is used to test against a specific Python version.\n\n\nInstead, use sys.version_info to access the current major and minor\nversion numbers as a tuple, which can be compared to other tuples\nwithout issue.\n\nExample:\nimport sys\n\nsys.version[:3]  # Evaluates to \"3.1\" on Python 3.10.\n\n\n\nUse instead:\n\n\nimport sys\n\nsys.version_info[:2]  # Evaluates to (3, 10) on Python 3.10.\n\n# Idiom YTT102 (sys-version2)\n\nDefinition: Checks for uses of sys.version[2].\n\nRationale: If the current major or minor version consists of multiple digits,\nsys.version[2] will select the first digit of the minor number only\n(e.g., \"3.10\" would evaluate to \"1\"). This is likely unintended, and\ncan lead to subtle bugs if the version is used to test against a minor\nversion number.\n\n\nInstead, use sys.version_info.minor to access the current minor version\nnumber.\n\nExample:\nimport sys\n\nsys.version[2]  # Evaluates to \"1\" on Python 3.10.\n\n\n\nUse instead:\n\n\nimport sys\n\nf\"{sys.version_info.minor}\"  # Evaluates to \"10\" on Python 3.10.\n\n# Idiom YTT103 (sys-version-cmp-str3)\n\nDefinition: Checks for comparisons that test sys.version against string literals,\nsuch that the comparison will evaluate to False on Python 3.10 or later.\n\nRationale: Comparing sys.version to a string is error-prone and may cause subtle\nbugs, as the comparison will be performed lexicographically, not\nsemantically. For example, sys.version > \"3.9\" will evaluate to False\nwhen using Python 3.10, as \"3.10\" is lexicographically \"less\" than\n\"3.9\".\n\n\nInstead, use sys.version_info to access the current major and minor\nversion numbers as a tuple, which can be compared to other tuples\nwithout issue.\n\nExample:\nimport sys\n\nsys.version > \"3.9\"  # `False` on Python 3.10.\n\n\n\nUse instead:\n\n\nimport sys\n\nsys.version_info > (3, 9)  # `True` on Python 3.10.\n\n# Idiom YTT201 (sys-version-info0-eq3)\n\nDefinition: Checks for equality comparisons against the major version returned by\nsys.version_info (e.g., sys.version_info[0] == 3).\n\nRationale: Using sys.version_info[0] == 3 to verify that the major version is\nPython 3 or greater will fail if the major version number is ever\nincremented (e.g., to Python 4). This is likely unintended, as code\nthat uses this comparison is likely intended to be run on Python 2,\nbut would now run on Python 4 too.\n\n\nInstead, use >= to check if the major version number is 3 or greater,\nto future-proof the code.\n\nExample:\nimport sys\n\nif sys.version_info[0] == 3:\n    ...\nelse:\n    print(\"Python 2\")  # This will be printed on Python 4.\n\n\n\nUse instead:\n\n\nimport sys\n\nif sys.version_info >= (3,):\n    ...\nelse:\n    print(\"Python 2\")  # This will not be printed on Python 4.\n\n# Idiom YTT202 (six-py3)\n\nDefinition: Checks for uses of six.PY3.\n\nRationale: six.PY3 will evaluate to False on Python 4 and greater. This is likely\nunintended, and may cause code intended to run on Python 2 to run on Python 4\ntoo.\n\n\nInstead, use not six.PY2 to validate that the current Python major version is\nnot equal to 2, to future-proof the code.\n\nExample:\nimport six\n\nsix.PY3  # `False` on Python 4.\n\n\n\nUse instead:\n\n\nimport six\n\nnot six.PY2  # `True` on Python 4.\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/S704-FBT001-FBT002-FBT003",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom S704 (unsafe-markup-use)\n\nDefinition: Checks for non-literal strings being passed to markupsafe.Markup.\n\nRationale: [markupsafe.Markup][markupsafe.Markup] does not perform any escaping, so passing dynamic\ncontent, like f-strings, variables or interpolated strings will potentially\nlead to XSS vulnerabilities.\n\n\nInstead you should interpolate the Markup object.\n\n\nUsing lint.flake8-bandit.extend-markup-names additional objects can be\ntreated like Markup.\n\n\nThis rule was originally inspired by flake8-markupsafe but doesn't carve\nout any exceptions for i18n related calls by default.\n\n\nYou can use lint.flake8-bandit.allowed-markup-calls to specify exceptions.\n\nExample:\nGiven:\n\n\nfrom markupsafe import Markup\n\ncontent = \"<script>alert('Hello, world!')</script>\"\nhtml = Markup(f\"<b>{content}</b>\")  # XSS\n\n\n\nUse instead:\n\n\nfrom markupsafe import Markup\n\ncontent = \"<script>alert('Hello, world!')</script>\"\nhtml = Markup(\"<b>{}</b>\").format(content)  # Safe\n\n\n\nGiven:\n\n\nfrom markupsafe import Markup\n\nlines = [\n    Markup(\"<b>heading</b>\"),\n    \"<script>alert('XSS attempt')</script>\",\n]\nhtml = Markup(\"<br>\".join(lines))  # XSS\n\n\n\nUse instead:\n\n\nfrom markupsafe import Markup\n\nlines = [\n    Markup(\"<b>heading</b>\"),\n    \"<script>alert('XSS attempt')</script>\",\n]\nhtml = Markup(\"<br>\").join(lines)  # Safe\n\n# Idiom FBT001 (boolean-type-hint-positional-argument)\n\nDefinition: Checks for the use of boolean positional arguments in function definitions,\nas determined by the presence of a bool type hint.\n\nRationale: Calling a function with boolean positional arguments is confusing as the\nmeaning of the boolean value is not clear to the caller and to future\nreaders of the code.\n\n\nThe use of a boolean will also limit the function to only two possible\nbehaviors, which makes the function difficult to extend in the future.\n\n\nInstead, consider refactoring into separate implementations for the\nTrue and False cases, using an Enum, or making the argument a\nkeyword-only argument, to force callers to be explicit when providing\nthe argument.\n\n\nDunder methods that define operators are exempt from this rule, as are\nsetters and @override definitions.\n\n\nIn preview, this rule will also flag annotations that include boolean\nvariants, like bool | int.\n\nExample:\nfrom math import ceil, floor\n\n\ndef round_number(number: float, up: bool) -> int:\n    return ceil(number) if up else floor(number)\n\n\nround_number(1.5, True)  # What does `True` mean?\nround_number(1.5, False)  # What does `False` mean?\n\n\n\nInstead, refactor into separate implementations:\n\n\nfrom math import ceil, floor\n\n\ndef round_up(number: float) -> int:\n    return ceil(number)\n\n\ndef round_down(number: float) -> int:\n    return floor(number)\n\n\nround_up(1.5)\nround_down(1.5)\n\n\n\nOr, refactor to use an Enum:\n\n\nfrom enum import Enum\n\n\nclass RoundingMethod(Enum):\n    UP = 1\n    DOWN = 2\n\n\ndef round_number(value: float, method: RoundingMethod) -> float: ...\n\n\n\nOr, make the argument a keyword-only argument:\n\n\nfrom math import ceil, floor\n\n\ndef round_number(number: float, *, up: bool) -> int:\n    return ceil(number) if up else floor(number)\n\n\nround_number(1.5, up=True)\nround_number(1.5, up=False)\n\n# Idiom FBT002 (boolean-default-value-positional-argument)\n\nDefinition: Checks for the use of boolean positional arguments in function definitions,\nas determined by the presence of a boolean default value.\n\nRationale: Calling a function with boolean positional arguments is confusing as the\nmeaning of the boolean value is not clear to the caller and to future\nreaders of the code.\n\n\nThe use of a boolean will also limit the function to only two possible\nbehaviors, which makes the function difficult to extend in the future.\n\n\nInstead, consider refactoring into separate implementations for the\nTrue and False cases, using an Enum, or making the argument a\nkeyword-only argument, to force callers to be explicit when providing\nthe argument.\n\nExample:\nfrom math import ceil, floor\n\n\ndef round_number(number, up=True):\n    return ceil(number) if up else floor(number)\n\n\nround_number(1.5, True)  # What does `True` mean?\nround_number(1.5, False)  # What does `False` mean?\n\n\n\nInstead, refactor into separate implementations:\n\n\nfrom math import ceil, floor\n\n\ndef round_up(number):\n    return ceil(number)\n\n\ndef round_down(number):\n    return floor(number)\n\n\nround_up(1.5)\nround_down(1.5)\n\n\n\nOr, refactor to use an Enum:\n\n\nfrom enum import Enum\n\n\nclass RoundingMethod(Enum):\n    UP = 1\n    DOWN = 2\n\n\ndef round_number(value, method):\n    return ceil(number) if method is RoundingMethod.UP else floor(number)\n\n\nround_number(1.5, RoundingMethod.UP)\nround_number(1.5, RoundingMethod.DOWN)\n\n\n\nOr, make the argument a keyword-only argument:\n\n\nfrom math import ceil, floor\n\n\ndef round_number(number, *, up=True):\n    return ceil(number) if up else floor(number)\n\n\nround_number(1.5, up=True)\nround_number(1.5, up=False)\n\n# Idiom FBT003 (boolean-positional-value-in-call)\n\nDefinition: Checks for boolean positional arguments in function calls.\n\n\nSome functions are whitelisted by default. To extend the list of allowed calls\nconfigure the lint.flake8-boolean-trap.extend-allowed-calls option.\n\nRationale: Calling a function with boolean positional arguments is confusing as the\nmeaning of the boolean value is not clear to the caller, and to future\nreaders of the code.\n\nExample:\ndef func(flag: bool) -> None: ...\n\n\nfunc(True)\n\n\n\nUse instead:\n\n\ndef func(flag: bool) -> None: ...\n\n\nfunc(flag=True)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/E741-E742-E743-E902",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom E741 (ambiguous-variable-name)\n\nDefinition: Checks for the use of the characters 'l', 'O', or 'I' as variable names.\n\n\nNote: This rule is automatically disabled for all stub files\n(files with .pyi extensions). The rule has little relevance for authors\nof stubs: a well-written stub should aim to faithfully represent the\ninterface of the equivalent .py file as it exists at runtime, including any\nambiguously named variables in the runtime module.\n\nRationale: In some fonts, these characters are indistinguishable from the\nnumerals one and zero. When tempted to use 'l', use 'L' instead.\n\nExample:\nl = 0\nO = 123\nI = 42\n\n\n\nUse instead:\n\n\nL = 0\no = 123\ni = 42\n\n# Idiom E742 (ambiguous-class-name)\n\nDefinition: Checks for the use of the characters 'l', 'O', or 'I' as class names.\n\nRationale: In some fonts, these characters are indistinguishable from the\nnumerals one and zero. When tempted to use 'l', use 'L' instead.\n\nExample:\nclass I(object): ...\n\n\n\nUse instead:\n\n\nclass Integer(object): ...\n\n# Idiom E743 (ambiguous-function-name)\n\nDefinition: Checks for the use of the characters 'l', 'O', or 'I' as function names.\n\nRationale: In some fonts, these characters are indistinguishable from the\nnumerals one and zero. When tempted to use 'l', use 'L' instead.\n\nExample:\ndef l(x): ...\n\n\n\nUse instead:\n\n\ndef long_name(x): ...\n\n# Idiom E902 (io-error)\n\nDefinition: This is not a regular diagnostic; instead, it's raised when a file cannot be read\nfrom disk.\n\nRationale: An IOError indicates an error in the development setup. For example, the user may\nnot have permissions to read a given file, or the filesystem may contain a broken\nsymlink.\n\nExample:\nOn Linux or macOS:\n\n\n$ echo 'print(\"hello world!\")' > a.py\n$ chmod 000 a.py\n$ ruff a.py\na.py:1:1: E902 Permission denied (os error 13)\nFound 1 error.\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/G001-G002-G003-G004",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom G001 (logging-string-format)\n\nDefinition: Checks for uses of str.format to format logging messages.\n\nRationale: The logging module provides a mechanism for passing additional values to\nbe logged using the extra keyword argument. This is more consistent, more\nefficient, and less error-prone than formatting the string directly.\n\n\nUsing str.format to format a logging message requires that Python eagerly\nformat the string, even if the logging statement is never executed (e.g.,\nif the log level is above the level of the logging statement), whereas\nusing the extra keyword argument defers formatting until required.\n\n\nAdditionally, the use of extra will ensure that the values are made\navailable to all handlers, which can then be configured to log the values\nin a consistent manner.\n\n\nAs an alternative to extra, passing values as arguments to the logging\nmethod can also be used to defer string formatting until required.\n\nExample:\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"{} - Something happened\".format(user))\n\n\n\nUse instead:\n\n\nimport logging\n\nlogging.basicConfig(format=\"%(user_id)s - %(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"Something happened\", extra={\"user_id\": user})\n\n\n\nOr:\n\n\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"%s - Something happened\", user)\n\n# Idiom G002 (logging-percent-format)\n\nDefinition: Checks for uses of printf-style format strings to format logging\nmessages.\n\nRationale: The logging module provides a mechanism for passing additional values to\nbe logged using the extra keyword argument. This is more consistent, more\nefficient, and less error-prone than formatting the string directly.\n\n\nUsing printf-style format strings to format a logging message requires\nthat Python eagerly format the string, even if the logging statement is\nnever executed (e.g., if the log level is above the level of the logging\nstatement), whereas using the extra keyword argument defers formatting\nuntil required.\n\n\nAdditionally, the use of extra will ensure that the values are made\navailable to all handlers, which can then be configured to log the values\nin a consistent manner.\n\n\nAs an alternative to extra, passing values as arguments to the logging\nmethod can also be used to defer string formatting until required.\n\nExample:\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"%s - Something happened\" % user)\n\n\n\nUse instead:\n\n\nimport logging\n\nlogging.basicConfig(format=\"%(user_id)s - %(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"Something happened\", extra=dict(user_id=user))\n\n\n\nOr:\n\n\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"%s - Something happened\", user)\n\n# Idiom G003 (logging-string-concat)\n\nDefinition: Checks for uses string concatenation via the + operator to format logging\nmessages.\n\nRationale: The logging module provides a mechanism for passing additional values to\nbe logged using the extra keyword argument. This is more consistent, more\nefficient, and less error-prone than formatting the string directly.\n\n\nUsing concatenation to format a logging message requires that Python\neagerly format the string, even if the logging statement is never executed\n(e.g., if the log level is above the level of the logging statement),\nwhereas using the extra keyword argument defers formatting until required.\n\n\nAdditionally, the use of extra will ensure that the values are made\navailable to all handlers, which can then be configured to log the values\nin a consistent manner.\n\n\nAs an alternative to extra, passing values as arguments to the logging\nmethod can also be used to defer string formatting until required.\n\nExample:\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(user + \" - Something happened\")\n\n\n\nUse instead:\n\n\nimport logging\n\nlogging.basicConfig(format=\"%(user_id)s - %(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"Something happened\", extra=dict(user_id=user))\n\n\n\nOr:\n\n\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"%s - Something happened\", user)\n\n# Idiom G004 (logging-f-string)\n\nDefinition: Checks for uses of f-strings to format logging messages.\n\nRationale: The logging module provides a mechanism for passing additional values to\nbe logged using the extra keyword argument. This is more consistent, more\nefficient, and less error-prone than formatting the string directly.\n\n\nUsing f-strings to format a logging message requires that Python eagerly\nformat the string, even if the logging statement is never executed (e.g.,\nif the log level is above the level of the logging statement), whereas\nusing the extra keyword argument defers formatting until required.\n\n\nAdditionally, the use of extra will ensure that the values are made\navailable to all handlers, which can then be configured to log the values\nin a consistent manner.\n\n\nAs an alternative to extra, passing values as arguments to the logging\nmethod can also be used to defer string formatting until required.\n\nExample:\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(f\"{user} - Something happened\")\n\n\n\nUse instead:\n\n\nimport logging\n\nlogging.basicConfig(format=\"%(user_id)s - %(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"Something happened\", extra=dict(user_id=user))\n\n\n\nOr:\n\n\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"%s - Something happened\", user)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/RUF013-RUF015-RUF016-RUF017-RUF018",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom RUF013 (implicit-optional)\n\nDefinition: Checks for the use of implicit Optional in type annotations when the\ndefault parameter value is None.\n\nRationale: Implicit Optional is prohibited by PEP 484. It is confusing and\ninconsistent with the rest of the type system.\n\n\nIt's recommended to use Optional[T] instead. For Python 3.10 and later,\nyou can also use T | None.\n\nExample:\ndef foo(arg: int = None):\n    pass\n\n\n\nUse instead:\n\n\nfrom typing import Optional\n\n\ndef foo(arg: Optional[int] = None):\n    pass\n\n\n\nOr, for Python 3.10 and later:\n\n\ndef foo(arg: int | None = None):\n    pass\n\n\n\nIf you want to use the | operator in Python 3.9 and earlier, you can\nuse future imports:\n\n\nfrom __future__ import annotations\n\n\ndef foo(arg: int | None = None):\n    pass\n\n# Idiom RUF015 (unnecessary-iterable-allocation-for-first-element)\n\nDefinition: Checks the following constructs, all of which can be replaced by\nnext(iter(...)):\n\n\n\nlist(...)[0]\ntuple(...)[0]\nlist(i for i in ...)[0]\n[i for i in ...][0]\nlist(...).pop(0)\n\nRationale: Calling e.g. list(...) will create a new list of the entire collection,\nwhich can be very expensive for large collections. If you only need the\nfirst element of the collection, you can use next(...) or\nnext(iter(...) to lazily fetch the first element. The same is true for\nthe other constructs.\n\nExample:\nhead = list(x)[0]\nhead = [x * x for x in range(10)][0]\n\n\n\nUse instead:\n\n\nhead = next(iter(x))\nhead = next(x * x for x in range(10))\n\n# Idiom RUF016 (invalid-index-type)\n\nDefinition: Checks for indexed access to lists, strings, tuples, bytes, and comprehensions\nusing a type other than an integer or slice.\n\nRationale: Only integers or slices can be used as indices to these types. Using\nother types will result in a TypeError at runtime and a SyntaxWarning at\nimport time.\n\nExample:\nvar = [1, 2, 3][\"x\"]\n\n\n\nUse instead:\n\n\nvar = [1, 2, 3][0]\n\n# Idiom RUF017 (quadratic-list-summation)\n\nDefinition: Checks for the use of sum() to flatten lists of lists, which has\nquadratic complexity.\n\nRationale: The use of sum() to flatten lists of lists is quadratic in the number of\nlists, as sum() creates a new list for each element in the summation.\n\n\nInstead, consider using another method of flattening lists to avoid\nquadratic complexity. The following methods are all linear in the number of\nlists:\n\n\n\nfunctools.reduce(operator.iadd, lists, [])\nlist(itertools.chain.from_iterable(lists))\n[item for sublist in lists for item in sublist]\n\n\n\nWhen fixing relevant violations, Ruff defaults to the functools.reduce\nform, which outperforms the other methods in microbenchmarks.\n\nExample:\nlists = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\njoined = sum(lists, [])\n\n\n\nUse instead:\n\n\nimport functools\nimport operator\n\n\nlists = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nfunctools.reduce(operator.iadd, lists, [])\n\n# Idiom RUF018 (assignment-in-assert)\n\nDefinition: Checks for named assignment expressions (e.g., x := 0) in assert\nstatements.\n\nRationale: Named assignment expressions (also known as \"walrus operators\") are used to\nassign a value to a variable as part of a larger expression.\n\n\nNamed assignments are syntactically valid in assert statements. However,\nwhen the Python interpreter is run under the -O flag, assert statements\nare not executed. In this case, the named assignment will also be ignored,\nwhich may result in unexpected behavior (e.g., undefined variable\naccesses).\n\nExample:\nassert (x := 0) == 0\nprint(x)\n\n\n\nUse instead:\n\n\nx = 0\nassert x == 0\nprint(x)\n\n\n\nThe rule avoids flagging named expressions that define variables which are\nonly referenced from inside assert statements; the following will not\ntrigger the rule:\n\n\nassert (x := y**2) > 42, f\"Expected >42 but got {x}\"\n\n\n\nNor will this:\n\n\nassert (x := y**2) > 42\nassert x < 1_000_000\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PIE804-PIE807-PIE808-PIE810",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PIE804 (unnecessary-dict-kwargs)\n\nDefinition: Checks for unnecessary dict kwargs.\n\nRationale: If the dict keys are valid identifiers, they can be passed as keyword\narguments directly.\n\nExample:\ndef foo(bar):\n    return bar + 1\n\n\nprint(foo(**{\"bar\": 2}))  # prints 3\n\n\n\nUse instead:\n\n\ndef foo(bar):\n    return bar + 1\n\n\nprint(foo(bar=2))  # prints 3\n\n# Idiom PIE807 (reimplemented-container-builtin)\n\nDefinition: Checks for lambdas that can be replaced with the list or dict builtins.\n\nRationale: Using container builtins are more succinct and idiomatic than wrapping\nthe literal in a lambda.\n\nExample:\nfrom dataclasses import dataclass, field\n\n\n@dataclass\nclass Foo:\n    bar: list[int] = field(default_factory=lambda: [])\n\n\n\nUse instead:\n\n\nfrom dataclasses import dataclass, field\n\n\n@dataclass\nclass Foo:\n    bar: list[int] = field(default_factory=list)\n    baz: dict[str, int] = field(default_factory=dict)\n\n# Idiom PIE808 (unnecessary-range-start)\n\nDefinition: Checks for range calls with an unnecessary start argument.\n\nRationale: range(0, x) is equivalent to range(x), as 0 is the default value for\nthe start argument. Omitting the start argument makes the code more\nconcise and idiomatic.\n\nExample:\nrange(0, 3)\n\n\n\nUse instead:\n\n\nrange(3)\n\n# Idiom PIE810 (multiple-starts-ends-with)\n\nDefinition: Checks for startswith or endswith calls on the same value with\ndifferent prefixes or suffixes.\n\nRationale: The startswith and endswith methods accept tuples of prefixes or\nsuffixes respectively. Passing a tuple of prefixes or suffixes is more\nefficient and readable than calling the method multiple times.\n\nExample:\nmsg = \"Hello, world!\"\nif msg.startswith(\"Hello\") or msg.startswith(\"Hi\"):\n    print(\"Greetings!\")\n\n\n\nUse instead:\n\n\nmsg = \"Hello, world!\"\nif msg.startswith((\"Hello\", \"Hi\")):\n    print(\"Greetings!\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/FURB166-FURB167-FURB168-FURB169",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom FURB166 (int-on-sliced-str)\n\nDefinition: Checks for uses of int with an explicit base in which a string expression\nis stripped of its leading prefix (i.e., 0b, 0o, or 0x).\n\nRationale: Given an integer string with a prefix (e.g., 0xABC), Python can automatically\ndetermine the base of the integer by the prefix without needing to specify\nit explicitly.\n\n\nInstead of int(num[2:], 16), use int(num, 0), which will automatically\ndeduce the base based on the prefix.\n\nExample:\nnum = \"0xABC\"\n\nif num.startswith(\"0b\"):\n    i = int(num[2:], 2)\nelif num.startswith(\"0o\"):\n    i = int(num[2:], 8)\nelif num.startswith(\"0x\"):\n    i = int(num[2:], 16)\n\nprint(i)\n\n\n\nUse instead:\n\n\nnum = \"0xABC\"\n\ni = int(num, 0)\n\nprint(i)\n\n# Idiom FURB167 (regex-flag-alias)\n\nDefinition: Checks for the use of shorthand aliases for regular expression flags\n(e.g., re.I instead of re.IGNORECASE).\n\nRationale: The regular expression module provides descriptive names for each flag,\nalong with single-letter aliases. Prefer the descriptive names, as they\nare more readable and self-documenting.\n\nExample:\nimport re\n\nif re.match(\"^hello\", \"hello world\", re.I):\n    ...\n\n\n\nUse instead:\n\n\nimport re\n\nif re.match(\"^hello\", \"hello world\", re.IGNORECASE):\n    ...\n\n# Idiom FURB168 (isinstance-type-none)\n\nDefinition: Checks for uses of isinstance that check if an object is of type None.\n\nRationale: There is only ever one instance of None, so it is more efficient and\nreadable to use the is operator to check if an object is None.\n\nExample:\nisinstance(obj, type(None))\n\n\n\nUse instead:\n\n\nobj is None\n\n# Idiom FURB169 (type-none-comparison)\n\nDefinition: Checks for uses of type that compare the type of an object to the type of None.\n\nRationale: There is only ever one instance of None, so it is more efficient and\nreadable to use the is operator to check if an object is None.\n\nExample:\ntype(obj) is type(None)\n\n\n\nUse instead:\n\n\nobj is None\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/F406-F407-F501-F502-F503",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom F406 (undefined-local-with-nested-import-star-usage)\n\nDefinition: Check for the use of wildcard imports outside of the module namespace.\n\nRationale: The use of wildcard imports outside of the module namespace (e.g., within\nfunctions) can lead to confusion, as the import can shadow local variables.\n\n\nThough wildcard imports are discouraged by PEP 8, when necessary, they\nshould be placed in the module namespace (i.e., at the top-level of a\nmodule).\n\nExample:\ndef foo():\n    from math import *\n\n\n\nUse instead:\n\n\nfrom math import *\n\n\ndef foo(): ...\n\n# Idiom F407 (future-feature-not-defined)\n\nDefinition: Checks for __future__ imports that are not defined in the current Python\nversion.\n\nRationale: Importing undefined or unsupported members from the __future__ module is\na SyntaxError.\n\n# Idiom F501 (percent-format-invalid-format)\n\nDefinition: Checks for invalid printf-style format strings.\n\nRationale: Conversion specifiers are required for printf-style format strings. These\nspecifiers must contain a % character followed by a conversion type.\n\nExample:\n\"Hello, %\" % \"world\"\n\n\n\nUse instead:\n\n\n\"Hello, %s\" % \"world\"\n\n# Idiom F502 (percent-format-expected-mapping)\n\nDefinition: Checks for named placeholders in printf-style format strings without\nmapping-type values.\n\nRationale: When using named placeholders in printf-style format strings, the values\nmust be a map type (such as a dictionary). Otherwise, the expression will\nraise a TypeError.\n\nExample:\n\"%(greeting)s, %(name)s\" % (\"Hello\", \"World\")\n\n\n\nUse instead:\n\n\n\"%(greeting)s, %(name)s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n\n\n\nOr:\n\n\n\"%s, %s\" % (\"Hello\", \"World\")\n\n# Idiom F503 (percent-format-expected-sequence)\n\nDefinition: Checks for uses of mapping-type values in printf-style format strings\nwithout named placeholders.\n\nRationale: When using mapping-type values (such as dict) in printf-style format\nstrings, the keys must be named. Otherwise, the expression will raise a\nTypeError.\n\nExample:\n\"%s, %s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n\n\n\nUse instead:\n\n\n\"%(greeting)s, %(name)s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n\n\n\nOr:\n\n\n\"%s, %s\" % (\"Hello\", \"World\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/F722-F811-F821-F822",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom F722 (forward-annotation-syntax-error)\n\nDefinition: Checks for forward annotations that include invalid syntax.\n\nRationale: In Python, type annotations can be quoted as strings literals to enable\nreferences to types that have not yet been defined, known as \"forward\nreferences\".\n\n\nHowever, these quoted annotations must be valid Python expressions. The use\nof invalid syntax in a quoted annotation won't raise a SyntaxError, but\nwill instead raise an error when type checking is performed.\n\nExample:\ndef foo() -> \"/\": ...\n\n# Idiom F811 (redefined-while-unused)\n\nDefinition: Checks for variable definitions that redefine (or \"shadow\") unused\nvariables.\n\nRationale: Redefinitions of unused names are unnecessary and often indicative of a\nmistake.\n\nExample:\nimport foo\nimport bar\nimport foo  # Redefinition of unused `foo` from line 1\n\n\n\nUse instead:\n\n\nimport foo\nimport bar\n\n# Idiom F821 (undefined-name)\n\nDefinition: Checks for uses of undefined names.\n\nRationale: An undefined name is likely to raise NameError at runtime.\n\nExample:\ndef double():\n    return n * 2  # raises `NameError` if `n` is undefined when `double` is called\n\n\n\nUse instead:\n\n\ndef double(n):\n    return n * 2\n\n# Idiom F822 (undefined-export)\n\nDefinition: Checks for undefined names in __all__.\n\nRationale: In Python, the __all__ variable is used to define the names that are\nexported when a module is imported as a wildcard (e.g.,\nfrom foo import *). The names in __all__ must be defined in the module,\nbut are included as strings.\n\n\nIncluding an undefined name in __all__ is likely to raise NameError at\nruntime, when the module is imported.\n\n\nIn preview, this rule will flag undefined names in __init__.py file,\neven if those names implicitly refer to other modules in the package. Users\nthat rely on implicit exports should disable this rule in __init__.py\nfiles via lint.per-file-ignores.\n\nExample:\nfrom foo import bar\n\n\n__all__ = [\"bar\", \"baz\"]  # undefined name `baz` in `__all__`\n\n\n\nUse instead:\n\n\nfrom foo import bar, baz\n\n\n__all__ = [\"bar\", \"baz\"]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PTH206-PTH207-PTH208-PTH210-FLY002",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PTH206 (os-sep-split)\n\nDefinition: Checks for uses of .split(os.sep)\n\nRationale: The pathlib module in the standard library should be used for path\nmanipulation. It provides a high-level API with the functionality\nneeded for common operations on Path objects.\n\nExample:\nIf not all parts of the path are needed, then the name and parent\nattributes of the Path object should be used. Otherwise, the parts\nattribute can be used as shown in the last example.\n\n\nimport os\n\n\"path/to/file_name.txt\".split(os.sep)[-1]\n\n\"path/to/file_name.txt\".split(os.sep)[-2]\n\n# Iterating over the path parts\nif any(part in blocklist for part in \"my/file/path\".split(os.sep)):\n    ...\n\n\n\nUse instead:\n\n\nfrom pathlib import Path\n\nPath(\"path/to/file_name.txt\").name\n\nPath(\"path/to/file_name.txt\").parent.name\n\n# Iterating over the path parts\nif any(part in blocklist for part in Path(\"my/file/path\").parts):\n    ...\n\n# Idiom PTH207 (glob)\n\nDefinition: Checks for the use of glob.glob() and glob.iglob().\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os and glob.\n\n\nWhen possible, using Path object methods such as Path.glob() can\nimprove readability over their low-level counterparts (e.g.,\nglob.glob()).\n\n\nNote that glob.glob() and Path.glob() are not exact equivalents:\n\n\n\n\n\n\nglob-module functions\nPath.glob()\n\n\n\n\nHidden files\nHidden files are excluded by default. On Python 3.11+, the include_hidden keyword can be used to include hidden directories.\nIncludes hidden files by default.\n\n\nEagerness\nglob.iglob() returns a lazy iterator. Under the hood, glob.glob() simply converts the iterator to a list.\nPath.glob() returns a lazy iterator.\n\n\nWorking directory\nglob.glob() and glob.iglob() take a root_dir keyword to set the current working directory.\nPath.rglob() can be used to return the relative path.\n\n\nGlobstar (**)\nThe recursive flag must be set to True for the ** pattern to match any files and zero or more directories, subdirectories, and symbolic links.\nThe ** pattern in Path.glob() means \"this directory and all subdirectories, recursively\". In other words, it enables recursive globbing.\n\nExample:\nimport glob\nimport os\n\nglob.glob(os.path.join(\"my_path\", \"requirements*.txt\"))\n\n\n\nUse instead:\n\n\nfrom pathlib import Path\n\nPath(\"my_path\").glob(\"requirements*.txt\")\n\n# Idiom PTH208 (os-listdir)\n\nDefinition: Checks for uses of os.listdir.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os. When possible, using pathlib's\nPath.iterdir() can improve readability over os.listdir().\n\nExample:\np = \".\"\nfor d in os.listdir(p):\n    ...\n\nif os.listdir(p):\n    ...\n\nif \"file\" in os.listdir(p):\n    ...\n\n\n\nUse instead:\n\n\np = Path(\".\")\nfor d in p.iterdir():\n    ...\n\nif any(p.iterdir()):\n    ...\n\nif (p / \"file\").exists():\n    ...\n\n# Idiom PTH210 (invalid-pathlib-with-suffix)\n\nDefinition: Checks for pathlib.Path.with_suffix() calls where\nthe given suffix does not have a leading dot\nor the given suffix is a single dot \".\".\n\nRationale: Path.with_suffix() will raise an error at runtime\nif the given suffix is not prefixed with a dot\nor it is a single dot \".\".\n\nExample:\npath.with_suffix(\"py\")\n\n\n\nUse instead:\n\n\npath.with_suffix(\".py\")\n\n# Idiom FLY002 (static-join-to-f-string)\n\nDefinition: Checks for str.join calls that can be replaced with f-strings.\n\nRationale: f-strings are more readable and generally preferred over str.join calls.\n\nExample:\n\" \".join((foo, bar))\n\n\n\nUse instead:\n\n\nf\"{foo} {bar}\"\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/S106-S107-S108-S110-S112",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom S106 (hardcoded-password-func-arg)\n\nDefinition: Checks for potential uses of hardcoded passwords in function calls.\n\nRationale: Including a hardcoded password in source code is a security risk, as an\nattacker could discover the password and use it to gain unauthorized\naccess.\n\n\nInstead, store passwords and other secrets in configuration files,\nenvironment variables, or other sources that are excluded from version\ncontrol.\n\nExample:\nconnect_to_server(password=\"hunter2\")\n\n\n\nUse instead:\n\n\nimport os\n\nconnect_to_server(password=os.environ[\"PASSWORD\"])\n\n# Idiom S107 (hardcoded-password-default)\n\nDefinition: Checks for potential uses of hardcoded passwords in function argument\ndefaults.\n\nRationale: Including a hardcoded password in source code is a security risk, as an\nattacker could discover the password and use it to gain unauthorized\naccess.\n\n\nInstead, store passwords and other secrets in configuration files,\nenvironment variables, or other sources that are excluded from version\ncontrol.\n\nExample:\ndef connect_to_server(password=\"hunter2\"): ...\n\n\n\nUse instead:\n\n\nimport os\n\n\ndef connect_to_server(password=os.environ[\"PASSWORD\"]): ...\n\n# Idiom S108 (hardcoded-temp-file)\n\nDefinition: Checks for the use of hardcoded temporary file or directory paths.\n\nRationale: The use of hardcoded paths for temporary files can be insecure. If an\nattacker discovers the location of a hardcoded path, they can replace the\ncontents of the file or directory with a malicious payload.\n\n\nOther programs may also read or write contents to these hardcoded paths,\ncausing unexpected behavior.\n\nExample:\nwith open(\"/tmp/foo.txt\", \"w\") as file:\n    ...\n\n\n\nUse instead:\n\n\nimport tempfile\n\nwith tempfile.NamedTemporaryFile() as file:\n    ...\n\n# Idiom S110 (try-except-pass)\n\nDefinition: Checks for uses of the try-except-pass pattern.\n\nRationale: The try-except-pass pattern suppresses all exceptions. Suppressing\nexceptions may hide errors that could otherwise reveal unexpected behavior,\nsecurity vulnerabilities, or malicious activity. Instead, consider logging\nthe exception.\n\nExample:\ntry:\n    ...\nexcept Exception:\n    pass\n\n\n\nUse instead:\n\n\nimport logging\n\ntry:\n    ...\nexcept Exception as exc:\n    logging.exception(\"Exception occurred\")\n\n# Idiom S112 (try-except-continue)\n\nDefinition: Checks for uses of the try-except-continue pattern.\n\nRationale: The try-except-continue pattern suppresses all exceptions.\nSuppressing exceptions may hide errors that could otherwise reveal\nunexpected behavior, security vulnerabilities, or malicious activity.\nInstead, consider logging the exception.\n\nExample:\nimport logging\n\nwhile predicate:\n    try:\n        ...\n    except Exception:\n        continue\n\n\n\nUse instead:\n\n\nimport logging\n\nwhile predicate:\n    try:\n        ...\n    except Exception as exc:\n        logging.exception(\"Error occurred\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/S113-S201-S202-S301-S302",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom S113 (request-without-timeout)\n\nDefinition: Checks for uses of the Python requests or httpx module that omit the\ntimeout parameter.\n\nRationale: The timeout parameter is used to set the maximum time to wait for a\nresponse from the server. By omitting the timeout parameter, the program\nmay hang indefinitely while awaiting a response.\n\nExample:\nimport requests\n\nrequests.get(\"https://www.example.com/\")\n\n\n\nUse instead:\n\n\nimport requests\n\nrequests.get(\"https://www.example.com/\", timeout=10)\n\n# Idiom S201 (flask-debug-true)\n\nDefinition: Checks for uses of debug=True in Flask.\n\nRationale: Enabling debug mode shows an interactive debugger in the browser if an\nerror occurs, and allows running arbitrary Python code from the browser.\nThis could leak sensitive information, or allow an attacker to run\narbitrary code.\n\nExample:\nimport flask\n\napp = Flask()\n\napp.run(debug=True)\n\n\n\nUse instead:\n\n\nimport flask\n\napp = Flask()\n\napp.run(debug=os.environ[\"ENV\"] == \"dev\")\n\n# Idiom S202 (tarfile-unsafe-members)\n\nDefinition: Checks for uses of tarfile.extractall.\n\nRationale: Extracting archives from untrusted sources without prior inspection is\na security risk, as maliciously crafted archives may contain files that\nwill be written outside of the target directory. For example, the archive\ncould include files with absolute paths (e.g., /etc/passwd), or relative\npaths with parent directory references (e.g., ../etc/passwd).\n\n\nOn Python 3.12 and later, use filter='data' to prevent the most dangerous\nsecurity issues (see: PEP 706). On earlier versions, set the members\nargument to a trusted subset of the archive's members.\n\nExample:\nimport tarfile\nimport tempfile\n\ntar = tarfile.open(filename)\ntar.extractall(path=tempfile.mkdtemp())\ntar.close()\n\n# Idiom S301 (suspicious-pickle-usage)\n\nDefinition: Checks for calls to pickle functions or modules that wrap them.\n\nRationale: Deserializing untrusted data with pickle and other deserialization\nmodules is insecure as it can allow for the creation of arbitrary objects,\nwhich can then be used to achieve arbitrary code execution and otherwise\nunexpected behavior.\n\n\nAvoid deserializing untrusted data with pickle and other deserialization\nmodules. Instead, consider safer formats, such as JSON.\n\n\nIf you must deserialize untrusted data with pickle, consider signing the\ndata with a secret key and verifying the signature before deserializing the\npayload, This will prevent an attacker from injecting arbitrary objects\ninto the serialized data.\n\n\nIn preview, this rule will also flag references to pickle functions.\n\nExample:\nimport pickle\n\nwith open(\"foo.pickle\", \"rb\") as file:\n    foo = pickle.load(file)\n\n\n\nUse instead:\n\n\nimport json\n\nwith open(\"foo.json\", \"rb\") as file:\n    foo = json.load(file)\n\n# Idiom S302 (suspicious-marshal-usage)\n\nDefinition: Checks for calls to marshal functions.\n\nRationale: Deserializing untrusted data with marshal is insecure, as it can allow for\nthe creation of arbitrary objects, which can then be used to achieve\narbitrary code execution and otherwise unexpected behavior.\n\n\nAvoid deserializing untrusted data with marshal. Instead, consider safer\nformats, such as JSON.\n\n\nIf you must deserialize untrusted data with marshal, consider signing the\ndata with a secret key and verifying the signature before deserializing the\npayload. This will prevent an attacker from injecting arbitrary objects\ninto the serialized data.\n\n\nIn preview, this rule will also flag references to marshal functions.\n\nExample:\nimport marshal\n\nwith open(\"foo.marshal\", \"rb\") as file:\n    foo = marshal.load(file)\n\n\n\nUse instead:\n\n\nimport json\n\nwith open(\"foo.json\", \"rb\") as file:\n    foo = json.load(file)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLW0642-PLW0711-PLW1501-PLW1507-PLW1508",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLW0642 (self-or-cls-assignment)\n\nDefinition: Checks for assignment of self and cls in instance and class methods respectively.\n\n\nThis check also applies to __new__ even though this is technically\na static method.\n\nRationale: The identifiers self and cls are conventional in Python for the first parameter of instance\nmethods and class methods, respectively. Assigning new values to these variables can be\nconfusing for others reading your code; using a different variable name can lead to clearer\ncode.\n\nExample:\nclass Version:\n    def add(self, other):\n        self = self + other\n        return self\n\n    @classmethod\n    def superclass(cls):\n        cls = cls.__mro__[-1]\n        return cls\n\n\n\nUse instead:\n\n\nclass Version:\n    def add(self, other):\n        new_version = self + other\n        return new_version\n\n    @classmethod\n    def superclass(cls):\n        supercls = cls.__mro__[-1]\n        return supercls\n\n# Idiom PLW0711 (binary-op-exception)\n\nDefinition: Checks for except clauses that attempt to catch multiple\nexceptions with a binary operation (and or or).\n\nRationale: A binary operation will not catch multiple exceptions. Instead, the binary\noperation will be evaluated first, and the result of that operation will\nbe caught (for an or operation, this is typically the first exception in\nthe list). This is almost never the desired behavior.\n\nExample:\ntry:\n    pass\nexcept A or B:\n    pass\n\n\n\nUse instead:\n\n\ntry:\n    pass\nexcept (A, B):\n    pass\n\n# Idiom PLW1501 (bad-open-mode)\n\nDefinition: Check for an invalid mode argument in open calls.\n\nRationale: The open function accepts a mode argument that specifies how the file\nshould be opened (e.g., read-only, write-only, append-only, etc.).\n\n\nPython supports a variety of open modes: r, w, a, and x, to control\nreading, writing, appending, and creating, respectively, along with\nb (binary mode), + (read and write), and U (universal newlines),\nthe latter of which is only valid alongside r. This rule detects both\ninvalid combinations of modes and invalid characters in the mode string\nitself.\n\nExample:\nwith open(\"file\", \"rwx\") as f:\n    return f.read()\n\n\n\nUse instead:\n\n\nwith open(\"file\", \"r\") as f:\n    return f.read()\n\n# Idiom PLW1507 (shallow-copy-environ)\n\nDefinition: Check for shallow os.environ copies.\n\nRationale: os.environ is not a dict object, but rather, a proxy object. As such, mutating a shallow\ncopy of os.environ will also mutate the original object.\n\n\nSee BPO 15373 for more information.\n\nExample:\nimport copy\nimport os\n\nenv = copy.copy(os.environ)\n\n\n\nUse instead:\n\n\nimport os\n\nenv = os.environ.copy()\n\n# Idiom PLW1508 (invalid-envvar-default)\n\nDefinition: Checks for os.getenv calls with invalid default values.\n\nRationale: If an environment variable is set, os.getenv will return its value as\na string. If the environment variable is not set, os.getenv will\nreturn None, or the default value if one is provided.\n\n\nIf the default value is not a string or None, then it will be\ninconsistent with the return type of os.getenv, which can lead to\nconfusing behavior.\n\nExample:\nimport os\n\nint(os.getenv(\"FOO\", 1))\n\n\n\nUse instead:\n\n\nimport os\n\nint(os.getenv(\"FOO\", \"1\"))\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/SIM113-SIM114-SIM115-SIM116-SIM117",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom SIM113 (enumerate-for-loop)\n\nDefinition: Checks for for loops with explicit loop-index variables that can be replaced\nwith enumerate().\n\nRationale: When iterating over a sequence, it's often desirable to keep track of the\nindex of each element alongside the element itself. Prefer the enumerate\nbuiltin over manually incrementing a counter variable within the loop, as\nenumerate is more concise and idiomatic.\n\nExample:\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor fruit in fruits:\n    print(f\"{i + 1}. {fruit}\")\n    i += 1\n\n\n\nUse instead:\n\n\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor i, fruit in enumerate(fruits):\n    print(f\"{i + 1}. {fruit}\")\n\n# Idiom SIM114 (if-with-same-arms)\n\nDefinition: Checks for if branches with identical arm bodies.\n\nRationale: If multiple arms of an if statement have the same body, using or\nbetter signals the intent of the statement.\n\nExample:\nif x == 1:\n    print(\"Hello\")\nelif x == 2:\n    print(\"Hello\")\n\n\n\nUse instead:\n\n\nif x == 1 or x == 2:\n    print(\"Hello\")\n\n# Idiom SIM115 (open-file-with-context-handler)\n\nDefinition: Checks for cases where files are opened (e.g., using the builtin open() function)\nwithout using a context manager.\n\nRationale: If a file is opened without a context manager, it is not guaranteed that\nthe file will be closed (e.g., if an exception is raised), which can cause\nresource leaks. The rule detects a wide array of IO calls where context managers\ncould be used, such as open, pathlib.Path(...).open(), tempfile.TemporaryFile()\nortarfile.TarFile(...).gzopen().\n\nExample:\nfile = open(\"foo.txt\")\n...\nfile.close()\n\n\n\nUse instead:\n\n\nwith open(\"foo.txt\") as file:\n    ...\n\n# Idiom SIM116 (if-else-block-instead-of-dict-lookup)\n\nDefinition: Checks for three or more consecutive if-statements with direct returns\n\nRationale: These can be simplified by using a dictionary\n\nExample:\nif x == 1:\n    return \"Hello\"\nelif x == 2:\n    return \"Goodbye\"\nelse:\n    return \"Goodnight\"\n\n\n\nUse instead:\n\n\nreturn {1: \"Hello\", 2: \"Goodbye\"}.get(x, \"Goodnight\")\n\n# Idiom SIM117 (multiple-with-statements)\n\nDefinition: Checks for the unnecessary nesting of multiple consecutive context\nmanagers.\n\nRationale: In Python 3, a single with block can include multiple context\nmanagers.\n\n\nCombining multiple context managers into a single with statement\nwill minimize the indentation depth of the code, making it more\nreadable.\n\n\nThe following context managers are exempt when used as standalone\nstatements:\n\n\n\nanyio.{CancelScope, fail_after, move_on_after}\nasyncio.{timeout, timeout_at}\ntrio.{fail_after, fail_at, move_on_after, move_on_at}\n\nExample:\nwith A() as a:\n    with B() as b:\n        pass\n\n\n\nUse instead:\n\n\nwith A() as a, B() as b:\n    pass\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/ARG001-ARG002-ARG003-ARG004-ARG005",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom ARG001 (unused-function-argument)\n\nDefinition: Checks for the presence of unused arguments in function definitions.\n\nRationale: An argument that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\n\nIf a variable is intentionally defined-but-not-used, it should be\nprefixed with an underscore, or some other value that adheres to the\nlint.dummy-variable-rgx pattern.\n\nExample:\ndef foo(bar, baz):\n    return bar * 2\n\n\n\nUse instead:\n\n\ndef foo(bar):\n    return bar * 2\n\n# Idiom ARG002 (unused-method-argument)\n\nDefinition: Checks for the presence of unused arguments in instance method definitions.\n\nRationale: An argument that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\n\nIf a variable is intentionally defined-but-not-used, it should be\nprefixed with an underscore, or some other value that adheres to the\nlint.dummy-variable-rgx pattern.\n\nExample:\nclass Class:\n    def foo(self, arg1, arg2):\n        print(arg1)\n\n\n\nUse instead:\n\n\nclass Class:\n    def foo(self, arg1):\n        print(arg1)\n\n# Idiom ARG003 (unused-class-method-argument)\n\nDefinition: Checks for the presence of unused arguments in class method definitions.\n\nRationale: An argument that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\n\nIf a variable is intentionally defined-but-not-used, it should be\nprefixed with an underscore, or some other value that adheres to the\nlint.dummy-variable-rgx pattern.\n\nExample:\nclass Class:\n    @classmethod\n    def foo(cls, arg1, arg2):\n        print(arg1)\n\n\n\nUse instead:\n\n\nclass Class:\n    @classmethod\n    def foo(cls, arg1):\n        print(arg1)\n\n# Idiom ARG004 (unused-static-method-argument)\n\nDefinition: Checks for the presence of unused arguments in static method definitions.\n\nRationale: An argument that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\n\nIf a variable is intentionally defined-but-not-used, it should be\nprefixed with an underscore, or some other value that adheres to the\nlint.dummy-variable-rgx pattern.\n\nExample:\nclass Class:\n    @staticmethod\n    def foo(arg1, arg2):\n        print(arg1)\n\n\n\nUse instead:\n\n\nclass Class:\n    @staticmethod\n    def foo(arg1):\n        print(arg1)\n\n# Idiom ARG005 (unused-lambda-argument)\n\nDefinition: Checks for the presence of unused arguments in lambda expression\ndefinitions.\n\nRationale: An argument that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\n\nIf a variable is intentionally defined-but-not-used, it should be\nprefixed with an underscore, or some other value that adheres to the\nlint.dummy-variable-rgx pattern.\n\nExample:\nmy_list = [1, 2, 3, 4, 5]\nsquares = map(lambda x, y: x**2, my_list)\n\n\n\nUse instead:\n\n\nmy_list = [1, 2, 3, 4, 5]\nsquares = map(lambda x: x**2, my_list)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/RUF007-RUF008-RUF009-RUF010-RUF012",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom RUF007 (zip-instead-of-pairwise)\n\nDefinition: Checks for use of zip() to iterate over successive pairs of elements.\n\nRationale: When iterating over successive pairs of elements, prefer\nitertools.pairwise() over zip().\n\n\nitertools.pairwise() is more readable and conveys the intent of the code\nmore clearly.\n\nExample:\nletters = \"ABCD\"\nzip(letters, letters[1:])  # (\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\")\n\n\n\nUse instead:\n\n\nfrom itertools import pairwise\n\nletters = \"ABCD\"\npairwise(letters)  # (\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\")\n\n# Idiom RUF008 (mutable-dataclass-default)\n\nDefinition: Checks for mutable default values in dataclass attributes.\n\nRationale: Mutable default values share state across all instances of the dataclass.\nThis can lead to bugs when the attributes are changed in one instance, as\nthose changes will unexpectedly affect all other instances.\n\n\nInstead of sharing mutable defaults, use the field(default_factory=...)\npattern.\n\n\nIf the default value is intended to be mutable, it must be annotated with\ntyping.ClassVar; otherwise, a ValueError will be raised.\n\nExample:\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass A:\n    # A list without a `default_factory` or `ClassVar` annotation\n    # will raise a `ValueError`.\n    mutable_default: list[int] = []\n\n\n\nUse instead:\n\n\nfrom dataclasses import dataclass, field\n\n\n@dataclass\nclass A:\n    mutable_default: list[int] = field(default_factory=list)\n\n\n\nOr:\n\n\nfrom dataclasses import dataclass\nfrom typing import ClassVar\n\n\n@dataclass\nclass A:\n    mutable_default: ClassVar[list[int]] = []\n\n# Idiom RUF009 (function-call-in-dataclass-default-argument)\n\nDefinition: Checks for function calls in dataclass attribute defaults.\n\nRationale: Function calls are only performed once, at definition time. The returned\nvalue is then reused by all instances of the dataclass. This can lead to\nunexpected behavior when the function call returns a mutable object, as\nchanges to the object will be shared across all instances.\n\n\nIf a field needs to be initialized with a mutable object, use the\nfield(default_factory=...) pattern.\n\n\nAttributes whose default arguments are NewType calls\nwhere the original type is immutable are ignored.\n\nExample:\nfrom dataclasses import dataclass\n\n\ndef simple_list() -> list[int]:\n    return [1, 2, 3, 4]\n\n\n@dataclass\nclass A:\n    mutable_default: list[int] = simple_list()\n\n\n\nUse instead:\n\n\nfrom dataclasses import dataclass, field\n\n\ndef creating_list() -> list[int]:\n    return [1, 2, 3, 4]\n\n\n@dataclass\nclass A:\n    mutable_default: list[int] = field(default_factory=creating_list)\n\n# Idiom RUF010 (explicit-f-string-type-conversion)\n\nDefinition: Checks for uses of str(), repr(), and ascii() as explicit type\nconversions within f-strings.\n\nRationale: f-strings support dedicated conversion flags for these types, which are\nmore succinct and idiomatic.\n\n\nNote that, in many cases, calling str() within an f-string is\nunnecessary and can be removed entirely, as the value will be converted\nto a string automatically, the notable exception being for classes that\nimplement a custom __format__ method.\n\nExample:\na = \"some string\"\nf\"{repr(a)}\"\n\n\n\nUse instead:\n\n\na = \"some string\"\nf\"{a!r}\"\n\n# Idiom RUF012 (mutable-class-default)\n\nDefinition: Checks for mutable default values in class attributes.\n\nRationale: Mutable default values share state across all instances of the class,\nwhile not being obvious. This can lead to bugs when the attributes are\nchanged in one instance, as those changes will unexpectedly affect all\nother instances.\n\n\nGenerally speaking, you probably want to avoid having mutable default\nvalues in the class body at all; instead, these variables should usually\nbe initialized in __init__. However, other possible fixes for the issue\ncan include:\n\n\n\nExplicitly annotating the variable with typing.ClassVar to\n    indicate that it is intended to be shared across all instances.\nUsing an immutable data type (e.g. a tuple instead of a list)\n    for the default value.\n\nExample:\nclass A:\n    variable_1: list[int] = []\n    variable_2: set[int] = set()\n    variable_3: dict[str, int] = {}\n\n\n\nUse instead:\n\n\nclass A:\n    def __init__(self) -> None:\n        self.variable_1: list[int] = []\n        self.variable_2: set[int] = set()\n        self.variable_3: dict[str, int] = {}\n\n\n\nOr:\n\n\nfrom typing import ClassVar\n\n\nclass A:\n    variable_1: ClassVar[list[int]] = []\n    variable_2: ClassVar[set[int]] = set()\n    variable_3: ClassVar[dict[str, int]] = {}\n\n\n\nOr:\n\n\nclass A:\n    variable_1: list[int] | None = None\n    variable_2: set[int] | None = None\n    variable_3: dict[str, int] | None = None\n\n\n\nOr:\n\n\nfrom collections.abc import Sequence, Mapping, Set as AbstractSet\nfrom types import MappingProxyType\n\n\nclass A:\n    variable_1: Sequence[int] = ()\n    variable_2: AbstractSet[int] = frozenset()\n    variable_3: Mapping[str, int] = MappingProxyType({})\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/DTZ001-DTZ002-DTZ003-DTZ004-DTZ005",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom DTZ001 (call-datetime-without-tzinfo)\n\nDefinition: Checks for datetime instantiations that do not specify a timezone.\n\nRationale: datetime objects are \"naive\" by default, in that they do not include\ntimezone information. \"Naive\" objects are easy to understand, but ignore\nsome aspects of reality, which can lead to subtle bugs. Timezone-aware\ndatetime objects are preferred, as they represent a specific moment in\ntime, unlike \"naive\" objects.\n\n\nBy providing a non-None value for tzinfo, a datetime can be made\ntimezone-aware.\n\nExample:\nimport datetime\n\ndatetime.datetime(2000, 1, 1, 0, 0, 0)\n\n\n\nUse instead:\n\n\nimport datetime\n\ndatetime.datetime(2000, 1, 1, 0, 0, 0, tzinfo=datetime.timezone.utc)\n\n\n\nOr, on Python 3.11 and later:\n\n\nimport datetime\n\ndatetime.datetime(2000, 1, 1, 0, 0, 0, tzinfo=datetime.UTC)\n\n# Idiom DTZ002 (call-datetime-today)\n\nDefinition: Checks for usage of datetime.datetime.today().\n\nRationale: datetime objects are \"naive\" by default, in that they do not include\ntimezone information. \"Naive\" objects are easy to understand, but ignore\nsome aspects of reality, which can lead to subtle bugs. Timezone-aware\ndatetime objects are preferred, as they represent a specific moment in\ntime, unlike \"naive\" objects.\n\n\ndatetime.datetime.today() creates a \"naive\" object; instead, use\ndatetime.datetime.now(tz=...) to create a timezone-aware object.\n\nExample:\nimport datetime\n\ndatetime.datetime.today()\n\n\n\nUse instead:\n\n\nimport datetime\n\ndatetime.datetime.now(tz=datetime.timezone.utc)\n\n\n\nOr, for Python 3.11 and later:\n\n\nimport datetime\n\ndatetime.datetime.now(tz=datetime.UTC)\n\n# Idiom DTZ003 (call-datetime-utcnow)\n\nDefinition: Checks for usage of datetime.datetime.utcnow().\n\nRationale: Python datetime objects can be naive or timezone-aware. While an aware\nobject represents a specific moment in time, a naive object does not\ncontain enough information to unambiguously locate itself relative to other\ndatetime objects. Since this can lead to errors, it is recommended to\nalways use timezone-aware objects.\n\n\ndatetime.datetime.utcnow() returns a naive datetime object; instead, use\ndatetime.datetime.now(tz=...) to create a timezone-aware object.\n\nExample:\nimport datetime\n\ndatetime.datetime.utcnow()\n\n\n\nUse instead:\n\n\nimport datetime\n\ndatetime.datetime.now(tz=datetime.timezone.utc)\n\n\n\nOr, for Python 3.11 and later:\n\n\nimport datetime\n\ndatetime.datetime.now(tz=datetime.UTC)\n\n# Idiom DTZ004 (call-datetime-utcfromtimestamp)\n\nDefinition: Checks for usage of datetime.datetime.utcfromtimestamp().\n\nRationale: Python datetime objects can be naive or timezone-aware. While an aware\nobject represents a specific moment in time, a naive object does not\ncontain enough information to unambiguously locate itself relative to other\ndatetime objects. Since this can lead to errors, it is recommended to\nalways use timezone-aware objects.\n\n\ndatetime.datetime.utcfromtimestamp() returns a naive datetime\nobject; instead, use datetime.datetime.fromtimestamp(ts, tz=...)\nto create a timezone-aware object.\n\nExample:\nimport datetime\n\ndatetime.datetime.utcfromtimestamp(946684800)\n\n\n\nUse instead:\n\n\nimport datetime\n\ndatetime.datetime.fromtimestamp(946684800, tz=datetime.timezone.utc)\n\n\n\nOr, on Python 3.11 and later:\n\n\nimport datetime\n\ndatetime.datetime.fromtimestamp(946684800, tz=datetime.UTC)\n\n# Idiom DTZ005 (call-datetime-now-without-tzinfo)\n\nDefinition: Checks for usages of datetime.datetime.now() that do not specify a timezone.\n\nRationale: Python datetime objects can be naive or timezone-aware. While an aware\nobject represents a specific moment in time, a naive object does not\ncontain enough information to unambiguously locate itself relative to other\ndatetime objects. Since this can lead to errors, it is recommended to\nalways use timezone-aware objects.\n\n\ndatetime.datetime.now() or datetime.datetime.now(tz=None) returns a naive\ndatetime object. Instead, use datetime.datetime.now(tz=<timezone>) to create\na timezone-aware object.\n\nExample:\nimport datetime\n\ndatetime.datetime.now()\n\n\n\nUse instead:\n\n\nimport datetime\n\ndatetime.datetime.now(tz=datetime.timezone.utc)\n\n\n\nOr, for Python 3.11 and later:\n\n\nimport datetime\n\ndatetime.datetime.now(tz=datetime.UTC)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/TD005-TD006-TD007",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom TD005 (missing-todo-description)\n\nDefinition: Checks that a \"TODO\" tag contains a description of the issue following the\ntag itself.\n\nRationale: TODO comments should include a description of the issue to provide context\nfor future readers.\n\nExample:\n# TODO(charlie)\n\n\n\nUse instead:\n\n\n# TODO(charlie): fix some issue\n\n# Idiom TD006 (invalid-todo-capitalization)\n\nDefinition: Checks that a \"TODO\" tag is properly capitalized (i.e., that the tag is\nuppercase).\n\nRationale: Capitalizing the \"TODO\" in a TODO comment is a convention that makes it\neasier for future readers to identify TODOs.\n\nExample:\n# todo(charlie): capitalize this\n\n\n\nUse instead:\n\n\n# TODO(charlie): this is capitalized\n\n# Idiom TD007 (missing-space-after-todo-colon)\n\nDefinition: Checks that the colon after a \"TODO\" tag is followed by a space.\n\nRationale: \"TODO\" tags are typically followed by a parenthesized author name, a colon,\na space, and a description of the issue, in that order.\n\n\nDeviating from this pattern can lead to inconsistent and non-idiomatic\ncomments.\n\nExample:\n# TODO(charlie):fix this\n\n\n\nUse instead:\n\n\n# TODO(charlie): fix this\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/EXE001-EXE002-EXE003-EXE004-EXE005",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom EXE001 (shebang-not-executable)\n\nDefinition: Checks for a shebang directive in a file that is not executable.\n\nRationale: In Python, a shebang (also known as a hashbang) is the first line of a\nscript, which specifies the interpreter that should be used to run the\nscript.\n\n\nThe presence of a shebang suggests that a file is intended to be\nexecutable. If a file contains a shebang but is not executable, then the\nshebang is misleading, or the file is missing the executable bit.\n\n\nIf the file is meant to be executable, add the executable bit to the file\n(e.g., chmod +x __main__.py or git update-index --chmod=+x __main__.py).\n\n\nOtherwise, remove the shebang.\n\n\nA file is considered executable if it has the executable bit set (i.e., its\npermissions mode intersects with 0o111). As such, this rule is only\navailable on Unix-like systems, and is not enforced on Windows or WSL.\n\nExample:\n#!/usr/bin/env python\n\n# Idiom EXE002 (shebang-missing-executable-file)\n\nDefinition: Checks for executable .py files that do not have a shebang.\n\nRationale: In Python, a shebang (also known as a hashbang) is the first line of a\nscript, which specifies the interpreter that should be used to run the\nscript.\n\n\nIf a .py file is executable, but does not have a shebang, it may be run\nwith the wrong interpreter, or fail to run at all.\n\n\nIf the file is meant to be executable, add a shebang, as in:\n\n\n#!/usr/bin/env python\n\n\n\nOtherwise, remove the executable bit from the file\n(e.g., chmod -x __main__.py or git update-index --chmod=-x __main__.py).\n\n\nA file is considered executable if it has the executable bit set (i.e., its\npermissions mode intersects with 0o111). As such, this rule is only\navailable on Unix-like systems, and is not enforced on Windows or WSL.\n\n# Idiom EXE003 (shebang-missing-python)\n\nDefinition: Checks for a shebang directive in .py files that does not contain python,\npytest, or uv run.\n\nRationale: In Python, a shebang (also known as a hashbang) is the first line of a\nscript, which specifies the command that should be used to run the\nscript.\n\n\nFor Python scripts, if the shebang does not include a command that explicitly\nor implicitly specifies an interpreter, then the file will be executed with\nthe default interpreter, which is likely a mistake.\n\nExample:\n#!/usr/bin/env bash\n\n\n\nUse instead:\n\n\n#!/usr/bin/env python3\n\n# Idiom EXE004 (shebang-leading-whitespace)\n\nDefinition: Checks for whitespace before a shebang directive.\n\nRationale: In Python, a shebang (also known as a hashbang) is the first line of a\nscript, which specifies the interpreter that should be used to run the\nscript.\n\n\nThe shebang's #! prefix must be the first two characters of a file. The\npresence of whitespace before the shebang will cause the shebang to be\nignored, which is likely a mistake.\n\nExample:\n #!/usr/bin/env python3\n\n\n\nUse instead:\n\n\n#!/usr/bin/env python3\n\n# Idiom EXE005 (shebang-not-first-line)\n\nDefinition: Checks for a shebang directive that is not at the beginning of the file.\n\nRationale: In Python, a shebang (also known as a hashbang) is the first line of a\nscript, which specifies the interpreter that should be used to run the\nscript.\n\n\nThe shebang's #! prefix must be the first two characters of a file. If\nthe shebang is not at the beginning of the file, it will be ignored, which\nis likely a mistake.\n\nExample:\nfoo = 1\n#!/usr/bin/env python3\n\n\n\nUse instead:\n\n\n#!/usr/bin/env python3\nfoo = 1\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/B017-B018-B019-B020-B021",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom B017 (assert-raises-exception)\n\nDefinition: Checks for assertRaises and pytest.raises context managers that catch\nException or BaseException.\n\nRationale: These forms catch every Exception, which can lead to tests passing even\nif, e.g., the code under consideration raises a SyntaxError or\nIndentationError.\n\n\nEither assert for a more specific exception (builtin or custom), or use\nassertRaisesRegex or pytest.raises(..., match=<REGEX>) respectively.\n\nExample:\nself.assertRaises(Exception, foo)\n\n\n\nUse instead:\n\n\nself.assertRaises(SomeSpecificException, foo)\n\n# Idiom B018 (useless-expression)\n\nDefinition: Checks for useless expressions.\n\nRationale: Useless expressions have no effect on the program, and are often included\nby mistake. Assign a useless expression to a variable, or remove it\nentirely.\n\nExample:\n1 + 1\n\n\n\nUse instead:\n\n\nfoo = 1 + 1\n\n# Idiom B019 (cached-instance-method)\n\nDefinition: Checks for uses of the functools.lru_cache and functools.cache\ndecorators on methods.\n\nRationale: Using the functools.lru_cache and functools.cache decorators on methods\ncan lead to memory leaks, as the global cache will retain a reference to\nthe instance, preventing it from being garbage collected.\n\n\nInstead, refactor the method to depend only on its arguments and not on the\ninstance of the class, or use the @lru_cache decorator on a function\noutside of the class.\n\n\nThis rule ignores instance methods on enumeration classes, as enum members\nare singletons.\n\nExample:\nfrom functools import lru_cache\n\n\ndef square(x: int) -> int:\n    return x * x\n\n\nclass Number:\n    value: int\n\n    @lru_cache\n    def squared(self):\n        return square(self.value)\n\n\n\nUse instead:\n\n\nfrom functools import lru_cache\n\n\n@lru_cache\ndef square(x: int) -> int:\n    return x * x\n\n\nclass Number:\n    value: int\n\n    def squared(self):\n        return square(self.value)\n\n# Idiom B020 (loop-variable-overrides-iterator)\n\nDefinition: Checks for loop control variables that override the loop iterable.\n\nRationale: Loop control variables should not override the loop iterable, as this can\nlead to confusing behavior.\n\n\nInstead, use a distinct variable name for any loop control variables.\n\nExample:\nitems = [1, 2, 3]\n\nfor items in items:\n    print(items)\n\n\n\nUse instead:\n\n\nitems = [1, 2, 3]\n\nfor item in items:\n    print(item)\n\n# Idiom B021 (f-string-docstring)\n\nDefinition: Checks for docstrings that are written via f-strings.\n\nRationale: Python will interpret the f-string as a joined string, rather than as a\ndocstring. As such, the \"docstring\" will not be accessible via the\n__doc__ attribute, nor will it be picked up by any automated\ndocumentation tooling.\n\nExample:\ndef foo():\n    f\"\"\"Not a docstring.\"\"\"\n\n\n\nUse instead:\n\n\ndef foo():\n    \"\"\"A docstring.\"\"\"\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/C405-C406-C408-C409-C410",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom C405 (unnecessary-literal-set)\n\nDefinition: Checks for set() calls that take unnecessary list or tuple literals\nas arguments.\n\nRationale: It's unnecessary to use a list or tuple literal within a call to set().\nInstead, the expression can be rewritten as a set literal.\n\nExample:\nset([1, 2])\nset((1, 2))\nset([])\n\n\n\nUse instead:\n\n\n{1, 2}\n{1, 2}\nset()\n\n# Idiom C406 (unnecessary-literal-dict)\n\nDefinition: Checks for unnecessary list or tuple literals.\n\nRationale: It's unnecessary to use a list or tuple literal within a call to dict().\nIt can be rewritten as a dict literal ({}).\n\nExample:\ndict([(1, 2), (3, 4)])\ndict(((1, 2), (3, 4)))\ndict([])\n\n\n\nUse instead:\n\n\n{1: 2, 3: 4}\n{1: 2, 3: 4}\n{}\n\n# Idiom C408 (unnecessary-collection-call)\n\nDefinition: Checks for unnecessary dict(), list() or tuple() calls that can be\nrewritten as empty literals.\n\nRationale: It's unnecessary to call, e.g., dict() as opposed to using an empty\nliteral ({}). The former is slower because the name dict must be\nlooked up in the global scope in case it has been rebound.\n\nExample:\ndict()\ndict(a=1, b=2)\nlist()\ntuple()\n\n\n\nUse instead:\n\n\n{}\n{\"a\": 1, \"b\": 2}\n[]\n()\n\n# Idiom C409 (unnecessary-literal-within-tuple-call)\n\nDefinition: Checks for tuple calls that take unnecessary list or tuple literals as\narguments. In preview, this also includes unnecessary list comprehensions\nwithin tuple calls.\n\nRationale: It's unnecessary to use a list or tuple literal within a tuple() call,\nsince there is a literal syntax for these types.\n\n\nIf a list literal was passed, then it should be rewritten as a tuple\nliteral. Otherwise, if a tuple literal was passed, then the outer call\nto tuple() should be removed.\n\n\nIn preview, this rule also checks for list comprehensions within tuple()\ncalls. If a list comprehension is found, it should be rewritten as a\ngenerator expression.\n\nExample:\ntuple([1, 2])\ntuple((1, 2))\ntuple([x for x in range(10)])\n\n\n\nUse instead:\n\n\n(1, 2)\n(1, 2)\ntuple(x for x in range(10))\n\n# Idiom C410 (unnecessary-literal-within-list-call)\n\nDefinition: Checks for list() calls that take unnecessary list or tuple literals as\narguments.\n\nRationale: It's unnecessary to use a list or tuple literal within a list() call,\nsince there is a literal syntax for these types.\n\n\nIf a list literal is passed in, then the outer call to list() should be\nremoved. Otherwise, if a tuple literal is passed in, then it should be\nrewritten as a list literal.\n\nExample:\nlist([1, 2])\nlist((1, 2))\n\n\n\nUse instead:\n\n\n[1, 2]\n[1, 2]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLE0604-PLE0605-PLE0643-PLE1132",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLE0604 (invalid-all-object)\n\nDefinition: Checks for the inclusion of invalid objects in __all__.\n\nRationale: In Python, __all__ should contain a sequence of strings that represent\nthe names of all \"public\" symbols exported by a module.\n\n\nAssigning anything other than a tuple or list of strings to __all__\nis invalid.\n\nExample:\n__all__ = [Foo, 1, None]\n\n\n\nUse instead:\n\n\n__all__ = [\"Foo\", \"Bar\", \"Baz\"]\n\n# Idiom PLE0605 (invalid-all-format)\n\nDefinition: Checks for invalid assignments to __all__.\n\nRationale: In Python, __all__ should contain a sequence of strings that represent\nthe names of all \"public\" symbols exported by a module.\n\n\nAssigning anything other than a tuple or list of strings to __all__\nis invalid.\n\nExample:\n__all__ = \"Foo\"\n\n\n\nUse instead:\n\n\n__all__ = (\"Foo\",)\n\n# Idiom PLE0643 (potential-index-error)\n\nDefinition: Checks for hard-coded sequence accesses that are known to be out of bounds.\n\nRationale: Attempting to access a sequence with an out-of-bounds index will cause an\nIndexError to be raised at runtime. When the sequence and index are\ndefined statically (e.g., subscripts on list and tuple literals, with\ninteger indexes), such errors can be detected ahead of time.\n\nExample:\nprint([0, 1, 2][3])\n\n# Idiom PLE1132 (repeated-keyword-argument)\n\nDefinition: Checks for repeated keyword arguments in function calls.\n\nRationale: Python does not allow repeated keyword arguments in function calls. If a\nfunction is called with the same keyword argument multiple times, the\ninterpreter will raise an exception.\n\nExample:\nfunc(1, 2, c=3, **{\"c\": 4})\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/D301-D400-D401-D402-D403",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom D301 (escape-sequence-in-docstring)\n\nDefinition: Checks for docstrings that include backslashes, but are not defined as\nraw string literals.\n\nRationale: In Python, backslashes are typically used to escape characters in strings.\nIn raw strings (those prefixed with an r), however, backslashes are\ntreated as literal characters.\n\n\nPEP 257 recommends\nthe use of raw strings (i.e., r\"\"\"raw triple double quotes\"\"\") for\ndocstrings that include backslashes. The use of a raw string ensures that\nany backslashes are treated as literal characters, and not as escape\nsequences, which avoids confusion.\n\nExample:\ndef foobar():\n    \"\"\"Docstring for foo\\bar.\"\"\"\n\n\nfoobar.__doc__  # \"Docstring for foar.\"\n\n\n\nUse instead:\n\n\ndef foobar():\n    r\"\"\"Docstring for foo\\bar.\"\"\"\n\n\nfoobar.__doc__  # \"Docstring for foo\\bar.\"\n\n# Idiom D400 (missing-trailing-period)\n\nDefinition: Checks for docstrings in which the first line does not end in a period.\n\nRationale: PEP 257 recommends that the first line of a docstring is written in the\nform of a command, ending in a period.\n\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the numpy and\npep257 conventions, and disabled when using the google convention.\n\nExample:\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values\"\"\"\n\n\n\nUse instead:\n\n\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n\n# Idiom D401 (non-imperative-mood)\n\nDefinition: Checks for docstring first lines that are not in an imperative mood.\n\nRationale: PEP 257 recommends that the first line of a docstring be written in the\nimperative mood, for consistency.\n\n\nHint: to rewrite the docstring in the imperative, phrase the first line as\nif it were a command.\n\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the numpy and\npep257 conventions, and disabled when using the google conventions.\n\nExample:\ndef average(values: list[float]) -> float:\n    \"\"\"Returns the mean of the given values.\"\"\"\n\n\n\nUse instead:\n\n\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n\n# Idiom D402 (signature-in-docstring)\n\nDefinition: Checks for function docstrings that include the function's signature in\nthe summary line.\n\nRationale: PEP 257 recommends against including a function's signature in its\ndocstring. Instead, consider using type annotations as a form of\ndocumentation for the function's parameters and return value.\n\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the google and\npep257 conventions, and disabled when using the numpy convention.\n\nExample:\ndef foo(a, b):\n    \"\"\"foo(a: int, b: int) -> list[int]\"\"\"\n\n\n\nUse instead:\n\n\ndef foo(a: int, b: int) -> list[int]:\n    \"\"\"Return a list of a and b.\"\"\"\n\n# Idiom D403 (first-word-uncapitalized)\n\nDefinition: Checks for docstrings that do not start with a capital letter.\n\nRationale: The first non-whitespace character in a docstring should be\ncapitalized for grammatical correctness and consistency.\n\nExample:\ndef average(values: list[float]) -> float:\n    \"\"\"return the mean of the given values.\"\"\"\n\n\n\nUse instead:\n\n\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/F701-F702-F704-F706-F707",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom F701 (break-outside-loop)\n\nDefinition: Checks for break statements outside of loops.\n\nRationale: The use of a break statement outside of a for or while loop will\nraise a SyntaxError.\n\nExample:\ndef foo():\n    break\n\n# Idiom F702 (continue-outside-loop)\n\nDefinition: Checks for continue statements outside of loops.\n\nRationale: The use of a continue statement outside of a for or while loop will\nraise a SyntaxError.\n\nExample:\ndef foo():\n    continue  # SyntaxError\n\n# Idiom F704 (yield-outside-function)\n\nDefinition: Checks for yield, yield from, and await usages outside of functions.\n\nRationale: The use of yield, yield from, or await outside of a function will\nraise a SyntaxError.\n\nExample:\nclass Foo:\n    yield 1\n\n# Idiom F706 (return-outside-function)\n\nDefinition: Checks for return statements outside of functions.\n\nRationale: The use of a return statement outside of a function will raise a\nSyntaxError.\n\nExample:\nclass Foo:\n    return 1\n\n# Idiom F707 (default-except-not-last)\n\nDefinition: Checks for except blocks that handle all exceptions, but are not the last\nexcept block in a try statement.\n\nRationale: When an exception is raised within a try block, the except blocks are\nevaluated in order, and the first matching block is executed. If an except\nblock handles all exceptions, but isn't the last block, Python will raise a\nSyntaxError, as the following blocks would never be executed.\n\nExample:\ndef reciprocal(n):\n    try:\n        reciprocal = 1 / n\n    except:\n        print(\"An exception occurred.\")\n    except ZeroDivisionError:\n        print(\"Cannot divide by zero.\")\n    else:\n        return reciprocal\n\n\n\nUse instead:\n\n\ndef reciprocal(n):\n    try:\n        reciprocal = 1 / n\n    except ZeroDivisionError:\n        print(\"Cannot divide by zero.\")\n    except:\n        print(\"An exception occurred.\")\n    else:\n        return reciprocal\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/UP018-UP019-UP020-UP021-UP022",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom UP018 (native-literals)\n\nDefinition: Checks for unnecessary calls to str, bytes, int, float, and bool.\n\nRationale: The mentioned constructors can be replaced with their respective literal\nforms, which are more readable and idiomatic.\n\nExample:\nstr(\"foo\")\n\n\n\nUse instead:\n\n\n\"foo\"\n\n# Idiom UP019 (typing-text-str-alias)\n\nDefinition: Checks for uses of typing.Text.\n\nRationale: typing.Text is an alias for str, and only exists for Python 2\ncompatibility. As of Python 3.11, typing.Text is deprecated. Use str\ninstead.\n\nExample:\nfrom typing import Text\n\nfoo: Text = \"bar\"\n\n\n\nUse instead:\n\n\nfoo: str = \"bar\"\n\n# Idiom UP020 (open-alias)\n\nDefinition: Checks for uses of io.open.\n\nRationale: In Python 3, io.open is an alias for open. Prefer using open directly,\nas it is more idiomatic.\n\nExample:\nimport io\n\nwith io.open(\"file.txt\") as f:\n    ...\n\n\n\nUse instead:\n\n\nwith open(\"file.txt\") as f:\n    ...\n\n# Idiom UP021 (replace-universal-newlines)\n\nDefinition: Checks for uses of subprocess.run that set the universal_newlines\nkeyword argument.\n\nRationale: As of Python 3.7, the universal_newlines keyword argument has been\nrenamed to text, and now exists for backwards compatibility. The\nuniversal_newlines keyword argument may be removed in a future version of\nPython. Prefer text, which is more explicit and readable.\n\nExample:\nimport subprocess\n\nsubprocess.run([\"foo\"], universal_newlines=True)\n\n\n\nUse instead:\n\n\nimport subprocess\n\nsubprocess.run([\"foo\"], text=True)\n\n# Idiom UP022 (replace-stdout-stderr)\n\nDefinition: Checks for uses of subprocess.run that send stdout and stderr to a\npipe.\n\nRationale: As of Python 3.7, subprocess.run has a capture_output keyword argument\nthat can be set to True to capture stdout and stderr outputs. This is\nequivalent to setting stdout and stderr to subprocess.PIPE, but is\nmore explicit and readable.\n\nExample:\nimport subprocess\n\nsubprocess.run([\"foo\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n\n\nUse instead:\n\n\nimport subprocess\n\nsubprocess.run([\"foo\"], capture_output=True)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/N805-N806-N807-N811",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom N805 (invalid-first-argument-name-for-method)\n\nDefinition: Checks for instance methods that use a name other than self for their\nfirst argument.\n\nRationale: PEP 8 recommends the use of self as first argument for all instance\nmethods:\n\n\n\nAlways use self for the first argument to instance methods.\nIf a function argument\u2019s name clashes with a reserved keyword, it is generally better to\nappend a single trailing underscore rather than use an abbreviation or spelling corruption.\nThus class_ is better than clss. (Perhaps better is to avoid such clashes by using a synonym.)\n\n\n\nNames can be excluded from this rule using the lint.pep8-naming.ignore-names\nor lint.pep8-naming.extend-ignore-names configuration options. For example,\nto allow the use of this as the first argument to instance methods, set\nthe lint.pep8-naming.extend-ignore-names option to [\"this\"].\n\nExample:\nclass Example:\n    def function(cls, data): ...\n\n\n\nUse instead:\n\n\nclass Example:\n    def function(self, data): ...\n\n# Idiom N806 (non-lowercase-variable-in-function)\n\nDefinition: Checks for the use of non-lowercase variable names in functions.\n\nRationale: PEP 8 recommends that all function variables use lowercase names:\n\n\n\nFunction names should be lowercase, with words separated by underscores as necessary to\nimprove readability. Variable names follow the same convention as function names. mixedCase\nis allowed only in contexts where that's already the prevailing style (e.g. threading.py),\nto retain backwards compatibility.\n\nExample:\ndef my_function(a):\n    B = a + 3\n    return B\n\n\n\nUse instead:\n\n\ndef my_function(a):\n    b = a + 3\n    return b\n\n# Idiom N807 (dunder-function-name)\n\nDefinition: Checks for functions with \"dunder\" names (that is, names with two\nleading and trailing underscores) that are not documented.\n\nRationale: PEP 8 recommends that only documented \"dunder\" methods are used:\n\n\n\n...\"magic\" objects or attributes that live in user-controlled\nnamespaces. E.g. __init__, __import__ or __file__. Never invent\nsuch names; only use them as documented.\n\nExample:\ndef __my_function__():\n    pass\n\n\n\nUse instead:\n\n\ndef my_function():\n    pass\n\n# Idiom N811 (constant-imported-as-non-constant)\n\nDefinition: Checks for constant imports that are aliased to non-constant-style\nnames.\n\nRationale: PEP 8 recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\nExample:\nfrom example import CONSTANT_VALUE as ConstantValue\n\n\n\nUse instead:\n\n\nfrom example import CONSTANT_VALUE\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/F504-F505-F506-F507-F508",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom F504 (percent-format-extra-named-arguments)\n\nDefinition: Checks for unused mapping keys in printf-style format strings.\n\nRationale: Unused named placeholders in printf-style format strings are unnecessary,\nand likely indicative of a mistake. They should be removed.\n\nExample:\n\"Hello, %(name)s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n\n\n\nUse instead:\n\n\n\"Hello, %(name)s\" % {\"name\": \"World\"}\n\n# Idiom F505 (percent-format-missing-argument)\n\nDefinition: Checks for named placeholders in printf-style format strings that are not\npresent in the provided mapping.\n\nRationale: Named placeholders that lack a corresponding value in the provided mapping\nwill raise a KeyError.\n\nExample:\n\"%(greeting)s, %(name)s\" % {\"name\": \"world\"}\n\n\n\nUse instead:\n\n\n\"Hello, %(name)s\" % {\"name\": \"world\"}\n\n# Idiom F506 (percent-format-mixed-positional-and-named)\n\nDefinition: Checks for printf-style format strings that have mixed positional and\nnamed placeholders.\n\nRationale: Python does not support mixing positional and named placeholders in\nprintf-style format strings. The use of mixed placeholders will raise a\nTypeError at runtime.\n\nExample:\n\"%s, %(name)s\" % (\"Hello\", {\"name\": \"World\"})\n\n\n\nUse instead:\n\n\n\"%s, %s\" % (\"Hello\", \"World\")\n\n\n\nOr:\n\n\n\"%(greeting)s, %(name)s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n\n# Idiom F507 (percent-format-positional-count-mismatch)\n\nDefinition: Checks for printf-style format strings that have a mismatch between the\nnumber of positional placeholders and the number of substitution values.\n\nRationale: When a printf-style format string is provided with too many or too few\nsubstitution values, it will raise a TypeError at runtime.\n\nExample:\n\"%s, %s\" % (\"Hello\", \"world\", \"!\")\n\n\n\nUse instead:\n\n\n\"%s, %s\" % (\"Hello\", \"world\")\n\n# Idiom F508 (percent-format-star-requires-sequence)\n\nDefinition: Checks for printf-style format strings that use the * specifier with\nnon-tuple values.\n\nRationale: The use of the * specifier with non-tuple values will raise a\nTypeError at runtime.\n\nExample:\nfrom math import pi\n\n\"%(n).*f\" % {\"n\": (2, pi)}\n\n\n\nUse instead:\n\n\nfrom math import pi\n\n\"%.*f\" % (2, pi)  # 3.14\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/ISC001-ISC002-ISC003",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom ISC001 (single-line-implicit-string-concatenation)\n\nDefinition: Checks for implicitly concatenated strings on a single line.\n\nRationale: While it is valid Python syntax to concatenate multiple string or byte\nliterals implicitly (via whitespace delimiters), it is unnecessary and\nnegatively affects code readability.\n\n\nIn some cases, the implicit concatenation may also be unintentional, as\ncode formatters are capable of introducing single-line implicit\nconcatenations when collapsing long lines.\n\nExample:\nz = \"The quick \" \"brown fox.\"\n\n\n\nUse instead:\n\n\nz = \"The quick brown fox.\"\n\n# Idiom ISC002 (multi-line-implicit-string-concatenation)\n\nDefinition: Checks for implicitly concatenated strings that span multiple lines.\n\nRationale: For string literals that wrap across multiple lines, PEP 8 recommends\nthe use of implicit string concatenation within parentheses instead of\nusing a backslash for line continuation, as the former is more readable\nthan the latter.\n\n\nBy default, this rule will only trigger if the string literal is\nconcatenated via a backslash. To disallow implicit string concatenation\naltogether, set the lint.flake8-implicit-str-concat.allow-multiline option\nto false.\n\nExample:\nz = \"The quick brown fox jumps over the lazy \"\\\n    \"dog.\"\n\n\n\nUse instead:\n\n\nz = (\n    \"The quick brown fox jumps over the lazy \"\n    \"dog.\"\n)\n\n# Idiom ISC003 (explicit-string-concatenation)\n\nDefinition: Checks for string literals that are explicitly concatenated (using the\n+ operator).\n\nRationale: For string literals that wrap across multiple lines, implicit string\nconcatenation within parentheses is preferred over explicit\nconcatenation using the + operator, as the former is more readable.\n\nExample:\nz = (\n    \"The quick brown fox jumps over the lazy \"\n    + \"dog\"\n)\n\n\n\nUse instead:\n\n\nz = (\n    \"The quick brown fox jumps over the lazy \"\n    \"dog\"\n)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/Q001-Q002-Q003-Q004",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom Q001 (bad-quotes-multiline-string)\n\nDefinition: Checks for multiline strings that use single quotes or double quotes,\ndepending on the value of the lint.flake8-quotes.multiline-quotes\nsetting.\n\nRationale: Consistency is good. Use either single or double quotes for multiline\nstrings, but be consistent.\n\nExample:\nfoo = '''\nbar\n'''\n\n\n\nAssuming multiline-quotes is set to double, use instead:\n\n\nfoo = \"\"\"\nbar\n\"\"\"\n\n# Idiom Q002 (bad-quotes-docstring)\n\nDefinition: Checks for docstrings that use single quotes or double quotes, depending\non the value of the lint.flake8-quotes.docstring-quotes setting.\n\nRationale: Consistency is good. Use either single or double quotes for docstring\nstrings, but be consistent.\n\nExample:\n'''\nbar\n'''\n\n\n\nAssuming docstring-quotes is set to double, use instead:\n\n\n\"\"\"\nbar\n\"\"\"\n\n# Idiom Q003 (avoidable-escaped-quote)\n\nDefinition: Checks for strings that include escaped quotes, and suggests changing\nthe quote style to avoid the need to escape them.\n\nRationale: It's preferable to avoid escaped quotes in strings. By changing the\nouter quote style, you can avoid escaping inner quotes.\n\nExample:\nfoo = 'bar\\'s'\n\n\n\nUse instead:\n\n\nfoo = \"bar's\"\n\n# Idiom Q004 (unnecessary-escaped-quote)\n\nDefinition: Checks for strings that include unnecessarily escaped quotes.\n\nRationale: If a string contains an escaped quote that doesn't match the quote\ncharacter used for the string, it's unnecessary and can be removed.\n\nExample:\nfoo = \"bar\\'s\"\n\n\n\nUse instead:\n\n\nfoo = \"bar's\"\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/B032-B033-B034-B035-B039",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom B032 (unintentional-type-annotation)\n\nDefinition: Checks for the unintentional use of type annotations.\n\nRationale: The use of a colon (:) in lieu of an assignment (=) can be syntactically valid, but\nis almost certainly a mistake when used in a subscript or attribute assignment.\n\nExample:\na[\"b\"]: 1\n\n\n\nUse instead:\n\n\na[\"b\"] = 1\n\n# Idiom B033 (duplicate-value)\n\nDefinition: Checks for set literals that contain duplicate items.\n\nRationale: In Python, sets are unordered collections of unique elements. Including a\nduplicate item in a set literal is redundant, as the duplicate item will be\nreplaced with a single item at runtime.\n\nExample:\n{1, 2, 3, 1}\n\n\n\nUse instead:\n\n\n{1, 2, 3}\n\n# Idiom B034 (re-sub-positional-args)\n\nDefinition: Checks for calls to re.sub, re.subn, and re.split that pass count,\nmaxsplit, or flags as positional arguments.\n\nRationale: Passing count, maxsplit, or flags as positional arguments to\nre.sub, re.subn, or re.split can lead to confusion, as most methods in\nthe re module accept flags as the third positional argument, while\nre.sub, re.subn, and re.split have different signatures.\n\n\nInstead, pass count, maxsplit, and flags as keyword arguments.\n\nExample:\nimport re\n\nre.split(\"pattern\", \"replacement\", 1)\n\n\n\nUse instead:\n\n\nimport re\n\nre.split(\"pattern\", \"replacement\", maxsplit=1)\n\n# Idiom B035 (static-key-dict-comprehension)\n\nDefinition: Checks for dictionary comprehensions that use a static key, like a string\nliteral or a variable defined outside the comprehension.\n\nRationale: Using a static key (like a string literal) in a dictionary comprehension\nis usually a mistake, as it will result in a dictionary with only one key,\ndespite the comprehension iterating over multiple values.\n\nExample:\ndata = [\"some\", \"Data\"]\n{\"key\": value.upper() for value in data}\n\n\n\nUse instead:\n\n\ndata = [\"some\", \"Data\"]\n{value: value.upper() for value in data}\n\n# Idiom B039 (mutable-contextvar-default)\n\nDefinition: Checks for uses of mutable objects as ContextVar defaults.\n\nRationale: The ContextVar default is evaluated once, when the ContextVar is defined.\n\n\nThe same mutable object is then shared across all .get() method calls to\nthe ContextVar. If the object is modified, those modifications will persist\nacross calls, which can lead to unexpected behavior.\n\n\nInstead, prefer to use immutable data structures. Alternatively, take\nNone as a default, and initialize a new mutable object inside for each\ncall using the .set() method.\n\n\nTypes outside the standard library can be marked as immutable with the\nlint.flake8-bugbear.extend-immutable-calls configuration option.\n\nExample:\nfrom contextvars import ContextVar\n\n\ncv: ContextVar[list] = ContextVar(\"cv\", default=[])\n\n\n\nUse instead:\n\n\nfrom contextvars import ContextVar\n\n\ncv: ContextVar[list | None] = ContextVar(\"cv\", default=None)\n\n...\n\nif cv.get() is None:\n    cv.set([])\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/TD001-TD002-TD003-TD004",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom TD001 (invalid-todo-tag)\n\nDefinition: Checks that a TODO comment is labelled with \"TODO\".\n\nRationale: Ambiguous tags reduce code visibility and can lead to dangling TODOs.\nFor example, if a comment is tagged with \"FIXME\" rather than \"TODO\", it may\nbe overlooked by future readers.\n\n\nNote that this rule will only flag \"FIXME\" and \"XXX\" tags as incorrect.\n\nExample:\n# FIXME(ruff): this should get fixed!\n\n\n\nUse instead:\n\n\n# TODO(ruff): this is now fixed!\n\n# Idiom TD002 (missing-todo-author)\n\nDefinition: Checks that a TODO comment includes an author.\n\nRationale: Including an author on a TODO provides future readers with context around\nthe issue. While the TODO author is not always considered responsible for\nfixing the issue, they are typically the individual with the most context.\n\nExample:\n# TODO: should assign an author here\n\n\n\nUse instead\n\n\n# TODO(charlie): now an author is assigned\n\n# Idiom TD003 (missing-todo-link)\n\nDefinition: Checks that a TODO comment is associated with a link to a relevant issue\nor ticket.\n\nRationale: Including an issue link near a TODO makes it easier for resolvers\nto get context around the issue.\n\nExample:\n# TODO: this link has no issue\n\n\n\nUse one of these instead:\n\n\n# TODO(charlie): this comment has an issue link\n# https://github.com/astral-sh/ruff/issues/3870\n\n# TODO(charlie): this comment has a 3-digit issue code\n# 003\n\n# TODO(charlie): https://github.com/astral-sh/ruff/issues/3870\n# this comment has an issue link\n\n# TODO(charlie): #003 this comment has a 3-digit issue code\n# with leading character `#`\n\n# TODO(charlie): this comment has an issue code (matches the regex `[A-Z]+\\-?\\d+`)\n# SIXCHR-003\n\n# Idiom TD004 (missing-todo-colon)\n\nDefinition: Checks that a \"TODO\" tag is followed by a colon.\n\nRationale: \"TODO\" tags are typically followed by a parenthesized author name, a colon,\na space, and a description of the issue, in that order.\n\n\nDeviating from this pattern can lead to inconsistent and non-idiomatic\ncomments.\n\nExample:\n# TODO(charlie) fix this colon\n\n\n\nUsed instead:\n\n\n# TODO(charlie): colon fixed\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/A001-A002-A003",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom A001 (builtin-variable-shadowing)\n\nDefinition: Checks for variable (and function) assignments that use the same names\nas builtins.\n\nRationale: Reusing a builtin name for the name of a variable increases the\ndifficulty of reading and maintaining the code, and can cause\nnon-obvious errors, as readers may mistake the variable for the\nbuiltin and vice versa.\n\n\nBuiltins can be marked as exceptions to this rule via the\nlint.flake8-builtins.ignorelist configuration option.\n\nExample:\ndef find_max(list_of_lists):\n    max = 0\n    for flat_list in list_of_lists:\n        for value in flat_list:\n            max = max(max, value)  # TypeError: 'int' object is not callable\n    return max\n\n\n\nUse instead:\n\n\ndef find_max(list_of_lists):\n    result = 0\n    for flat_list in list_of_lists:\n        for value in flat_list:\n            result = max(result, value)\n    return result\n\n# Idiom A002 (builtin-argument-shadowing)\n\nDefinition: Checks for function arguments that use the same names as builtins.\n\nRationale: Reusing a builtin name for the name of an argument increases the\ndifficulty of reading and maintaining the code, and can cause\nnon-obvious errors, as readers may mistake the argument for the\nbuiltin and vice versa.\n\n\nBuiltins can be marked as exceptions to this rule via the\nlint.flake8-builtins.ignorelist configuration option.\n\nExample:\ndef remove_duplicates(list, list2):\n    result = set()\n    for value in list:\n        result.add(value)\n    for value in list2:\n        result.add(value)\n    return list(result)  # TypeError: 'list' object is not callable\n\n\n\nUse instead:\n\n\ndef remove_duplicates(list1, list2):\n    result = set()\n    for value in list1:\n        result.add(value)\n    for value in list2:\n        result.add(value)\n    return list(result)\n\n# Idiom A003 (builtin-attribute-shadowing)\n\nDefinition: Checks for class attributes and methods that use the same names as\nPython builtins.\n\nRationale: Reusing a builtin name for the name of an attribute increases the\ndifficulty of reading and maintaining the code, and can cause\nnon-obvious errors, as readers may mistake the attribute for the\nbuiltin and vice versa.\n\n\nSince methods and class attributes typically cannot be referenced directly\nfrom outside the class scope, this rule only applies to those methods\nand attributes that both shadow a builtin and are referenced from within\nthe class scope, as in the following example, where the list[int] return\ntype annotation resolves to the list method, rather than the builtin:\n\n\nclass Class:\n    @staticmethod\n    def list() -> None:\n        pass\n\n    @staticmethod\n    def repeat(value: int, times: int) -> list[int]:\n        return [value] * times\n\n\n\nBuiltins can be marked as exceptions to this rule via the\nlint.flake8-builtins.ignorelist configuration option, or\nconverted to the appropriate dunder method. Methods decorated with\n@typing.override or @typing_extensions.override are also\nignored.\n\nExample:\nclass Class:\n    @staticmethod\n    def list() -> None:\n        pass\n\n    @staticmethod\n    def repeat(value: int, times: int) -> list[int]:\n        return [value] * times\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/RUF030-RUF031-RUF032-RUF033-RUF034",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom RUF030 (assert-with-print-message)\n\nDefinition: Checks for uses of assert expression, print(message).\n\nRationale: If an assert x, y assertion fails, the Python interpreter raises an\nAssertionError, and the evaluated value of y is used as the contents of\nthat assertion error. The print function always returns None, however,\nso the evaluated value of a call to print will always be None.\n\n\nUsing a print call in this context will therefore output the message to\nstdout, before raising an empty AssertionError(None). Instead, remove\nthe print and pass the message directly as the second expression,\nallowing stderr to capture the message in a well-formatted context.\n\nExample:\nassert False, print(\"This is a message\")\n\n\n\nUse instead:\n\n\nassert False, \"This is a message\"\n\n# Idiom RUF031 (incorrectly-parenthesized-tuple-in-subscript)\n\nDefinition: Checks for consistent style regarding whether nonempty tuples in subscripts\nare parenthesized.\n\n\nThe exact nature of this violation depends on the setting\nlint.ruff.parenthesize-tuple-in-subscript. By default, the use of\nparentheses is considered a violation.\n\n\nThis rule is not applied inside \"typing contexts\" (type annotations,\ntype aliases and subscripted class bases), as these have their own specific\nconventions around them.\n\nRationale: It is good to be consistent and, depending on the codebase, one or the other\nconvention may be preferred.\n\nExample:\ndirections = {(0, 1): \"North\", (1, 0): \"East\", (0, -1): \"South\", (-1, 0): \"West\"}\ndirections[(0, 1)]\n\n\n\nUse instead (with default setting):\n\n\ndirections = {(0, 1): \"North\", (1, 0): \"East\", (0, -1): \"South\", (-1, 0): \"West\"}\ndirections[0, 1]\n\n# Idiom RUF032 (decimal-from-float-literal)\n\nDefinition: Checks for Decimal calls passing a float literal.\n\nRationale: Float literals have limited precision that can lead to unexpected results.\nThe Decimal class is designed to handle numbers with fixed-point precision,\nso a string literal should be used instead.\n\nExample:\nnum = Decimal(1.2345)\n\n\n\nUse instead:\n\n\nnum = Decimal(\"1.2345\")\n\n# Idiom RUF033 (post-init-default)\n\nDefinition: Checks for __post_init__ dataclass methods with parameter defaults.\n\nRationale: Adding a default value to a parameter in a __post_init__ method has no\nimpact on whether the parameter will have a default value in the dataclass's\ngenerated __init__ method. To create an init-only dataclass parameter with\na default value, you should use an InitVar field in the dataclass's class\nbody and give that InitVar field a default value.\n\n\nAs the documentation states:\n\n\n\nInit-only fields are added as parameters to the generated __init__()\nmethod, and are passed to the optional __post_init__() method. They are\nnot otherwise used by dataclasses.\n\nExample:\nfrom dataclasses import InitVar, dataclass\n\n\n@dataclass\nclass Foo:\n    bar: InitVar[int] = 0\n\n    def __post_init__(self, bar: int = 1, baz: int = 2) -> None:\n        print(bar, baz)\n\n\nfoo = Foo()  # Prints '0 2'.\n\n\n\nUse instead:\n\n\nfrom dataclasses import InitVar, dataclass\n\n\n@dataclass\nclass Foo:\n    bar: InitVar[int] = 1\n    baz: InitVar[int] = 2\n\n    def __post_init__(self, bar: int, baz: int) -> None:\n        print(bar, baz)\n\n\nfoo = Foo()  # Prints '1 2'.\n\n# Idiom RUF034 (useless-if-else)\n\nDefinition: Checks for useless if-else conditions with identical arms.\n\nRationale: Useless if-else conditions add unnecessary complexity to the code without\nproviding any logical benefit. Assigning the value directly is clearer.\n\nExample:\nfoo = x if y else x\n\n\n\nUse instead:\n\n\nfoo = x\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLC0105-PLC0131-PLC0132-PLC0205-PLC0206",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLC0105 (type-name-incorrect-variance)\n\nDefinition: Checks for type names that do not match the variance of their associated\ntype parameter.\n\nRationale: PEP 484 recommends the use of the _co and _contra suffixes for\ncovariant and contravariant type parameters, respectively (while invariant\ntype parameters should not have any such suffix).\n\nExample:\nfrom typing import TypeVar\n\nT = TypeVar(\"T\", covariant=True)\nU = TypeVar(\"U\", contravariant=True)\nV_co = TypeVar(\"V_co\")\n\n\n\nUse instead:\n\n\nfrom typing import TypeVar\n\nT_co = TypeVar(\"T_co\", covariant=True)\nU_contra = TypeVar(\"U_contra\", contravariant=True)\nV = TypeVar(\"V\")\n\n# Idiom PLC0131 (type-bivariance)\n\nDefinition: Checks for TypeVar and ParamSpec definitions in which the type is\nboth covariant and contravariant.\n\nRationale: By default, Python's generic types are invariant, but can be marked as\neither covariant or contravariant via the covariant and contravariant\nkeyword arguments. While the API does allow you to mark a type as both\ncovariant and contravariant, this is not supported by the type system,\nand should be avoided.\n\n\nInstead, change the variance of the type to be either covariant,\ncontravariant, or invariant. If you want to describe both covariance and\ncontravariance, consider using two separate type parameters.\n\n\nFor context: an \"invariant\" generic type only accepts values that exactly\nmatch the type parameter; for example, list[Dog] accepts only list[Dog],\nnot list[Animal] (superclass) or list[Bulldog] (subclass). This is\nthe default behavior for Python's generic types.\n\n\nA \"covariant\" generic type accepts subclasses of the type parameter; for\nexample, Sequence[Animal] accepts Sequence[Dog]. A \"contravariant\"\ngeneric type accepts superclasses of the type parameter; for example,\nCallable[Dog] accepts Callable[Animal].\n\nExample:\nfrom typing import TypeVar\n\nT = TypeVar(\"T\", covariant=True, contravariant=True)\n\n\n\nUse instead:\n\n\nfrom typing import TypeVar\n\nT_co = TypeVar(\"T_co\", covariant=True)\nT_contra = TypeVar(\"T_contra\", contravariant=True)\n\n# Idiom PLC0132 (type-param-name-mismatch)\n\nDefinition: Checks for TypeVar, TypeVarTuple, ParamSpec, and NewType\ndefinitions in which the name of the type parameter does not match the name\nof the variable to which it is assigned.\n\nRationale: When defining a TypeVar or a related type parameter, Python allows you to\nprovide a name for the type parameter. According to PEP 484, the name\nprovided to the TypeVar constructor must be equal to the name of the\nvariable to which it is assigned.\n\nExample:\nfrom typing import TypeVar\n\nT = TypeVar(\"U\")\n\n\n\nUse instead:\n\n\nfrom typing import TypeVar\n\nT = TypeVar(\"T\")\n\n# Idiom PLC0205 (single-string-slots)\n\nDefinition: Checks for single strings assigned to __slots__.\n\nRationale: In Python, the __slots__ attribute allows you to explicitly define the\nattributes (instance variables) that a class can have. By default, Python\nuses a dictionary to store an object's attributes, which incurs some memory\noverhead. However, when __slots__ is defined, Python uses a more compact\ninternal structure to store the object's attributes, resulting in memory\nsavings.\n\n\nAny string iterable may be assigned to __slots__ (most commonly, a\ntuple of strings). If a string is assigned to __slots__, it is\ninterpreted as a single attribute name, rather than an iterable of attribute\nnames. This can cause confusion, as users that iterate over the __slots__\nvalue may expect to iterate over a sequence of attributes, but would instead\niterate over the characters of the string.\n\n\nTo use a single string attribute in __slots__, wrap the string in an\niterable container type, like a tuple.\n\nExample:\nclass Person:\n    __slots__: str = \"name\"\n\n    def __init__(self, name: str) -> None:\n        self.name = name\n\n\n\nUse instead:\n\n\nclass Person:\n    __slots__: tuple[str, ...] = (\"name\",)\n\n    def __init__(self, name: str) -> None:\n        self.name = name\n\n# Idiom PLC0206 (dict-index-missing-items)\n\nDefinition: Checks for dictionary iterations that extract the dictionary value\nvia explicit indexing, instead of using .items().\n\nRationale: Iterating over a dictionary with .items() is semantically clearer\nand more efficient than extracting the value with the key.\n\nExample:\nORCHESTRA = {\n    \"violin\": \"strings\",\n    \"oboe\": \"woodwind\",\n    \"tuba\": \"brass\",\n    \"gong\": \"percussion\",\n}\n\nfor instrument in ORCHESTRA:\n    print(f\"{instrument}: {ORCHESTRA[instrument]}\")\n\n\n\nUse instead:\n\n\nORCHESTRA = {\n    \"violin\": \"strings\",\n    \"oboe\": \"woodwind\",\n    \"tuba\": \"brass\",\n    \"gong\": \"percussion\",\n}\n\nfor instrument, section in ORCHESTRA.items():\n    print(f\"{instrument}: {section}\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLE1141-PLE1142-PLE1205-PLE1206-PLE1300",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLE1141 (dict-iter-missing-items)\n\nDefinition: Checks for dictionary unpacking in a for loop without calling .items().\n\nRationale: When iterating over a dictionary in a for loop, if a dictionary is unpacked\nwithout calling .items(), it could lead to a runtime error if the keys are not\na tuple of two elements.\n\n\nIt is likely that you're looking for an iteration over (key, value) pairs which\ncan only be achieved when calling .items().\n\nExample:\ndata = {\"Paris\": 2_165_423, \"New York City\": 8_804_190, \"Tokyo\": 13_988_129}\n\nfor city, population in data:\n    print(f\"{city} has population {population}.\")\n\n\n\nUse instead:\n\n\ndata = {\"Paris\": 2_165_423, \"New York City\": 8_804_190, \"Tokyo\": 13_988_129}\n\nfor city, population in data.items():\n    print(f\"{city} has population {population}.\")\n\n# Idiom PLE1142 (await-outside-async)\n\nDefinition: Checks for uses of await outside async functions.\n\nRationale: Using await outside an async function is a syntax error.\n\nExample:\nimport asyncio\n\n\ndef foo():\n    await asyncio.sleep(1)\n\n\n\nUse instead:\n\n\nimport asyncio\n\n\nasync def foo():\n    await asyncio.sleep(1)\n\n# Idiom PLE1205 (logging-too-many-args)\n\nDefinition: Checks for too many positional arguments for a logging format string.\n\nRationale: A TypeError will be raised if the statement is run.\n\nExample:\nimport logging\n\ntry:\n    function()\nexcept Exception as e:\n    logging.error(\"Error occurred: %s\", type(e), e)\n    raise\n\n\n\nUse instead:\n\n\nimport logging\n\ntry:\n    function()\nexcept Exception as e:\n    logging.error(\"%s error occurred: %s\", type(e), e)\n    raise\n\n# Idiom PLE1206 (logging-too-few-args)\n\nDefinition: Checks for too few positional arguments for a logging format string.\n\nRationale: A TypeError will be raised if the statement is run.\n\nExample:\nimport logging\n\ntry:\n    function()\nexcept Exception as e:\n    logging.error(\"%s error occurred: %s\", e)\n    raise\n\n\n\nUse instead:\n\n\nimport logging\n\ntry:\n    function()\nexcept Exception as e:\n    logging.error(\"%s error occurred: %s\", type(e), e)\n    raise\n\n# Idiom PLE1300 (bad-string-format-character)\n\nDefinition: Checks for unsupported format types in format strings.\n\nRationale: An invalid format string character will result in an error at runtime.\n\nExample:\n# `z` is not a valid format type.\nprint(\"%z\" % \"1\")\n\nprint(\"{:z}\".format(\"1\"))\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLR0911-PLR0912-PLR0913-PLR0914-PLR0915",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLR0911 (too-many-return-statements)\n\nDefinition: Checks for functions or methods with too many return statements.\n\n\nBy default, this rule allows up to six return statements, as configured by\nthe lint.pylint.max-returns option.\n\nRationale: Functions or methods with many return statements are harder to understand\nand maintain, and often indicative of complex logic.\n\nExample:\ndef capital(country: str) -> str | None:\n    if country == \"England\":\n        return \"London\"\n    elif country == \"France\":\n        return \"Paris\"\n    elif country == \"Poland\":\n        return \"Warsaw\"\n    elif country == \"Romania\":\n        return \"Bucharest\"\n    elif country == \"Spain\":\n        return \"Madrid\"\n    elif country == \"Thailand\":\n        return \"Bangkok\"\n    else:\n        return None\n\n\n\nUse instead:\n\n\ndef capital(country: str) -> str | None:\n    capitals = {\n        \"England\": \"London\",\n        \"France\": \"Paris\",\n        \"Poland\": \"Warsaw\",\n        \"Romania\": \"Bucharest\",\n        \"Spain\": \"Madrid\",\n        \"Thailand\": \"Bangkok\",\n    }\n    return capitals.get(country)\n\n# Idiom PLR0912 (too-many-branches)\n\nDefinition: Checks for functions or methods with too many branches, including (nested)\nif, elif, and else branches, for loops, try-except clauses, and\nmatch and case statements.\n\n\nBy default, this rule allows up to 12 branches. This can be configured\nusing the lint.pylint.max-branches option.\n\nRationale: Functions or methods with many branches are harder to understand\nand maintain than functions or methods with fewer branches.\n\nExample:\nGiven:\n\n\ndef capital(country):\n    if country == \"Australia\":\n        return \"Canberra\"\n    elif country == \"Brazil\":\n        return \"Brasilia\"\n    elif country == \"Canada\":\n        return \"Ottawa\"\n    elif country == \"England\":\n        return \"London\"\n    elif country == \"France\":\n        return \"Paris\"\n    elif country == \"Germany\":\n        return \"Berlin\"\n    elif country == \"Poland\":\n        return \"Warsaw\"\n    elif country == \"Romania\":\n        return \"Bucharest\"\n    elif country == \"Spain\":\n        return \"Madrid\"\n    elif country == \"Thailand\":\n        return \"Bangkok\"\n    elif country == \"Turkey\":\n        return \"Ankara\"\n    elif country == \"United States\":\n        return \"Washington\"\n    else:\n        return \"Unknown\"  # 13th branch\n\n\n\nUse instead:\n\n\ndef capital(country):\n    capitals = {\n        \"Australia\": \"Canberra\",\n        \"Brazil\": \"Brasilia\",\n        \"Canada\": \"Ottawa\",\n        \"England\": \"London\",\n        \"France\": \"Paris\",\n        \"Germany\": \"Berlin\",\n        \"Poland\": \"Warsaw\",\n        \"Romania\": \"Bucharest\",\n        \"Spain\": \"Madrid\",\n        \"Thailand\": \"Bangkok\",\n        \"Turkey\": \"Ankara\",\n        \"United States\": \"Washington\",\n    }\n    city = capitals.get(country, \"Unknown\")\n    return city\n\n\n\nGiven:\n\n\ndef grades_to_average_number(grades):\n    numbers = []\n    for grade in grades:  # 1st branch\n        if len(grade) not in {1, 2}:\n            raise ValueError(f\"Invalid grade: {grade}\")\n\n        if len(grade) == 2 and grade[1] not in {\"+\", \"-\"}:\n            raise ValueError(f\"Invalid grade: {grade}\")\n\n        letter = grade[0]\n\n        if letter in {\"F\", \"E\"}:\n            number = 0.0\n        elif letter == \"D\":\n            number = 1.0\n        elif letter == \"C\":\n            number = 2.0\n        elif letter == \"B\":\n            number = 3.0\n        elif letter == \"A\":\n            number = 4.0\n        else:\n            raise ValueError(f\"Invalid grade: {grade}\")\n\n        modifier = 0.0\n        if letter != \"F\" and grade[-1] == \"+\":\n            modifier = 0.3\n        elif letter != \"F\" and grade[-1] == \"-\":\n            modifier = -0.3\n\n        numbers.append(max(0.0, min(number + modifier, 4.0)))\n\n    try:\n        return sum(numbers) / len(numbers)\n    except ZeroDivisionError:  # 13th branch\n        return 0\n\n\n\nUse instead:\n\n\ndef grades_to_average_number(grades):\n    grade_values = {\"F\": 0.0, \"E\": 0.0, \"D\": 1.0, \"C\": 2.0, \"B\": 3.0, \"A\": 4.0}\n    modifier_values = {\"+\": 0.3, \"-\": -0.3}\n\n    numbers = []\n    for grade in grades:\n        if len(grade) not in {1, 2}:\n            raise ValueError(f\"Invalid grade: {grade}\")\n\n        letter = grade[0]\n        if letter not in grade_values:\n            raise ValueError(f\"Invalid grade: {grade}\")\n        number = grade_values[letter]\n\n        if len(grade) == 2 and grade[1] not in modifier_values:\n            raise ValueError(f\"Invalid grade: {grade}\")\n        modifier = modifier_values.get(grade[-1], 0.0)\n\n        if letter == \"F\":\n            numbers.append(0.0)\n        else:\n            numbers.append(max(0.0, min(number + modifier, 4.0)))\n\n    try:\n        return sum(numbers) / len(numbers)\n    except ZeroDivisionError:\n        return 0\n\n# Idiom PLR0913 (too-many-arguments)\n\nDefinition: Checks for function definitions that include too many arguments.\n\n\nBy default, this rule allows up to five arguments, as configured by the\nlint.pylint.max-args option.\n\nRationale: Functions with many arguments are harder to understand, maintain, and call.\nConsider refactoring functions with many arguments into smaller functions\nwith fewer arguments, or using objects to group related arguments.\n\nExample:\ndef calculate_position(x_pos, y_pos, z_pos, x_vel, y_vel, z_vel, time):\n    new_x = x_pos + x_vel * time\n    new_y = y_pos + y_vel * time\n    new_z = z_pos + z_vel * time\n    return new_x, new_y, new_z\n\n\n\nUse instead:\n\n\nfrom typing import NamedTuple\n\n\nclass Vector(NamedTuple):\n    x: float\n    y: float\n    z: float\n\n\ndef calculate_position(pos: Vector, vel: Vector, time: float) -> Vector:\n    return Vector(*(p + v * time for p, v in zip(pos, vel)))\n\n# Idiom PLR0914 (too-many-locals)\n\nDefinition: Checks for functions that include too many local variables.\n\n\nBy default, this rule allows up to fifteen locals, as configured by the\nlint.pylint.max-locals option.\n\nRationale: Functions with many local variables are harder to understand and maintain.\n\n\nConsider refactoring functions with many local variables into smaller\nfunctions with fewer assignments.\n\n# Idiom PLR0915 (too-many-statements)\n\nDefinition: Checks for functions or methods with too many statements.\n\n\nBy default, this rule allows up to 50 statements, as configured by the\nlint.pylint.max-statements option.\n\nRationale: Functions or methods with many statements are harder to understand\nand maintain.\n\n\nInstead, consider refactoring the function or method into smaller\nfunctions or methods, or identifying generalizable patterns and\nreplacing them with generic logic or abstractions.\n\nExample:\ndef is_even(number: int) -> bool:\n    if number == 0:\n        return True\n    elif number == 1:\n        return False\n    elif number == 2:\n        return True\n    elif number == 3:\n        return False\n    elif number == 4:\n        return True\n    elif number == 5:\n        return False\n    else:\n        ...\n\n\n\nUse instead:\n\n\ndef is_even(number: int) -> bool:\n    return number % 2 == 0\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLW0245-PLW0406-PLW0602-PLW0603-PLW0604",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLW0245 (super-without-brackets)\n\nDefinition: Detects attempts to use super without parentheses.\n\nRationale: The super() callable\ncan be used inside method definitions to create a proxy object that\ndelegates attribute access to a superclass of the current class. Attempting\nto access attributes on super itself, however, instead of the object\nreturned by a call to super(), will raise AttributeError.\n\nExample:\nclass Animal:\n    @staticmethod\n    def speak():\n        return \"This animal says something.\"\n\n\nclass Dog(Animal):\n    @staticmethod\n    def speak():\n        original_speak = super.speak()  # ERROR: `super.speak()`\n        return f\"{original_speak} But as a dog, it barks!\"\n\n\n\nUse instead:\n\n\nclass Animal:\n    @staticmethod\n    def speak():\n        return \"This animal says something.\"\n\n\nclass Dog(Animal):\n    @staticmethod\n    def speak():\n        original_speak = super().speak()  # Correct: `super().speak()`\n        return f\"{original_speak} But as a dog, it barks!\"\n\n# Idiom PLW0406 (import-self)\n\nDefinition: Checks for import statements that import the current module.\n\nRationale: Importing a module from itself is a circular dependency and results\nin an ImportError exception.\n\nExample:\n# file: this_file.py\nfrom this_file import foo\n\n\ndef foo(): ...\n\n# Idiom PLW0602 (global-variable-not-assigned)\n\nDefinition: Checks for global variables that are not assigned a value in the current\nscope.\n\nRationale: The global keyword allows an inner scope to modify a variable declared\nin the outer scope. If the variable is not modified within the inner scope,\nthere is no need to use global.\n\nExample:\nDEBUG = True\n\n\ndef foo():\n    global DEBUG\n    if DEBUG:\n        print(\"foo() called\")\n    ...\n\n\n\nUse instead:\n\n\nDEBUG = True\n\n\ndef foo():\n    if DEBUG:\n        print(\"foo() called\")\n    ...\n\n# Idiom PLW0603 (global-statement)\n\nDefinition: Checks for the use of global statements to update identifiers.\n\nRationale: Pylint discourages the use of global variables as global mutable\nstate is a common source of bugs and confusing behavior.\n\nExample:\nvar = 1\n\n\ndef foo():\n    global var  # [global-statement]\n    var = 10\n    print(var)\n\n\nfoo()\nprint(var)\n\n\n\nUse instead:\n\n\nvar = 1\n\n\ndef foo():\n    print(var)\n    return 10\n\n\nvar = foo()\nprint(var)\n\n# Idiom PLW0604 (global-at-module-level)\n\nDefinition: Checks for uses of the global keyword at the module level.\n\nRationale: The global keyword is used within functions to indicate that a name\nrefers to a global variable, rather than a local variable.\n\n\nAt the module level, all names are global by default, so the global\nkeyword is redundant.\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLR1733-PLR1736-PLR2004-PLR2044",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLR1733 (unnecessary-dict-index-lookup)\n\nDefinition: Checks for key-based dict accesses during .items() iterations.\n\nRationale: When iterating over a dict via .items(), the current value is already\navailable alongside its key. Using the key to look up the value is\nunnecessary.\n\nExample:\nFRUITS = {\"apple\": 1, \"orange\": 10, \"berry\": 22}\n\nfor fruit_name, fruit_count in FRUITS.items():\n    print(FRUITS[fruit_name])\n\n\n\nUse instead:\n\n\nFRUITS = {\"apple\": 1, \"orange\": 10, \"berry\": 22}\n\nfor fruit_name, fruit_count in FRUITS.items():\n    print(fruit_count)\n\n# Idiom PLR1736 (unnecessary-list-index-lookup)\n\nDefinition: Checks for index-based list accesses during enumerate iterations.\n\nRationale: When iterating over a list with enumerate, the current item is already\navailable alongside its index. Using the index to look up the item is\nunnecessary.\n\nExample:\nletters = [\"a\", \"b\", \"c\"]\n\nfor index, letter in enumerate(letters):\n    print(letters[index])\n\n\n\nUse instead:\n\n\nletters = [\"a\", \"b\", \"c\"]\n\nfor index, letter in enumerate(letters):\n    print(letter)\n\n# Idiom PLR2004 (magic-value-comparison)\n\nDefinition: Checks for the use of unnamed numerical constants (\"magic\") values in\ncomparisons.\n\nRationale: The use of \"magic\" values can make code harder to read and maintain, as\nreaders will have to infer the meaning of the value from the context.\nSuch values are discouraged by PEP 8.\n\n\nFor convenience, this rule excludes a variety of common values from the\n\"magic\" value definition, such as 0, 1, \"\", and \"__main__\".\n\nExample:\ndef apply_discount(price: float) -> float:\n    if price <= 100:\n        return price / 2\n    else:\n        return price\n\n\n\nUse instead:\n\n\nMAX_DISCOUNT = 100\n\n\ndef apply_discount(price: float) -> float:\n    if price <= MAX_DISCOUNT:\n        return price / 2\n    else:\n        return price\n\n# Idiom PLR2044 (empty-comment)\n\nDefinition: Checks for a # symbol appearing on a line not followed by an actual comment.\n\nRationale: Empty comments don't provide any clarity to the code, and just add clutter.\nEither add a comment or delete the empty comment.\n\nExample:\nclass Foo:  #\n    pass\n\n\n\nUse instead:\n\n\nclass Foo:\n    pass\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PT008-PT009-PT010-PT011-PT012",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PT008 (pytest-patch-with-lambda)\n\nDefinition: Checks for mocked calls that use a dummy lambda function instead of\nreturn_value.\n\nRationale: When patching calls, an explicit return_value better conveys the intent\nthan a lambda function, assuming the lambda does not use the arguments\npassed to it.\n\n\nreturn_value is also robust to changes in the patched function's\nsignature, and enables additional assertions to verify behavior. For\nexample, return_value allows for verification of the number of calls or\nthe arguments passed to the patched function via assert_called_once_with\nand related methods.\n\nExample:\ndef test_foo(mocker):\n    mocker.patch(\"module.target\", lambda x, y: 7)\n\n\n\nUse instead:\n\n\ndef test_foo(mocker):\n    mocker.patch(\"module.target\", return_value=7)\n\n    # If the lambda makes use of the arguments, no diagnostic is emitted.\n    mocker.patch(\"module.other_target\", lambda x, y: x)\n\n# Idiom PT009 (pytest-unittest-assertion)\n\nDefinition: Checks for uses of assertion methods from the unittest module.\n\nRationale: To make use of pytest's assertion rewriting, a regular assert statement\nis preferred over unittest's assertion methods.\n\nExample:\nimport unittest\n\n\nclass TestFoo(unittest.TestCase):\n    def test_foo(self):\n        self.assertEqual(a, b)\n\n\n\nUse instead:\n\n\nimport unittest\n\n\nclass TestFoo(unittest.TestCase):\n    def test_foo(self):\n        assert a == b\n\n# Idiom PT010 (pytest-raises-without-exception)\n\nDefinition: Checks for pytest.raises calls without an expected exception.\n\nRationale: pytest.raises expects to receive an expected exception as its first\nargument. If omitted, the pytest.raises call will fail at runtime.\n\nExample:\nimport pytest\n\n\ndef test_foo():\n    with pytest.raises():\n        do_something()\n\n\n\nUse instead:\n\n\nimport pytest\n\n\ndef test_foo():\n    with pytest.raises(SomeException):\n        do_something()\n\n# Idiom PT011 (pytest-raises-too-broad)\n\nDefinition: Checks for pytest.raises calls without a match parameter.\n\nRationale: pytest.raises(Error) will catch any Error and may catch errors that are\nunrelated to the code under test. To avoid this, pytest.raises should be\ncalled with a match parameter. The exception names that require a match\nparameter can be configured via the\nlint.flake8-pytest-style.raises-require-match-for and\nlint.flake8-pytest-style.raises-extend-require-match-for settings.\n\nExample:\nimport pytest\n\n\ndef test_foo():\n    with pytest.raises(ValueError):\n        ...\n\n    # empty string is also an error\n    with pytest.raises(ValueError, match=\"\"):\n        ...\n\n\n\nUse instead:\n\n\nimport pytest\n\n\ndef test_foo():\n    with pytest.raises(ValueError, match=\"expected message\"):\n        ...\n\n# Idiom PT012 (pytest-raises-with-multiple-statements)\n\nDefinition: Checks for pytest.raises context managers with multiple statements.\n\n\nThis rule allows pytest.raises bodies to contain for\nloops with empty bodies (e.g., pass or ... statements), to test\niterator behavior.\n\nRationale: When a pytest.raises is used as a context manager and contains multiple\nstatements, it can lead to the test passing when it actually should fail.\n\n\nA pytest.raises context manager should only contain a single simple\nstatement that raises the expected exception.\n\nExample:\nimport pytest\n\n\ndef test_foo():\n    with pytest.raises(MyError):\n        setup()\n        func_to_test()  # not executed if `setup()` raises `MyError`\n        assert foo()  # not executed\n\n\n\nUse instead:\n\n\nimport pytest\n\n\ndef test_foo():\n    setup()\n    with pytest.raises(MyError):\n        func_to_test()\n    assert foo()\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLR0916-PLR0917-PLR1702-PLR1704-PLR1711",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLR0916 (too-many-boolean-expressions)\n\nDefinition: Checks for too many Boolean expressions in an if statement.\n\n\nBy default, this rule allows up to 5 expressions. This can be configured\nusing the lint.pylint.max-bool-expr option.\n\nRationale: if statements with many Boolean expressions are harder to understand\nand maintain. Consider assigning the result of the Boolean expression,\nor any of its sub-expressions, to a variable.\n\nExample:\nif a and b and c and d and e and f and g and h:\n    ...\n\n# Idiom PLR0917 (too-many-positional-arguments)\n\nDefinition: Checks for function definitions that include too many positional arguments.\n\n\nBy default, this rule allows up to five arguments, as configured by the\nlint.pylint.max-positional-args option.\n\nRationale: Functions with many arguments are harder to understand, maintain, and call.\nThis is especially true for functions with many positional arguments, as\nproviding arguments positionally is more error-prone and less clear to\nreaders than providing arguments by name.\n\n\nConsider refactoring functions with many arguments into smaller functions\nwith fewer arguments, using objects to group related arguments, or migrating to\nkeyword-only arguments.\n\nExample:\ndef plot(x, y, z, color, mark, add_trendline): ...\n\n\nplot(1, 2, 3, \"r\", \"*\", True)\n\n\n\nUse instead:\n\n\ndef plot(x, y, z, *, color, mark, add_trendline): ...\n\n\nplot(1, 2, 3, color=\"r\", mark=\"*\", add_trendline=True)\n\n# Idiom PLR1702 (too-many-nested-blocks)\n\nDefinition: Checks for functions or methods with too many nested blocks.\n\n\nBy default, this rule allows up to five nested blocks.\nThis can be configured using the lint.pylint.max-nested-blocks option.\n\nRationale: Functions or methods with too many nested blocks are harder to understand\nand maintain.\n\n# Idiom PLR1704 (redefined-argument-from-local)\n\nDefinition: Checks for variables defined in for, try, with statements\nthat redefine function parameters.\n\nRationale: Redefined variables can cause unexpected behavior because of overridden function parameters.\nIf nested functions are declared, an inner function's body can override an outer function's parameters.\n\nExample:\ndef show(host_id=10.11):\n    for host_id, host in [[12.13, \"Venus\"], [14.15, \"Mars\"]]:\n        print(host_id, host)\n\n\n\nUse instead:\n\n\ndef show(host_id=10.11):\n    for inner_host_id, host in [[12.13, \"Venus\"], [14.15, \"Mars\"]]:\n        print(host_id, inner_host_id, host)\n\n# Idiom PLR1711 (useless-return)\n\nDefinition: Checks for functions that end with an unnecessary return or\nreturn None, and contain no other return statements.\n\nRationale: Python implicitly assumes a None return at the end of a function, making\nit unnecessary to explicitly write return None.\n\nExample:\ndef f():\n    print(5)\n    return None\n\n\n\nUse instead:\n\n\ndef f():\n    print(5)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/N816-N817-N818-N999",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom N816 (mixed-case-variable-in-global-scope)\n\nDefinition: Checks for global variable names that follow the mixedCase convention.\n\nRationale: PEP 8 recommends that global variable names should be lower case and\nseparated by underscores (also known as snake_case).\n\n\n\nGlobal Variable Names\n(Let\u2019s hope that these variables are meant for use inside one module\nonly.) The conventions are about the same as those for functions.\nModules that are designed for use via from M import * should use the\nall mechanism to prevent exporting globals, or use the older\nconvention of prefixing such globals with an underscore (which you might\nwant to do to indicate these globals are \u201cmodule non-public\u201d).\nFunction and Variable Names\nFunction names should be lowercase, with words separated by underscores\nas necessary to improve readability.\nVariable names follow the same convention as function names.\nmixedCase is allowed only in contexts where that\u2019s already the prevailing\nstyle (e.g. threading.py), to retain backwards compatibility.\n\nExample:\nmyVariable = \"hello\"\nanother_variable = \"world\"\nyet_anotherVariable = \"foo\"\n\n\n\nUse instead:\n\n\nmy_variable = \"hello\"\nanother_variable = \"world\"\nyet_another_variable = \"foo\"\n\n# Idiom N817 (camelcase-imported-as-acronym)\n\nDefinition: Checks for CamelCase imports that are aliased as acronyms.\n\nRationale: PEP 8 recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\n\nNote that this rule is distinct from camelcase-imported-as-constant\nto accommodate selective enforcement.\n\n\nAlso note that import aliases following an import convention according to the\nlint.flake8-import-conventions.aliases option are allowed.\n\nExample:\nfrom example import MyClassName as MCN\n\n\n\nUse instead:\n\n\nfrom example import MyClassName\n\n# Idiom N818 (error-suffix-on-exception-name)\n\nDefinition: Checks for custom exception definitions that omit the Error suffix.\n\nRationale: The Error suffix is recommended by PEP 8:\n\n\n\nBecause exceptions should be classes, the class naming convention\napplies here. However, you should use the suffix \"Error\" on your\nexception names (if the exception actually is an error).\n\nExample:\nclass Validation(Exception): ...\n\n\n\nUse instead:\n\n\nclass ValidationError(Exception): ...\n\n# Idiom N999 (invalid-module-name)\n\nDefinition: Checks for module names that do not follow the snake_case naming\nconvention or are otherwise invalid.\n\nRationale: PEP 8 recommends the use of the snake_case naming convention for\nmodule names:\n\n\n\nModules should have short, all-lowercase names. Underscores can be used in the\nmodule name if it improves readability. Python packages should also have short,\nall-lowercase names, although the use of underscores is discouraged.\nWhen an extension module written in C or C++ has an accompanying Python module that\nprovides a higher level (e.g. more object-oriented) interface, the C/C++ module has\na leading underscore (e.g. _socket).\n\n\n\nFurther, in order for Python modules to be importable, they must be valid\nidentifiers. As such, they cannot start with a digit, or collide with hard\nkeywords, like import or class.\n\nExample:\nInstead of example-module-name or example module name, use example_module_name.\nInstead of ExampleModule, use example_module.\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/RUF019-RUF020-RUF021-RUF022-RUF023",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom RUF019 (unnecessary-key-check)\n\nDefinition: Checks for unnecessary key checks prior to accessing a dictionary.\n\nRationale: When working with dictionaries, the get can be used to access a value\nwithout having to check if the dictionary contains the relevant key,\nreturning None if the key is not present.\n\nExample:\nif \"key\" in dct and dct[\"key\"]:\n    ...\n\n\n\nUse instead:\n\n\nif dct.get(\"key\"):\n    ...\n\n# Idiom RUF020 (never-union)\n\nDefinition: Checks for uses of typing.NoReturn and typing.Never in union types.\n\nRationale: typing.NoReturn and typing.Never are special types, used to indicate\nthat a function never returns, or that a type has no values.\n\n\nIncluding typing.NoReturn or typing.Never in a union type is redundant,\nas, e.g., typing.Never | T is equivalent to T.\n\nExample:\nfrom typing import Never\n\n\ndef func() -> Never | int: ...\n\n\n\nUse instead:\n\n\ndef func() -> int: ...\n\n# Idiom RUF021 (parenthesize-chained-operators)\n\nDefinition: Checks for chained operators where adding parentheses could improve the\nclarity of the code.\n\nRationale: and always binds more tightly than or when chaining the two together,\nbut this can be hard to remember (and sometimes surprising).\nAdding parentheses in these situations can greatly improve code readability,\nwith no change to semantics or performance.\n\n\nFor example:\n\n\na, b, c = 1, 0, 2\nx = a or b and c\n\nd, e, f = 0, 1, 2\ny = d and e or f\n\n\n\nUse instead:\n\n\na, b, c = 1, 0, 2\nx = a or (b and c)\n\nd, e, f = 0, 1, 2\ny = (d and e) or f\n\n# Idiom RUF022 (unsorted-dunder-all)\n\nDefinition: Checks for __all__ definitions that are not ordered\naccording to an \"isort-style\" sort.\n\n\nAn isort-style sort orders items first according to their casing:\nSCREAMING_SNAKE_CASE names (conventionally used for global constants)\ncome first, followed by CamelCase names (conventionally used for\nclasses), followed by anything else. Within each category,\na natural sort\nis used to order the elements.\n\nRationale: Consistency is good. Use a common convention for __all__ to make your\ncode more readable and idiomatic.\n\nExample:\nimport sys\n\n__all__ = [\n    \"b\",\n    \"c\",\n    \"a\",\n]\n\nif sys.platform == \"win32\":\n    __all__ += [\"z\", \"y\"]\n\n\n\nUse instead:\n\n\nimport sys\n\n__all__ = [\n    \"a\",\n    \"b\",\n    \"c\",\n]\n\nif sys.platform == \"win32\":\n    __all__ += [\"y\", \"z\"]\n\n# Idiom RUF023 (unsorted-dunder-slots)\n\nDefinition: Checks for __slots__ definitions that are not ordered according to a\nnatural sort.\n\nRationale: Consistency is good. Use a common convention for this special variable\nto make your code more readable and idiomatic.\n\nExample:\nclass Dog:\n    __slots__ = \"name\", \"breed\"\n\n\n\nUse instead:\n\n\nclass Dog:\n    __slots__ = \"breed\", \"name\"\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/SIM223-SIM300-SIM401-SLF001",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom SIM223 (expr-and-false)\n\nDefinition: Checks for and expressions that contain falsey values.\n\nRationale: If the expression is used as a condition, it can be replaced in-full with\nFalse.\n\n\nIn other cases, the expression can be short-circuited to the first falsey\nvalue.\n\n\nBy using False (or the first falsey value), the code is more concise\nand easier to understand, since it no longer contains redundant conditions.\n\nExample:\nif x and [] and y:\n    pass\n\na = x and [] and y\n\n\n\nUse instead:\n\n\nif False:\n    pass\n\na = x and []\n\n# Idiom SIM300 (yoda-conditions)\n\nDefinition: Checks for conditions that position a constant on the left-hand side of the\ncomparison operator, rather than the right-hand side.\n\nRationale: These conditions (sometimes referred to as \"Yoda conditions\") are less\nreadable than conditions that place the variable on the left-hand side of\nthe comparison operator.\n\n\nIn some languages, Yoda conditions are used to prevent accidental\nassignment in conditions (i.e., accidental uses of the = operator,\ninstead of the == operator). However, Python does not allow assignments\nin conditions unless using the := operator, so Yoda conditions provide\nno benefit in this regard.\n\nExample:\nif \"Foo\" == foo:\n    ...\n\n\n\nUse instead:\n\n\nif foo == \"Foo\":\n    ...\n\n# Idiom SIM401 (if-else-block-instead-of-dict-get)\n\nDefinition: Checks for if statements that can be replaced with dict.get calls.\n\nRationale: dict.get() calls can be used to replace if statements that assign a\nvalue to a variable in both branches, falling back to a default value if\nthe key is not found. When possible, using dict.get is more concise and\nmore idiomatic.\n\n\nUnder preview mode, this rule will\nalso suggest replacing if-else expressions with dict.get calls.\n\nExample:\nif \"bar\" in foo:\n    value = foo[\"bar\"]\nelse:\n    value = 0\n\n\n\nUse instead:\n\n\nvalue = foo.get(\"bar\", 0)\n\n\n\nIf preview mode is enabled:\n\n\nvalue = foo[\"bar\"] if \"bar\" in foo else 0\n\n\n\nUse instead:\n\n\nvalue = foo.get(\"bar\", 0)\n\n# Idiom SLF001 (private-member-access)\n\nDefinition: Checks for accesses on \"private\" class members.\n\nRationale: In Python, the convention is such that class members that are prefixed\nwith a single underscore, or prefixed but not suffixed with a double\nunderscore, are considered private and intended for internal use.\n\n\nUsing such \"private\" members is considered a misuse of the class, as\nthere are no guarantees that the member will be present in future\nversions, that it will have the same type, or that it will have the same\nbehavior. Instead, use the class's public interface.\n\n\nThis rule ignores accesses on dunder methods (e.g., __init__) and sunder\nmethods (e.g., _missing_).\n\nExample:\nclass Class:\n    def __init__(self):\n        self._private_member = \"...\"\n\n\nvar = Class()\nprint(var._private_member)\n\n\n\nUse instead:\n\n\nclass Class:\n    def __init__(self):\n        self.public_member = \"...\"\n\n\nvar = Class()\nprint(var.public_member)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/ASYNC221-ASYNC222-ASYNC230-ASYNC251",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom ASYNC221 (run-process-in-async-function)\n\nDefinition: Checks that async functions do not run processes with blocking methods.\n\nRationale: Blocking an async function via a blocking call will block the entire\nevent loop, preventing it from executing other tasks while waiting for the\ncall to complete, negating the benefits of asynchronous programming.\n\n\nInstead of making a blocking call, use an equivalent asynchronous library\nor function, like trio.run_process()\nor anyio.run_process().\n\nExample:\nasync def foo():\n    subprocess.run(cmd)\n\n\n\nUse instead:\n\n\nasync def foo():\n    asyncio.create_subprocess_shell(cmd)\n\n# Idiom ASYNC222 (wait-for-process-in-async-function)\n\nDefinition: Checks that async functions do not wait on processes with blocking methods.\n\nRationale: Blocking an async function via a blocking call will block the entire\nevent loop, preventing it from executing other tasks while waiting for the\ncall to complete, negating the benefits of asynchronous programming.\n\n\nInstead of making a blocking call, use an equivalent asynchronous library\nor function, like trio.to_thread.run_sync()\nor anyio.to_thread.run_sync().\n\nExample:\nasync def foo():\n    os.waitpid(0)\n\n\n\nUse instead:\n\n\ndef wait_for_process():\n    os.waitpid(0)\n\n\nasync def foo():\n    await asyncio.loop.run_in_executor(None, wait_for_process)\n\n# Idiom ASYNC230 (blocking-open-call-in-async-function)\n\nDefinition: Checks that async functions do not open files with blocking methods like open.\n\nRationale: Blocking an async function via a blocking call will block the entire\nevent loop, preventing it from executing other tasks while waiting for the\ncall to complete, negating the benefits of asynchronous programming.\n\n\nInstead of making a blocking call, use an equivalent asynchronous library\nor function.\n\nExample:\nasync def foo():\n    with open(\"bar.txt\") as f:\n        contents = f.read()\n\n\n\nUse instead:\n\n\nimport anyio\n\n\nasync def foo():\n    async with await anyio.open_file(\"bar.txt\") as f:\n        contents = await f.read()\n\n# Idiom ASYNC251 (blocking-sleep-in-async-function)\n\nDefinition: Checks that async functions do not call time.sleep.\n\nRationale: Blocking an async function via a time.sleep call will block the entire\nevent loop, preventing it from executing other tasks while waiting for the\ntime.sleep, negating the benefits of asynchronous programming.\n\n\nInstead of time.sleep, use asyncio.sleep.\n\nExample:\nasync def fetch():\n    time.sleep(1)\n\n\n\nUse instead:\n\n\nasync def fetch():\n    await asyncio.sleep(1)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/B002-B003-B004-B005-B006",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom B002 (unary-prefix-increment-decrement)\n\nDefinition: Checks for the attempted use of the unary prefix increment (++) or\ndecrement operator (--).\n\nRationale: Python does not support the unary prefix increment or decrement operator.\nWriting ++n is equivalent to +(+(n)) and writing --n is equivalent to\n-(-(n)). In both cases, it is equivalent to n.\n\nExample:\n++x\n--y\n\n\n\nUse instead:\n\n\nx += 1\ny -= 1\n\n# Idiom B003 (assignment-to-os-environ)\n\nDefinition: Checks for assignments to os.environ.\n\nRationale: In Python, os.environ is a mapping that represents the environment of the\ncurrent process.\n\n\nHowever, reassigning to os.environ does not clear the environment. Instead,\nit merely updates the os.environ for the current process. This can lead to\nunexpected behavior, especially when running the program in a subprocess.\n\n\nInstead, use os.environ.clear() to clear the environment, or use the\nenv argument of subprocess.Popen to pass a custom environment to\na subprocess.\n\nExample:\nimport os\n\nos.environ = {\"foo\": \"bar\"}\n\n\n\nUse instead:\n\n\nimport os\n\nos.environ.clear()\nos.environ[\"foo\"] = \"bar\"\n\n# Idiom B004 (unreliable-callable-check)\n\nDefinition: Checks for uses of hasattr to test if an object is callable (e.g.,\nhasattr(obj, \"__call__\")).\n\nRationale: Using hasattr is an unreliable mechanism for testing if an object is\ncallable. If obj implements a custom __getattr__, or if its __call__\nis itself not callable, you may get misleading results.\n\n\nInstead, use callable(obj) to test if obj is callable.\n\nExample:\nhasattr(obj, \"__call__\")\n\n\n\nUse instead:\n\n\ncallable(obj)\n\n# Idiom B005 (strip-with-multi-characters)\n\nDefinition: Checks for uses of multi-character strings in .strip(), .lstrip(), and\n.rstrip() calls.\n\nRationale: All characters in the call to .strip(), .lstrip(), or .rstrip() are\nremoved from the leading and trailing ends of the string. If the string\ncontains multiple characters, the reader may be misled into thinking that\na prefix or suffix is being removed, rather than a set of characters.\n\n\nIn Python 3.9 and later, you can use str.removeprefix and\nstr.removesuffix to remove an exact prefix or suffix from a string,\nrespectively, which should be preferred when possible.\n\nExample:\n\"text.txt\".strip(\".txt\")  # \"e\"\n\n\n\nUse instead:\n\n\n\"text.txt\".removesuffix(\".txt\")  # \"text\"\n\n# Idiom B006 (mutable-argument-default)\n\nDefinition: Checks for uses of mutable objects as function argument defaults.\n\nRationale: Function defaults are evaluated once, when the function is defined.\n\n\nThe same mutable object is then shared across all calls to the function.\nIf the object is modified, those modifications will persist across calls,\nwhich can lead to unexpected behavior.\n\n\nInstead, prefer to use immutable data structures, or take None as a\ndefault, and initialize a new mutable object inside the function body\nfor each call.\n\n\nArguments with immutable type annotations will be ignored by this rule.\nTypes outside of the standard library can be marked as immutable with the\nlint.flake8-bugbear.extend-immutable-calls configuration option.\n\nExample:\ndef add_to_list(item, some_list=[]):\n    some_list.append(item)\n    return some_list\n\n\nl1 = add_to_list(0)  # [0]\nl2 = add_to_list(1)  # [0, 1]\n\n\n\nUse instead:\n\n\ndef add_to_list(item, some_list=None):\n    if some_list is None:\n        some_list = []\n    some_list.append(item)\n    return some_list\n\n\nl1 = add_to_list(0)  # [0]\nl2 = add_to_list(1)  # [1]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/D409-D410-D411-D412",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom D409 (mismatched-section-underline-length)\n\nDefinition: Checks for section underlines in docstrings that do not match the length of\nthe corresponding section header.\n\nRationale: This rule enforces a consistent style for multiline numpy-style docstrings,\nand helps prevent incorrect syntax in docstrings using reStructuredText.\n\n\nMultiline numpy-style docstrings are typically composed of a summary line,\nfollowed by a blank line, followed by a series of sections. Each section\nhas a section header and a section body, and there should be a series of\nunderline characters in the line following the header. The length of the\nunderline should exactly match the length of the section header.\n\n\nThis rule enforces a consistent style for multiline numpy-style docstrings\nwith sections. If your docstring uses reStructuredText, the rule also\nhelps protect against incorrect reStructuredText syntax, which would cause\nerrors if you tried to use a tool such as Sphinx to generate documentation\nfrom the docstring.\n\n\nThis rule is enabled when using the numpy convention, and disabled\nwhen using the google or pep257 conventions.\n\nExample:\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ---\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    ---\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ---\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n\n\nUse instead:\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n# Idiom D410 (no-blank-line-after-section)\n\nDefinition: Checks for docstring sections that are not separated by a single blank\nline.\n\nRationale: This rule enforces consistency in your docstrings, and helps ensure\ncompatibility with documentation tooling.\n\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body. If a multiline numpy-style or Google-style docstring\nconsists of multiple sections, each section should be separated by a single\nblank line.\n\n\nThis rule is enabled when using the numpy and google conventions, and\ndisabled when using the pep257 convention.\n\nExample:\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n\n\nUse instead:\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n# Idiom D411 (no-blank-line-before-section)\n\nDefinition: Checks for docstring sections that are not separated by a blank line.\n\nRationale: This rule enforces consistency in numpy-style and Google-style docstrings,\nand helps ensure compatibility with documentation tooling.\n\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body. Sections should be separated by a single blank line.\n\n\nThis rule is enabled when using the numpy and google conventions, and\ndisabled when using the pep257 convention.\n\nExample:\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n\n\nUse instead:\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n# Idiom D412 (blank-lines-between-header-and-content)\n\nDefinition: Checks for docstring sections that contain blank lines between a section\nheader and a section body.\n\nRationale: This rule enforces a consistent style for multiline docstrings.\n\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body. There should be no blank lines between a section header\nand a section body.\n\nExample:\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n\n\nUse instead:\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PTH115-PTH116-PTH117-PTH118-PTH119",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PTH115 (os-readlink)\n\nDefinition: Checks for uses of os.readlink.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os. When possible, using Path object\nmethods such as Path.readlink() can improve readability over the os\nmodule's counterparts (e.g., os.readlink()).\n\n# Idiom PTH116 (os-stat)\n\nDefinition: Checks for uses of os.stat.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os. When possible, using Path object\nmethods such as Path.stat() can improve readability over the os\nmodule's counterparts (e.g., os.path.stat()).\n\n# Idiom PTH117 (os-path-isabs)\n\nDefinition: Checks for uses of os.path.isabs.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os.path. When possible, using Path object\nmethods such as Path.is_absolute() can improve readability over the os.path\nmodule's counterparts (e.g., as os.path.isabs()).\n\n# Idiom PTH118 (os-path-join)\n\nDefinition: Checks for uses of os.path.join.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os.path. When possible, using Path object\nmethods such as Path.joinpath() or the / operator can improve\nreadability over the os.path module's counterparts (e.g., os.path.join()).\n\n# Idiom PTH119 (os-path-basename)\n\nDefinition: Checks for uses of os.path.basename.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os.path. When possible, using Path object\nmethods such as Path.name can improve readability over the os.path\nmodule's counterparts (e.g., os.path.basename()).\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PERF401-PERF402-PERF403",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PERF401 (manual-list-comprehension)\n\nDefinition: Checks for for loops that can be replaced by a list comprehension.\n\nRationale: When creating a transformed list from an existing list using a for-loop,\nprefer a list comprehension. List comprehensions are more readable and\nmore performant.\n\n\nUsing the below as an example, the list comprehension is ~10% faster on\nPython 3.11, and ~25% faster on Python 3.10.\n\n\nNote that, as with all perflint rules, this is only intended as a\nmicro-optimization, and will have a negligible impact on performance in\nmost cases.\n\nExample:\noriginal = list(range(10000))\nfiltered = []\nfor i in original:\n    if i % 2:\n        filtered.append(i)\n\n\n\nUse instead:\n\n\noriginal = list(range(10000))\nfiltered = [x for x in original if x % 2]\n\n\n\nIf you're appending to an existing list, use the extend method instead:\n\n\noriginal = list(range(10000))\nfiltered.extend(x for x in original if x % 2)\n\n\n\nTake care that if the original for-loop uses an assignment expression\nas a conditional, such as if match:=re.match(\"\\d+\",\"123\"), then\nthe corresponding comprehension must wrap the assignment\nexpression in parentheses to avoid a syntax error.\n\n# Idiom PERF402 (manual-list-copy)\n\nDefinition: Checks for for loops that can be replaced by a making a copy of a list.\n\nRationale: When creating a copy of an existing list using a for-loop, prefer\nlist or list.copy instead. Making a direct copy is more readable and\nmore performant.\n\n\nUsing the below as an example, the list-based copy is ~2x faster on\nPython 3.11.\n\n\nNote that, as with all perflint rules, this is only intended as a\nmicro-optimization, and will have a negligible impact on performance in\nmost cases.\n\nExample:\noriginal = list(range(10000))\nfiltered = []\nfor i in original:\n    filtered.append(i)\n\n\n\nUse instead:\n\n\noriginal = list(range(10000))\nfiltered = list(original)\n\n# Idiom PERF403 (manual-dict-comprehension)\n\nDefinition: Checks for for loops that can be replaced by a dictionary comprehension.\n\nRationale: When creating or extending a dictionary in a for-loop, prefer a dictionary\ncomprehension. Comprehensions are more readable and more performant.\n\n\nFor example, when comparing {x: x for x in list(range(1000))} to the for\nloop version, the comprehension is ~10% faster on Python 3.11.\n\n\nNote that, as with all perflint rules, this is only intended as a\nmicro-optimization, and will have a negligible impact on performance in\nmost cases.\n\nExample:\npairs = ((\"a\", 1), (\"b\", 2))\nresult = {}\nfor x, y in pairs:\n    if y % 2:\n        result[x] = y\n\n\n\nUse instead:\n\n\npairs = ((\"a\", 1), (\"b\", 2))\nresult = {x: y for x, y in pairs if y % 2}\n\n\n\nIf you're appending to an existing dictionary, use the update method instead:\n\n\npairs = ((\"a\", 1), (\"b\", 2))\nresult.update({x: y for x, y in pairs if y % 2})\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/INT001-INT002-INT003-FA100-FA102",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom INT001 (f-string-in-get-text-func-call)\n\nDefinition: Checks for f-strings in gettext function calls.\n\nRationale: In the gettext API, the gettext function (often aliased to _) returns\na translation of its input argument by looking it up in a translation\ncatalog.\n\n\nCalling gettext with an f-string as its argument can cause unexpected\nbehavior. Since the f-string is resolved before the function call, the\ntranslation catalog will look up the formatted string, rather than the\nf-string template.\n\n\nInstead, format the value returned by the function call, rather than\nits argument.\n\nExample:\nfrom gettext import gettext as _\n\nname = \"Maria\"\n_(f\"Hello, {name}!\")  # Looks for \"Hello, Maria!\".\n\n\n\nUse instead:\n\n\nfrom gettext import gettext as _\n\nname = \"Maria\"\n_(\"Hello, %s!\") % name  # Looks for \"Hello, %s!\".\n\n# Idiom INT002 (format-in-get-text-func-call)\n\nDefinition: Checks for str.format calls in gettext function calls.\n\nRationale: In the gettext API, the gettext function (often aliased to _) returns\na translation of its input argument by looking it up in a translation\ncatalog.\n\n\nCalling gettext with a formatted string as its argument can cause\nunexpected behavior. Since the formatted string is resolved before the\nfunction call, the translation catalog will look up the formatted string,\nrather than the str.format-style template.\n\n\nInstead, format the value returned by the function call, rather than\nits argument.\n\nExample:\nfrom gettext import gettext as _\n\nname = \"Maria\"\n_(\"Hello, {}!\".format(name))  # Looks for \"Hello, Maria!\".\n\n\n\nUse instead:\n\n\nfrom gettext import gettext as _\n\nname = \"Maria\"\n_(\"Hello, %s!\") % name  # Looks for \"Hello, %s!\".\n\n# Idiom INT003 (printf-in-get-text-func-call)\n\nDefinition: Checks for printf-style formatted strings in gettext function calls.\n\nRationale: In the gettext API, the gettext function (often aliased to _) returns\na translation of its input argument by looking it up in a translation\ncatalog.\n\n\nCalling gettext with a formatted string as its argument can cause\nunexpected behavior. Since the formatted string is resolved before the\nfunction call, the translation catalog will look up the formatted string,\nrather than the printf-style template.\n\n\nInstead, format the value returned by the function call, rather than\nits argument.\n\nExample:\nfrom gettext import gettext as _\n\nname = \"Maria\"\n_(\"Hello, %s!\" % name)  # Looks for \"Hello, Maria!\".\n\n\n\nUse instead:\n\n\nfrom gettext import gettext as _\n\nname = \"Maria\"\n_(\"Hello, %s!\") % name  # Looks for \"Hello, %s!\".\n\n# Idiom FA100 (future-rewritable-type-annotation)\n\nDefinition: Checks for missing from __future__ import annotations imports upon\ndetecting type annotations that can be written more succinctly under\nPEP 563.\n\nRationale: PEP 585 enabled the use of a number of convenient type annotations, such as\nlist[str] instead of List[str]. However, these annotations are only\navailable on Python 3.9 and higher, unless the from __future__ import annotations\nimport is present.\n\n\nSimilarly, PEP 604 enabled the use of the | operator for unions, such as\nstr | None instead of Optional[str]. However, these annotations are only\navailable on Python 3.10 and higher, unless the from __future__ import annotations\nimport is present.\n\n\nBy adding the __future__ import, the pyupgrade rules can automatically\nmigrate existing code to use the new syntax, even for older Python versions.\nThis rule thus pairs well with pyupgrade and with Ruff's pyupgrade rules.\n\n\nThis rule respects the target-version setting. For example, if your\nproject targets Python 3.10 and above, adding from __future__ import annotations\ndoes not impact your ability to leverage PEP 604-style unions (e.g., to\nconvert Optional[str] to str | None). As such, this rule will only\nflag such usages if your project targets Python 3.9 or below.\n\nExample:\nfrom typing import List, Dict, Optional\n\n\ndef func(obj: Dict[str, Optional[int]]) -> None: ...\n\n\n\nUse instead:\n\n\nfrom __future__ import annotations\n\nfrom typing import List, Dict, Optional\n\n\ndef func(obj: Dict[str, Optional[int]]) -> None: ...\n\n\n\nAfter running the additional pyupgrade rules:\n\n\nfrom __future__ import annotations\n\n\ndef func(obj: dict[str, int | None]) -> None: ...\n\n# Idiom FA102 (future-required-type-annotation)\n\nDefinition: Checks for uses of PEP 585- and PEP 604-style type annotations in Python\nmodules that lack the required from __future__ import annotations import\nfor compatibility with older Python versions.\n\nRationale: Using PEP 585 and PEP 604 style annotations without a from __future__ import annotations import will cause runtime errors on Python versions prior to\n3.9 and 3.10, respectively.\n\n\nBy adding the __future__ import, the interpreter will no longer interpret\nannotations at evaluation time, making the code compatible with both past\nand future Python versions.\n\n\nThis rule respects the target-version setting. For example, if your\nproject targets Python 3.10 and above, adding from __future__ import annotations\ndoes not impact your ability to leverage PEP 604-style unions (e.g., to\nconvert Optional[str] to str | None). As such, this rule will only\nflag such usages if your project targets Python 3.9 or below.\n\nExample:\ndef func(obj: dict[str, int | None]) -> None: ...\n\n\n\nUse instead:\n\n\nfrom __future__ import annotations\n\n\ndef func(obj: dict[str, int | None]) -> None: ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/E714-E721-E722-E731",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom E714 (not-is-test)\n\nDefinition: Checks for identity comparisons using not {foo} is {bar}.\n\nRationale: According to PEP8, testing for an object's identity with is not is more\nreadable.\n\nExample:\nif not X is Y:\n    pass\nZ = not X.B is Y\n\n\n\nUse instead:\n\n\nif X is not Y:\n    pass\nZ = X.B is not Y\n\n# Idiom E721 (type-comparison)\n\nDefinition: Checks for object type comparisons using == and other comparison\noperators.\n\nRationale: Unlike a direct type comparison, isinstance will also check if an object\nis an instance of a class or a subclass thereof.\n\n\nIf you want to check for an exact type match, use is or is not.\n\nExample:\nif type(obj) == type(1):\n    pass\n\nif type(obj) == int:\n    pass\n\n\n\nUse instead:\n\n\nif isinstance(obj, int):\n    pass\n\n# Idiom E722 (bare-except)\n\nDefinition: Checks for bare except catches in try-except statements.\n\nRationale: A bare except catches BaseException which includes\nKeyboardInterrupt, SystemExit, Exception, and others. Catching\nBaseException can make it hard to interrupt the program (e.g., with\nCtrl-C) and can disguise other problems.\n\nExample:\ntry:\n    raise KeyboardInterrupt(\"You probably don't mean to break CTRL-C.\")\nexcept:\n    print(\"But a bare `except` will ignore keyboard interrupts.\")\n\n\n\nUse instead:\n\n\ntry:\n    do_something_that_might_break()\nexcept MoreSpecificException as e:\n    handle_error(e)\n\n\n\nIf you actually need to catch an unknown error, use Exception which will\ncatch regular program errors but not important system exceptions.\n\n\ndef run_a_function(some_other_fn):\n    try:\n        some_other_fn()\n    except Exception as e:\n        print(f\"How exceptional! {e}\")\n\n# Idiom E731 (lambda-assignment)\n\nDefinition: Checks for lambda expressions which are assigned to a variable.\n\nRationale: Per PEP 8, you should \"Always use a def statement instead of an assignment\nstatement that binds a lambda expression directly to an identifier.\"\n\n\nUsing a def statement leads to better tracebacks, and the assignment\nitself negates the primary benefit of using a lambda expression (i.e.,\nthat it can be embedded inside another expression).\n\nExample:\nf = lambda x: 2 * x\n\n\n\nUse instead:\n\n\ndef f(x):\n    return 2 * x\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLC2401-PLC2403-PLC2701-PLC2801-PLC3002",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLC2401 (non-ascii-name)\n\nDefinition: Checks for the use of non-ASCII characters in variable names.\n\nRationale: The use of non-ASCII characters in variable names can cause confusion\nand compatibility issues (see: PEP 672).\n\nExample:\n\u00e1pple_count: int\n\n\n\nUse instead:\n\n\napple_count: int\n\n# Idiom PLC2403 (non-ascii-import-name)\n\nDefinition: Checks for the use of non-ASCII characters in import statements.\n\nRationale: The use of non-ASCII characters in import statements can cause confusion\nand compatibility issues (see: PEP 672).\n\nExample:\nimport b\u00e1r\n\n\n\nUse instead:\n\n\nimport bar\n\n\n\nIf the module is third-party, use an ASCII-only alias:\n\n\nimport b\u00e1r as bar\n\n# Idiom PLC2701 (import-private-name)\n\nDefinition: Checks for import statements that import a private name (a name starting\nwith an underscore _) from another module.\n\nRationale: PEP 8 states that names starting with an underscore are private. Thus,\nthey are not intended to be used outside of the module in which they are\ndefined.\n\n\nFurther, as private imports are not considered part of the public API, they\nare prone to unexpected changes, especially outside of semantic versioning.\n\n\nInstead, consider using the public API of the module.\n\n\nThis rule ignores private name imports that are exclusively used in type\nannotations. Ideally, types would be public; however, this is not always\npossible when using third-party libraries.\n\nExample:\nfrom foo import _bar\n\n# Idiom PLC2801 (unnecessary-dunder-call)\n\nDefinition: Checks for explicit use of dunder methods, like __str__ and __add__.\n\nRationale: Dunder names are not meant to be called explicitly and, in most cases, can\nbe replaced with builtins or operators.\n\nExample:\nthree = (3.0).__str__()\ntwelve = \"1\".__add__(\"2\")\n\n\ndef is_greater_than_two(x: int) -> bool:\n    return x.__gt__(2)\n\n\n\nUse instead:\n\n\nthree = str(3.0)\ntwelve = \"1\" + \"2\"\n\n\ndef is_greater_than_two(x: int) -> bool:\n    return x > 2\n\n# Idiom PLC3002 (unnecessary-direct-lambda-call)\n\nDefinition: Checks for unnecessary direct calls to lambda expressions.\n\nRationale: Calling a lambda expression directly is unnecessary. The expression can be\nexecuted inline instead to improve readability.\n\nExample:\narea = (lambda r: 3.14 * r**2)(radius)\n\n\n\nUse instead:\n\n\narea = 3.14 * radius**2\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/B027-B028-B029-B030-B031",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom B027 (empty-method-without-abstract-decorator)\n\nDefinition: Checks for empty methods in abstract base classes without an abstract\ndecorator.\n\nRationale: Empty methods in abstract base classes without an abstract decorator may be\nbe indicative of a mistake. If the method is meant to be abstract, add an\n@abstractmethod decorator to the method.\n\nExample:\nfrom abc import ABC\n\n\nclass Foo(ABC):\n    def method(self): ...\n\n\n\nUse instead:\n\n\nfrom abc import ABC, abstractmethod\n\n\nclass Foo(ABC):\n    @abstractmethod\n    def method(self): ...\n\n# Idiom B028 (no-explicit-stacklevel)\n\nDefinition: Checks for warnings.warn calls without an explicit stacklevel keyword\nargument.\n\nRationale: The warnings.warn method uses a stacklevel of 1 by default, which\nwill output a stack frame of the line on which the \"warn\" method\nis called. Setting it to a higher number will output a stack frame\nfrom higher up the stack.\n\n\nIt's recommended to use a stacklevel of 2 or higher, to give the caller\nmore context about the warning.\n\nExample:\nwarnings.warn(\"This is a warning\")\n\n\n\nUse instead:\n\n\nwarnings.warn(\"This is a warning\", stacklevel=2)\n\n# Idiom B029 (except-with-empty-tuple)\n\nDefinition: Checks for exception handlers that catch an empty tuple.\n\nRationale: An exception handler that catches an empty tuple will not catch anything,\nand is indicative of a mistake. Instead, add exceptions to the except\nclause.\n\nExample:\ntry:\n    1 / 0\nexcept ():\n    ...\n\n\n\nUse instead:\n\n\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n    ...\n\n# Idiom B030 (except-with-non-exception-classes)\n\nDefinition: Checks for exception handlers that catch non-exception classes.\n\nRationale: Catching classes that do not inherit from BaseException will raise a\nTypeError.\n\nExample:\ntry:\n    1 / 0\nexcept 1:\n    ...\n\n\n\nUse instead:\n\n\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n    ...\n\n# Idiom B031 (reuse-of-groupby-generator)\n\nDefinition: Checks for multiple usage of the generator returned from\nitertools.groupby().\n\nRationale: Using the generator more than once will do nothing on the second usage.\nIf that data is needed later, it should be stored as a list.\n\nExample:\nimport itertools\n\nfor name, group in itertools.groupby(data):\n    for _ in range(5):\n        do_something_with_the_group(group)\n\n\n\nUse instead:\n\n\nimport itertools\n\nfor name, group in itertools.groupby(data):\n    values = list(group)\n    for _ in range(5):\n        do_something_with_the_group(values)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/FURB132-FURB136-FURB140-FURB142-FURB145",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom FURB132 (check-and-remove-from-set)\n\nDefinition: Checks for uses of set.remove that can be replaced with set.discard.\n\nRationale: If an element should be removed from a set if it is present, it is more\nsuccinct and idiomatic to use discard.\n\nExample:\nnums = {123, 456}\n\nif 123 in nums:\n    nums.remove(123)\n\n\n\nUse instead:\n\n\nnums = {123, 456}\n\nnums.discard(123)\n\n# Idiom FURB136 (if-expr-min-max)\n\nDefinition: Checks for if expressions that can be replaced with min() or max()\ncalls.\n\nRationale: An if expression that selects the lesser or greater of two\nsub-expressions can be replaced with a min() or max() call\nrespectively. When possible, prefer min() and max(), as they're more\nconcise and readable than the equivalent if expression.\n\nExample:\nhighest_score = score1 if score1 > score2 else score2\n\n\n\nUse instead:\n\n\nhighest_score = max(score2, score1)\n\n# Idiom FURB140 (reimplemented-starmap)\n\nDefinition: Checks for generator expressions, list and set comprehensions that can\nbe replaced with itertools.starmap.\n\nRationale: When unpacking values from iterators to pass them directly to\na function, prefer itertools.starmap.\n\n\nUsing itertools.starmap is more concise and readable. Furthermore, it is\nmore efficient than generator expressions, and in some versions of Python,\nit is more efficient than comprehensions.\n\nExample:\nall(predicate(a, b) for a, b in some_iterable)\n\n\n\nUse instead:\n\n\nfrom itertools import starmap\n\n\nall(starmap(predicate, some_iterable))\n\n# Idiom FURB142 (for-loop-set-mutations)\n\nDefinition: Checks for code that updates a set with the contents of an iterable by\nusing a for loop to call .add() or .discard() on each element\nseparately.\n\nRationale: When adding or removing a batch of elements to or from a set, it's more\nidiomatic to use a single method call rather than adding or removing\nelements one by one.\n\nExample:\ns = set()\n\nfor x in (1, 2, 3):\n    s.add(x)\n\nfor x in (1, 2, 3):\n    s.discard(x)\n\n\n\nUse instead:\n\n\ns = set()\n\ns.update((1, 2, 3))\ns.difference_update((1, 2, 3))\n\n# Idiom FURB145 (slice-copy)\n\nDefinition: Checks for unbounded slice expressions to copy a list.\n\nRationale: The list.copy method is more readable and consistent with copying other\ntypes.\n\nExample:\na = [1, 2, 3]\nb = a[:]\n\n\n\nUse instead:\n\n\na = [1, 2, 3]\nb = a.copy()\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/SIM211-SIM212-SIM220-SIM221-SIM222",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom SIM211 (if-expr-with-false-true)\n\nDefinition: Checks for if expressions that can be replaced by negating a given\ncondition.\n\nRationale: if expressions that evaluate to False for a truthy condition and True\nfor a falsey condition can be replaced with not operators, which are more\nconcise and readable.\n\nExample:\nFalse if a else True\n\n\n\nUse instead:\n\n\nnot a\n\n# Idiom SIM212 (if-expr-with-twisted-arms)\n\nDefinition: Checks for if expressions that check against a negated condition.\n\nRationale: if expressions that check against a negated condition are more difficult\nto read than if expressions that check against the condition directly.\n\nExample:\nb if not a else a\n\n\n\nUse instead:\n\n\na if a else b\n\n# Idiom SIM220 (expr-and-not-expr)\n\nDefinition: Checks for and expressions that include both an expression and its\nnegation.\n\nRationale: An and expression that includes both an expression and its negation will\nalways evaluate to False.\n\nExample:\nx and not x\n\n# Idiom SIM221 (expr-or-not-expr)\n\nDefinition: Checks for or expressions that include both an expression and its\nnegation.\n\nRationale: An or expression that includes both an expression and its negation will\nalways evaluate to True.\n\nExample:\nx or not x\n\n# Idiom SIM222 (expr-or-true)\n\nDefinition: Checks for or expressions that contain truthy values.\n\nRationale: If the expression is used as a condition, it can be replaced in-full with\nTrue.\n\n\nIn other cases, the expression can be short-circuited to the first truthy\nvalue.\n\n\nBy using True (or the first truthy value), the code is more concise\nand easier to understand, since it no longer contains redundant conditions.\n\nExample:\nif x or [1] or y:\n    pass\n\na = x or [1] or y\n\n\n\nUse instead:\n\n\nif True:\n    pass\n\na = x or [1]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PYI006-PYI007-PYI008-PYI009-PYI010",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PYI006 (bad-version-info-comparison)\n\nDefinition: Checks for uses of comparators other than < and >= for\nsys.version_info checks. All other comparators, such\nas >, <=, and ==, are banned.\n\nRationale: Comparing sys.version_info with == or <= has unexpected behavior\nand can lead to bugs.\n\n\nFor example, sys.version_info > (3, 8, 1) will resolve to True if your\nPython version is 3.8.1; meanwhile, sys.version_info <= (3, 8) will not\nresolve to True if your Python version is 3.8.10:\n\n\n>>> import sys\n>>> print(sys.version_info)\nsys.version_info(major=3, minor=8, micro=10, releaselevel='final', serial=0)\n>>> print(sys.version_info > (3, 8))\nTrue\n>>> print(sys.version_info == (3, 8))\nFalse\n>>> print(sys.version_info <= (3, 8))\nFalse\n>>> print(sys.version_info in (3, 8))\nFalse\n\nExample:\nimport sys\n\nif sys.version_info > (3, 8): ...\n\n\n\nUse instead:\n\n\nimport sys\n\nif sys.version_info >= (3, 9): ...\n\n# Idiom PYI007 (unrecognized-platform-check)\n\nDefinition: Check for unrecognized sys.platform checks. Platform checks should be\nsimple string comparisons.\n\n\nNote: this rule is only enabled in .pyi stub files.\n\nRationale: Some sys.platform checks are too complex for type checkers to\nunderstand, and thus result in incorrect inferences by these tools.\nsys.platform checks should be simple string comparisons, like\nif sys.platform == \"linux\".\n\nExample:\nif sys.platform.startswith(\"linux\"):\n    # Linux specific definitions\n    ...\nelse:\n    # Posix specific definitions\n    ...\n\n\n\nInstead, use a simple string comparison, such as == or !=:\n\n\nif sys.platform == \"linux\":\n    # Linux specific definitions\n    ...\nelse:\n    # Posix specific definitions\n    ...\n\n# Idiom PYI008 (unrecognized-platform-name)\n\nDefinition: Check for unrecognized platform names in sys.platform checks.\n\n\nNote: this rule is only enabled in .pyi stub files.\n\nRationale: If a sys.platform check compares to a platform name outside of a\nsmall set of known platforms (e.g. \"linux\", \"win32\", etc.), it's likely\na typo or a platform name that is not recognized by type checkers.\n\n\nThe list of known platforms is: \"linux\", \"win32\", \"cygwin\", \"darwin\".\n\nExample:\nif sys.platform == \"linus\": ...\n\n\n\nUse instead:\n\n\nif sys.platform == \"linux\": ...\n\n# Idiom PYI009 (pass-statement-stub-body)\n\nDefinition: Checks for pass statements in empty stub bodies.\n\nRationale: For stylistic consistency, ... should always be used rather than pass\nin stub files.\n\nExample:\ndef foo(bar: int) -> list[int]: pass\n\n\n\nUse instead:\n\n\ndef foo(bar: int) -> list[int]: ...\n\n# Idiom PYI010 (non-empty-stub-body)\n\nDefinition: Checks for non-empty function stub bodies.\n\nRationale: Stub files are never executed at runtime; they should be thought of as\n\"data files\" for type checkers or IDEs. Function bodies are redundant\nfor this purpose.\n\nExample:\ndef double(x: int) -> int:\n    return x * 2\n\n\n\nUse instead:\n\n\ndef double(x: int) -> int: ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/EM101-EM102-EM103-T100-CPY001",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom EM101 (raw-string-in-exception)\n\nDefinition: Checks for the use of string literals in exception constructors.\n\nRationale: Python includes the raise in the default traceback (and formatters\nlike Rich and IPython do too).\n\n\nBy using a string literal, the error message will be duplicated in the\ntraceback, which can make the traceback less readable.\n\nExample:\nGiven:\n\n\nraise RuntimeError(\"'Some value' is incorrect\")\n\n\n\nPython will produce a traceback like:\n\n\nTraceback (most recent call last):\n  File \"tmp.py\", line 2, in <module>\n    raise RuntimeError(\"'Some value' is incorrect\")\nRuntimeError: 'Some value' is incorrect\n\n\n\nInstead, assign the string to a variable:\n\n\nmsg = \"'Some value' is incorrect\"\nraise RuntimeError(msg)\n\n\n\nWhich will produce a traceback like:\n\n\nTraceback (most recent call last):\n  File \"tmp.py\", line 3, in <module>\n    raise RuntimeError(msg)\nRuntimeError: 'Some value' is incorrect\n\n# Idiom EM102 (f-string-in-exception)\n\nDefinition: Checks for the use of f-strings in exception constructors.\n\nRationale: Python includes the raise in the default traceback (and formatters\nlike Rich and IPython do too).\n\n\nBy using an f-string, the error message will be duplicated in the\ntraceback, which can make the traceback less readable.\n\nExample:\nGiven:\n\n\nsub = \"Some value\"\nraise RuntimeError(f\"{sub!r} is incorrect\")\n\n\n\nPython will produce a traceback like:\n\n\nTraceback (most recent call last):\n  File \"tmp.py\", line 2, in <module>\n    raise RuntimeError(f\"{sub!r} is incorrect\")\nRuntimeError: 'Some value' is incorrect\n\n\n\nInstead, assign the string to a variable:\n\n\nsub = \"Some value\"\nmsg = f\"{sub!r} is incorrect\"\nraise RuntimeError(msg)\n\n\n\nWhich will produce a traceback like:\n\n\nTraceback (most recent call last):\n  File \"tmp.py\", line 3, in <module>\n    raise RuntimeError(msg)\nRuntimeError: 'Some value' is incorrect\n\n# Idiom EM103 (dot-format-in-exception)\n\nDefinition: Checks for the use of .format calls on string literals in exception\nconstructors.\n\nRationale: Python includes the raise in the default traceback (and formatters\nlike Rich and IPython do too).\n\n\nBy using a .format call, the error message will be duplicated in the\ntraceback, which can make the traceback less readable.\n\nExample:\nGiven:\n\n\nsub = \"Some value\"\nraise RuntimeError(\"'{}' is incorrect\".format(sub))\n\n\n\nPython will produce a traceback like:\n\n\nTraceback (most recent call last):\n  File \"tmp.py\", line 2, in <module>\n    raise RuntimeError(\"'{}' is incorrect\".format(sub))\nRuntimeError: 'Some value' is incorrect\n\n\n\nInstead, assign the string to a variable:\n\n\nsub = \"Some value\"\nmsg = \"'{}' is incorrect\".format(sub)\nraise RuntimeError(msg)\n\n\n\nWhich will produce a traceback like:\n\n\nTraceback (most recent call last):\n  File \"tmp.py\", line 3, in <module>\n    raise RuntimeError(msg)\nRuntimeError: 'Some value' is incorrect\n\n# Idiom T100 (debugger)\n\nDefinition: Checks for the presence of debugger calls and imports.\n\nRationale: Debugger calls and imports should be used for debugging purposes only. The\npresence of a debugger call or import in production code is likely a\nmistake and may cause unintended behavior, such as exposing sensitive\ninformation or causing the program to hang.\n\n\nInstead, consider using a logging library to log information about the\nprogram's state, and writing tests to verify that the program behaves\nas expected.\n\nExample:\ndef foo():\n    breakpoint()\n\n# Idiom CPY001 (missing-copyright-notice)\n\nDefinition: Checks for the absence of copyright notices within Python files.\n\n\nNote that this check only searches within the first 4096 bytes of the file.\n\nRationale: In some codebases, it's common to have a license header at the top of every\nfile. This rule ensures that the license header is present.\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/YTT203-YTT204-YTT301-YTT302-YTT303",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom YTT203 (sys-version-info1-cmp-int)\n\nDefinition: Checks for comparisons that test sys.version_info[1] against an integer.\n\nRationale: Comparisons based on the current minor version number alone can cause\nsubtle bugs and would likely lead to unintended effects if the Python\nmajor version number were ever incremented (e.g., to Python 4).\n\n\nInstead, compare sys.version_info to a tuple, including the major and\nminor version numbers, to future-proof the code.\n\nExample:\nimport sys\n\nif sys.version_info[1] < 7:\n    print(\"Python 3.6 or earlier.\")  # This will be printed on Python 4.0.\n\n\n\nUse instead:\n\n\nimport sys\n\nif sys.version_info < (3, 7):\n    print(\"Python 3.6 or earlier.\")\n\n# Idiom YTT204 (sys-version-info-minor-cmp-int)\n\nDefinition: Checks for comparisons that test sys.version_info.minor against an integer.\n\nRationale: Comparisons based on the current minor version number alone can cause\nsubtle bugs and would likely lead to unintended effects if the Python\nmajor version number were ever incremented (e.g., to Python 4).\n\n\nInstead, compare sys.version_info to a tuple, including the major and\nminor version numbers, to future-proof the code.\n\nExample:\nimport sys\n\nif sys.version_info.minor < 7:\n    print(\"Python 3.6 or earlier.\")  # This will be printed on Python 4.0.\n\n\n\nUse instead:\n\n\nimport sys\n\nif sys.version_info < (3, 7):\n    print(\"Python 3.6 or earlier.\")\n\n# Idiom YTT301 (sys-version0)\n\nDefinition: Checks for uses of sys.version[0].\n\nRationale: If the current major or minor version consists of multiple digits,\nsys.version[0] will select the first digit of the major version number\nonly (e.g., \"10.2\" would evaluate to \"1\"). This is likely unintended,\nand can lead to subtle bugs if the version string is used to test against a\nmajor version number.\n\n\nInstead, use sys.version_info.major to access the current major version\nnumber.\n\nExample:\nimport sys\n\nsys.version[0]  # If using Python 10, this evaluates to \"1\".\n\n\n\nUse instead:\n\n\nimport sys\n\nf\"{sys.version_info.major}\"  # If using Python 10, this evaluates to \"10\".\n\n# Idiom YTT302 (sys-version-cmp-str10)\n\nDefinition: Checks for comparisons that test sys.version against string literals,\nsuch that the comparison would fail if the major version number were\never incremented to Python 10 or higher.\n\nRationale: Comparing sys.version to a string is error-prone and may cause subtle\nbugs, as the comparison will be performed lexicographically, not\nsemantically.\n\n\nInstead, use sys.version_info to access the current major and minor\nversion numbers as a tuple, which can be compared to other tuples\nwithout issue.\n\nExample:\nimport sys\n\nsys.version >= \"3\"  # `False` on Python 10.\n\n\n\nUse instead:\n\n\nimport sys\n\nsys.version_info >= (3,)  # `True` on Python 10.\n\n# Idiom YTT303 (sys-version-slice1)\n\nDefinition: Checks for uses of sys.version[:1].\n\nRationale: If the major version number consists of more than one digit, this will\nselect the first digit of the major version number only (e.g., \"10.0\"\nwould evaluate to \"1\"). This is likely unintended, and can lead to subtle\nbugs in future versions of Python if the version string is used to test\nagainst a specific major version number.\n\n\nInstead, use sys.version_info.major to access the current major version\nnumber.\n\nExample:\nimport sys\n\nsys.version[:1]  # If using Python 10, this evaluates to \"1\".\n\n\n\nUse instead:\n\n\nimport sys\n\nf\"{sys.version_info.major}\"  # If using Python 10, this evaluates to \"10\".\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/S504-S505-S506-S507-S508",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom S504 (ssl-with-no-version)\n\nDefinition: Checks for calls to ssl.wrap_socket() without an ssl_version.\n\nRationale: This method is known to provide a default value that maximizes\ncompatibility, but permits use of insecure protocols.\n\nExample:\nimport ssl\n\nssl.wrap_socket()\n\n\n\nUse instead:\n\n\nimport ssl\n\nssl.wrap_socket(ssl_version=ssl.PROTOCOL_TLSv1_2)\n\n# Idiom S505 (weak-cryptographic-key)\n\nDefinition: Checks for uses of cryptographic keys with vulnerable key sizes.\n\nRationale: Small keys are easily breakable. For DSA and RSA, keys should be at least\n2048 bits long. For EC, keys should be at least 224 bits long.\n\nExample:\nfrom cryptography.hazmat.primitives.asymmetric import dsa, ec\n\ndsa.generate_private_key(key_size=512)\nec.generate_private_key(curve=ec.SECT163K1())\n\n\n\nUse instead:\n\n\nfrom cryptography.hazmat.primitives.asymmetric import dsa, ec\n\ndsa.generate_private_key(key_size=4096)\nec.generate_private_key(curve=ec.SECP384R1())\n\n# Idiom S506 (unsafe-yaml-load)\n\nDefinition: Checks for uses of the yaml.load function.\n\nRationale: Running the yaml.load function over untrusted YAML files is insecure, as\nyaml.load allows for the creation of arbitrary Python objects, which can\nthen be used to execute arbitrary code.\n\n\nInstead, consider using yaml.safe_load, which allows for the creation of\nsimple Python objects like integers and lists, but prohibits the creation of\nmore complex objects like functions and classes.\n\nExample:\nimport yaml\n\nyaml.load(untrusted_yaml)\n\n\n\nUse instead:\n\n\nimport yaml\n\nyaml.safe_load(untrusted_yaml)\n\n# Idiom S507 (ssh-no-host-key-verification)\n\nDefinition: Checks for uses of policies disabling SSH verification in Paramiko.\n\nRationale: By default, Paramiko checks the identity of the remote host when establishing\nan SSH connection. Disabling the verification might lead to the client\nconnecting to a malicious host, without the client knowing.\n\nExample:\nfrom paramiko import client\n\nssh_client = client.SSHClient()\nssh_client.set_missing_host_key_policy(client.AutoAddPolicy)\n\n\n\nUse instead:\n\n\nfrom paramiko import client\n\nssh_client = client.SSHClient()\nssh_client.set_missing_host_key_policy(client.RejectPolicy)\n\n# Idiom S508 (snmp-insecure-version)\n\nDefinition: Checks for uses of SNMPv1 or SNMPv2.\n\nRationale: The SNMPv1 and SNMPv2 protocols are considered insecure as they do\nnot support encryption. Instead, prefer SNMPv3, which supports\nencryption.\n\nExample:\nfrom pysnmp.hlapi import CommunityData\n\nCommunityData(\"public\", mpModel=0)\n\n\n\nUse instead:\n\n\nfrom pysnmp.hlapi import CommunityData\n\nCommunityData(\"public\", mpModel=2)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/S303-S304-S305-S306-S307",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom S303 (suspicious-insecure-hash-usage)\n\nDefinition: Checks for uses of weak or broken cryptographic hash functions.\n\nRationale: Weak or broken cryptographic hash functions may be susceptible to\ncollision attacks (where two different inputs produce the same hash) or\npre-image attacks (where an attacker can find an input that produces a\ngiven hash). This can lead to security vulnerabilities in applications\nthat rely on these hash functions.\n\n\nAvoid using weak or broken cryptographic hash functions in security\ncontexts. Instead, use a known secure hash function such as SHA-256.\n\n\nIn preview, this rule will also flag references to insecure hash functions.\n\nExample:\nfrom cryptography.hazmat.primitives import hashes\n\ndigest = hashes.Hash(hashes.MD5())\ndigest.update(b\"Hello, world!\")\ndigest.finalize()\n\n\n\nUse instead:\n\n\nfrom cryptography.hazmat.primitives import hashes\n\ndigest = hashes.Hash(hashes.SHA256())\ndigest.update(b\"Hello, world!\")\ndigest.finalize()\n\n# Idiom S304 (suspicious-insecure-cipher-usage)\n\nDefinition: Checks for uses of weak or broken cryptographic ciphers.\n\nRationale: Weak or broken cryptographic ciphers may be susceptible to attacks that\nallow an attacker to decrypt ciphertext without knowing the key or\notherwise compromise the security of the cipher, such as forgeries.\n\n\nUse strong, modern cryptographic ciphers instead of weak or broken ones.\n\n\nIn preview, this rule will also flag references to insecure ciphers.\n\nExample:\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms\n\nalgorithm = algorithms.ARC4(key)\ncipher = Cipher(algorithm, mode=None)\nencryptor = cipher.encryptor()\n\n\n\nUse instead:\n\n\nfrom cryptography.fernet import Fernet\n\nfernet = Fernet(key)\n\n# Idiom S305 (suspicious-insecure-cipher-mode-usage)\n\nDefinition: Checks for uses of weak or broken cryptographic cipher modes.\n\nRationale: Weak or broken cryptographic ciphers may be susceptible to attacks that\nallow an attacker to decrypt ciphertext without knowing the key or\notherwise compromise the security of the cipher, such as forgeries.\n\n\nUse strong, modern cryptographic ciphers instead of weak or broken ones.\n\n\nIn preview, this rule will also flag references to insecure cipher modes.\n\nExample:\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\nalgorithm = algorithms.ARC4(key)\ncipher = Cipher(algorithm, mode=modes.ECB(iv))\nencryptor = cipher.encryptor()\n\n\n\nUse instead:\n\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\nalgorithm = algorithms.ARC4(key)\ncipher = Cipher(algorithm, mode=modes.CTR(iv))\nencryptor = cipher.encryptor()\n\n# Idiom S306 (suspicious-mktemp-usage)\n\nDefinition: Checks for uses of tempfile.mktemp.\n\nRationale: tempfile.mktemp returns a pathname of a file that does not exist at the\ntime the call is made; then, the caller is responsible for creating the\nfile and subsequently using it. This is insecure because another process\ncould create a file with the same name between the time the function\nreturns and the time the caller creates the file.\n\n\ntempfile.mktemp is deprecated in favor of tempfile.mkstemp which\ncreates the file when it is called. Consider using tempfile.mkstemp\ninstead, either directly or via a context manager such as\ntempfile.TemporaryFile.\n\n\nIn preview, this rule will also flag references to tempfile.mktemp.\n\nExample:\nimport tempfile\n\ntmp_file = tempfile.mktemp()\nwith open(tmp_file, \"w\") as file:\n    file.write(\"Hello, world!\")\n\n\n\nUse instead:\n\n\nimport tempfile\n\nwith tempfile.TemporaryFile() as file:\n    file.write(\"Hello, world!\")\n\n# Idiom S307 (suspicious-eval-usage)\n\nDefinition: Checks for uses of the builtin eval() function.\n\nRationale: The eval() function is insecure as it enables arbitrary code execution.\n\n\nIf you need to evaluate an expression from a string, consider using\nast.literal_eval() instead, which will raise an exception if the\nexpression is not a valid Python literal.\n\n\nIn preview, this rule will also flag references to eval.\n\nExample:\nx = eval(input(\"Enter a number: \"))\n\n\n\nUse instead:\n\n\nfrom ast import literal_eval\n\nx = literal_eval(input(\"Enter a number: \"))\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PTH110-PTH111-PTH112-PTH113-PTH114",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PTH110 (os-path-exists)\n\nDefinition: Checks for uses of os.path.exists.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os.path. When possible, using Path object\nmethods such as Path.exists() can improve readability over the os.path\nmodule's counterparts (e.g., os.path.exists()).\n\n# Idiom PTH111 (os-path-expanduser)\n\nDefinition: Checks for uses of os.path.expanduser.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os.path. When possible, using Path object\nmethods such as Path.expanduser() can improve readability over the os.path\nmodule's counterparts (e.g., as os.path.expanduser()).\n\n# Idiom PTH112 (os-path-isdir)\n\nDefinition: Checks for uses of os.path.isdir.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os.path. When possible, using Path object\nmethods such as Path.is_dir() can improve readability over the os.path\nmodule's counterparts (e.g., os.path.isdir()).\n\n# Idiom PTH113 (os-path-isfile)\n\nDefinition: Checks for uses of os.path.isfile.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os.path. When possible, using Path object\nmethods such as Path.is_file() can improve readability over the os.path\nmodule's counterparts (e.g., os.path.isfile()).\n\n# Idiom PTH114 (os-path-islink)\n\nDefinition: Checks for uses of os.path.islink.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os.path. When possible, using Path object\nmethods such as Path.is_symlink() can improve readability over the os.path\nmodule's counterparts (e.g., os.path.islink()).\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLE0118-PLE0237-PLE0241-PLE0302-PLE0303",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLE0118 (load-before-global-declaration)\n\nDefinition: Checks for uses of names that are declared as global prior to the\nrelevant global declaration.\n\nRationale: The global declaration applies to the entire scope. Using a name that's\ndeclared as global in a given scope prior to the relevant global\ndeclaration is a SyntaxError.\n\nExample:\ncounter = 1\n\n\ndef increment():\n    print(f\"Adding 1 to {counter}\")\n    global counter\n    counter += 1\n\n\n\nUse instead:\n\n\ncounter = 1\n\n\ndef increment():\n    global counter\n    print(f\"Adding 1 to {counter}\")\n    counter += 1\n\n# Idiom PLE0237 (non-slot-assignment)\n\nDefinition: Checks for assignments to attributes that are not defined in __slots__.\n\nRationale: When using __slots__, only the specified attributes are allowed.\nAttempting to assign to an attribute that is not defined in __slots__\nwill result in an AttributeError at runtime.\n\nExample:\nclass Student:\n    __slots__ = (\"name\",)\n\n    def __init__(self, name, surname):\n        self.name = name\n        self.surname = surname  # [assigning-non-slot]\n        self.setup()\n\n    def setup(self):\n        pass\n\n\n\nUse instead:\n\n\nclass Student:\n    __slots__ = (\"name\", \"surname\")\n\n    def __init__(self, name, surname):\n        self.name = name\n        self.surname = surname\n        self.setup()\n\n    def setup(self):\n        pass\n\n# Idiom PLE0241 (duplicate-bases)\n\nDefinition: Checks for duplicate base classes in class definitions.\n\nRationale: Including duplicate base classes will raise a TypeError at runtime.\n\nExample:\nclass Foo:\n    pass\n\n\nclass Bar(Foo, Foo):\n    pass\n\n\n\nUse instead:\n\n\nclass Foo:\n    pass\n\n\nclass Bar(Foo):\n    pass\n\n# Idiom PLE0302 (unexpected-special-method-signature)\n\nDefinition: Checks for \"special\" methods that have an unexpected method signature.\n\nRationale: \"Special\" methods, like __len__, are expected to adhere to a specific,\nstandard function signature. Implementing a \"special\" method using a\nnon-standard function signature can lead to unexpected and surprising\nbehavior for users of a given class.\n\nExample:\nclass Bookshelf:\n    def __init__(self):\n        self._books = [\"Foo\", \"Bar\", \"Baz\"]\n\n    def __len__(self, index):  # __len__ does not except an index parameter\n        return len(self._books)\n\n    def __getitem__(self, index):\n        return self._books[index]\n\n\n\nUse instead:\n\n\nclass Bookshelf:\n    def __init__(self):\n        self._books = [\"Foo\", \"Bar\", \"Baz\"]\n\n    def __len__(self):\n        return len(self._books)\n\n    def __getitem__(self, index):\n        return self._books[index]\n\n# Idiom PLE0303 (invalid-length-return-type)\n\nDefinition: Checks for __len__ implementations that return values that are not non-negative\nintegers.\n\nRationale: The __len__ method should return a non-negative integer. Returning a different\nvalue may cause unexpected behavior.\n\n\nNote: bool is a subclass of int, so it's technically valid for __len__ to\nreturn True or False. However, for consistency with other rules, Ruff will\nstill emit a diagnostic when __len__ returns a bool.\n\nExample:\nclass Foo:\n    def __len__(self):\n        return \"2\"\n\n\n\nUse instead:\n\n\nclass Foo:\n    def __len__(self):\n        return 2\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/TRY300-TRY301-TRY400-TRY401",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom TRY300 (try-consider-else)\n\nDefinition: Checks for return statements in try blocks.\n\nRationale: The try-except statement has an else clause for code that should\nrun only if no exceptions were raised. Returns in try blocks may\nexhibit confusing or unwanted behavior, such as being overridden by\ncontrol flow in except and finally blocks, or unintentionally\nsuppressing an exception.\n\nExample:\nimport logging\n\n\ndef reciprocal(n):\n    try:\n        rec = 1 / n\n        print(f\"reciprocal of {n} is {rec}\")\n        return rec\n    except ZeroDivisionError:\n        logging.exception(\"Exception occurred\")\n\n\n\nUse instead:\n\n\nimport logging\n\n\ndef reciprocal(n):\n    try:\n        rec = 1 / n\n    except ZeroDivisionError:\n        logging.exception(\"Exception occurred\")\n    else:\n        print(f\"reciprocal of {n} is {rec}\")\n        return rec\n\n# Idiom TRY301 (raise-within-try)\n\nDefinition: Checks for raise statements within try blocks. The only raises\ncaught are those that throw exceptions caught by the try statement itself.\n\nRationale: Raising and catching exceptions within the same try block is redundant,\nas the code can be refactored to avoid the try block entirely.\n\n\nAlternatively, the raise can be moved within an inner function, making\nthe exception reusable across multiple call sites.\n\nExample:\ndef bar():\n    pass\n\n\ndef foo():\n    try:\n        a = bar()\n        if not a:\n            raise ValueError\n    except ValueError:\n        raise\n\n\n\nUse instead:\n\n\ndef bar():\n    raise ValueError\n\n\ndef foo():\n    try:\n        a = bar()  # refactored `bar` to raise `ValueError`\n    except ValueError:\n        raise\n\n# Idiom TRY400 (error-instead-of-exception)\n\nDefinition: Checks for uses of logging.error instead of logging.exception when\nlogging an exception.\n\nRationale: logging.exception logs the exception and the traceback, while\nlogging.error only logs the exception. The former is more appropriate\nwhen logging an exception, as the traceback is often useful for debugging.\n\nExample:\nimport logging\n\n\ndef func():\n    try:\n        raise NotImplementedError\n    except NotImplementedError:\n        logging.error(\"Exception occurred\")\n\n\n\nUse instead:\n\n\nimport logging\n\n\ndef func():\n    try:\n        raise NotImplementedError\n    except NotImplementedError:\n        logging.exception(\"Exception occurred\")\n\n# Idiom TRY401 (verbose-log-message)\n\nDefinition: Checks for excessive logging of exception objects.\n\nRationale: When logging exceptions via logging.exception, the exception object\nis logged automatically. Including the exception object in the log\nmessage is redundant and can lead to excessive logging.\n\nExample:\ntry:\n    ...\nexcept ValueError as e:\n    logger.exception(f\"Found an error: {e}\")\n\n\n\nUse instead:\n\n\ntry:\n    ...\nexcept ValueError:\n    logger.exception(\"Found an error\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLE0704-PLE1700-PLE2515-PLE4703",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLE0704 (misplaced-bare-raise)\n\nDefinition: Checks for bare raise statements outside of exception handlers.\n\nRationale: A bare raise statement without an exception object will re-raise the last\nexception that was active in the current scope, and is typically used\nwithin an exception handler to re-raise the caught exception.\n\n\nIf a bare raise is used outside of an exception handler, it will generate\nan error due to the lack of an active exception.\n\n\nNote that a bare raise within a finally block will work in some cases\n(namely, when the exception is raised within the try block), but should\nbe avoided as it can lead to confusing behavior.\n\nExample:\nfrom typing import Any\n\n\ndef is_some(obj: Any) -> bool:\n    if obj is None:\n        raise\n\n\n\nUse instead:\n\n\nfrom typing import Any\n\n\ndef is_some(obj: Any) -> bool:\n    if obj is None:\n        raise ValueError(\"`obj` cannot be `None`\")\n\n# Idiom PLE1700 (yield-from-in-async-function)\n\nDefinition: Checks for uses of yield from in async functions.\n\nRationale: Python doesn't support the use of yield from in async functions, and will\nraise a SyntaxError in such cases.\n\n\nInstead, considering refactoring the code to use an async for loop instead.\n\nExample:\nasync def numbers():\n    yield from [1, 2, 3, 4, 5]\n\n\n\nUse instead:\n\n\nasync def numbers():\n    async for number in [1, 2, 3, 4, 5]:\n        yield number\n\n# Idiom PLE2515 (invalid-character-zero-width-space)\n\nDefinition: Checks for strings that contain the zero width space character.\n\nRationale: This character is rendered invisibly in some text editors and terminals.\n\n\nBy using the \\u200B sequence, the string will contain the same value,\nbut will render visibly in all editors.\n\nExample:\nx = \"Dear Sir/Madam\"\n\n\n\nUse instead:\n\n\nx = \"Dear Sir\\u200b/\\u200bMadam\"  # zero width space\n\n# Idiom PLE4703 (modified-iterating-set)\n\nDefinition: Checks for loops in which a set is modified during iteration.\n\nRationale: If a set is modified during iteration, it will cause a RuntimeError.\n\n\nIf you need to modify a set within a loop, consider iterating over a copy\nof the set instead.\n\nExample:\nnums = {1, 2, 3}\nfor num in nums:\n    nums.add(num + 5)\n\n\n\nUse instead:\n\n\nnums = {1, 2, 3}\nfor num in nums.copy():\n    nums.add(num + 5)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLW0108-PLW0120-PLW0127-PLW0128-PLW0129",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLW0108 (unnecessary-lambda)\n\nDefinition: Checks for lambda definitions that consist of a single function call\nwith the same arguments as the lambda itself.\n\nRationale: When a lambda is used to wrap a function call, and merely propagates\nthe lambda arguments to that function, it can typically be replaced with\nthe function itself, removing a level of indirection.\n\nExample:\ndf.apply(lambda x: str(x))\n\n\n\nUse instead:\n\n\ndf.apply(str)\n\n# Idiom PLW0120 (useless-else-on-loop)\n\nDefinition: Checks for else clauses on loops without a break statement.\n\nRationale: When a loop includes an else statement, the code inside the else clause\nwill be executed if the loop terminates \"normally\" (i.e., without a\nbreak).\n\n\nIf a loop always terminates \"normally\" (i.e., does not contain a\nbreak), then the else clause is redundant, as the code inside the\nelse clause will always be executed.\n\n\nIn such cases, the code inside the else clause can be moved outside the\nloop entirely, and the else clause can be removed.\n\nExample:\nfor item in items:\n    print(item)\nelse:\n    print(\"All items printed\")\n\n\n\nUse instead:\n\n\nfor item in items:\n    print(item)\nprint(\"All items printed\")\n\n# Idiom PLW0127 (self-assigning-variable)\n\nDefinition: Checks for self-assignment of variables.\n\nRationale: Self-assignment of variables is redundant and likely a mistake.\n\nExample:\ncountry = \"Poland\"\ncountry = country\n\n\n\nUse instead:\n\n\ncountry = \"Poland\"\n\n# Idiom PLW0128 (redeclared-assigned-name)\n\nDefinition: Checks for declared assignments to the same variable multiple times\nin the same assignment.\n\nRationale: Assigning a variable multiple times in the same assignment is redundant,\nas the final assignment to the variable is what the value will be.\n\nExample:\na, b, a = (1, 2, 3)\nprint(a)  # 3\n\n\n\nUse instead:\n\n\n# this is assuming you want to assign 3 to `a`\n_, b, a = (1, 2, 3)\nprint(a)  # 3\n\n# Idiom PLW0129 (assert-on-string-literal)\n\nDefinition: Checks for assert statements that use a string literal as the first\nargument.\n\nRationale: An assert on a non-empty string literal will always pass, while an\nassert on an empty string literal will always fail.\n\nExample:\nassert \"always true\"\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/FURB116-FURB118-FURB122-FURB129-FURB131",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom FURB116 (f-string-number-format)\n\nDefinition: Checks for uses of bin(...)[2:] (or hex, or oct) to convert\nan integer into a string.\n\nRationale: When converting an integer to a baseless binary, hexadecimal, or octal\nstring, using f-strings is more concise and readable than using the\nbin, hex, or oct functions followed by a slice.\n\nExample:\nprint(bin(1337)[2:])\n\n\n\nUse instead:\n\n\nprint(f\"{1337:b}\")\n\n# Idiom FURB118 (reimplemented-operator)\n\nDefinition: Checks for lambda expressions and function definitions that can be replaced with a function from\nthe operator module.\n\nRationale: The operator module provides functions that implement the same functionality as the\ncorresponding operators. For example, operator.add is often equivalent to lambda x, y: x + y.\nUsing the functions from the operator module is more concise and communicates the intent of\nthe code more clearly.\n\nExample:\nimport functools\n\nnums = [1, 2, 3]\ntotal = functools.reduce(lambda x, y: x + y, nums)\n\n\n\nUse instead:\n\n\nimport functools\nimport operator\n\nnums = [1, 2, 3]\ntotal = functools.reduce(operator.add, nums)\n\n# Idiom FURB122 (for-loop-writes)\n\nDefinition: Checks for the use of IOBase.write in a for loop.\n\nRationale: When writing a batch of elements, it's more idiomatic to use a single method call to\nIOBase.writelines, rather than write elements one by one.\n\nExample:\nwith Path(\"file\").open(\"w\") as f:\n    for line in lines:\n        f.write(line)\n\nwith Path(\"file\").open(\"wb\") as f:\n    for line in lines:\n        f.write(line.encode())\n\n\n\nUse instead:\n\n\nwith Path(\"file\").open(\"w\") as f:\n    f.writelines(lines)\n\nwith Path(\"file\").open(\"wb\") as f:\n    f.writelines(line.encode() for line in lines)\n\n# Idiom FURB129 (readlines-in-for)\n\nDefinition: Checks for uses of readlines() when iterating over a file line-by-line.\n\nRationale: Rather than iterating over all lines in a file by calling readlines(),\nit's more convenient and performant to iterate over the file object\ndirectly.\n\nExample:\nwith open(\"file.txt\") as fp:\n    for line in fp.readlines():\n        ...\n\n\n\nUse instead:\n\n\nwith open(\"file.txt\") as fp:\n    for line in fp:\n        ...\n\n# Idiom FURB131 (delete-full-slice)\n\nDefinition: Checks for del statements that delete the entire slice of a list or\ndictionary.\n\nRationale: It is faster and more succinct to remove all items via the clear()\nmethod.\n\nExample:\nnames = {\"key\": \"value\"}\nnums = [1, 2, 3]\n\ndel names[:]\ndel nums[:]\n\n\n\nUse instead:\n\n\nnames = {\"key\": \"value\"}\nnums = [1, 2, 3]\n\nnames.clear()\nnums.clear()\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLE0304-PLE0305-PLE0307-PLE0308-PLE0309",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLE0304 (invalid-bool-return-type)\n\nDefinition: Checks for __bool__ implementations that return a type other than bool.\n\nRationale: The __bool__ method should return a bool object. Returning a different\ntype may cause unexpected behavior.\n\nExample:\nclass Foo:\n    def __bool__(self):\n        return 2\n\n\n\nUse instead:\n\n\nclass Foo:\n    def __bool__(self):\n        return True\n\n# Idiom PLE0305 (invalid-index-return-type)\n\nDefinition: Checks for __index__ implementations that return non-integer values.\n\nRationale: The __index__ method should return an integer. Returning a different\ntype may cause unexpected behavior.\n\n\nNote: bool is a subclass of int, so it's technically valid for __index__ to\nreturn True or False. However, a DeprecationWarning (DeprecationWarning: __index__ returned non-int (type bool)) for such cases was already introduced,\nthus this is a conscious difference between the original pylint rule and the\ncurrent ruff implementation.\n\nExample:\nclass Foo:\n    def __index__(self):\n        return \"2\"\n\n\n\nUse instead:\n\n\nclass Foo:\n    def __index__(self):\n        return 2\n\n# Idiom PLE0307 (invalid-str-return-type)\n\nDefinition: Checks for __str__ implementations that return a type other than str.\n\nRationale: The __str__ method should return a str object. Returning a different\ntype may cause unexpected behavior.\n\nExample:\nclass Foo:\n    def __str__(self):\n        return True\n\n\n\nUse instead:\n\n\nclass Foo:\n    def __str__(self):\n        return \"Foo\"\n\n# Idiom PLE0308 (invalid-bytes-return-type)\n\nDefinition: Checks for __bytes__ implementations that return types other than bytes.\n\nRationale: The __bytes__ method should return a bytes object. Returning a different\ntype may cause unexpected behavior.\n\nExample:\nclass Foo:\n    def __bytes__(self):\n        return 2\n\n\n\nUse instead:\n\n\nclass Foo:\n    def __bytes__(self):\n        return b\"2\"\n\n# Idiom PLE0309 (invalid-hash-return-type)\n\nDefinition: Checks for __hash__ implementations that return non-integer values.\n\nRationale: The __hash__ method should return an integer. Returning a different\ntype may cause unexpected behavior.\n\n\nNote: bool is a subclass of int, so it's technically valid for __hash__ to\nreturn True or False. However, for consistency with other rules, Ruff will\nstill emit a diagnostic when __hash__ returns a bool.\n\nExample:\nclass Foo:\n    def __hash__(self):\n        return \"2\"\n\n\n\nUse instead:\n\n\nclass Foo:\n    def __hash__(self):\n        return 2\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/B007-B008-B009-B010-B011",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom B007 (unused-loop-control-variable)\n\nDefinition: Checks for unused variables in loops (e.g., for and while statements).\n\nRationale: Defining a variable in a loop statement that is never used can confuse\nreaders.\n\n\nIf the variable is intended to be unused (e.g., to facilitate\ndestructuring of a tuple or other object), prefix it with an underscore\nto indicate the intent. Otherwise, remove the variable entirely.\n\nExample:\nfor i, j in foo:\n    bar(i)\n\n\n\nUse instead:\n\n\nfor i, _j in foo:\n    bar(i)\n\n# Idiom B008 (function-call-in-default-argument)\n\nDefinition: Checks for function calls in default function arguments.\n\nRationale: Any function call that's used in a default argument will only be performed\nonce, at definition time. The returned value will then be reused by all\ncalls to the function, which can lead to unexpected behaviour.\n\n\nParameters with immutable type annotations will be ignored by this rule.\nThose whose default arguments are NewType calls where the original type\nis immutable are also ignored.\n\n\nCalls and types outside of the standard library can be marked as an exception\nto this rule with the lint.flake8-bugbear.extend-immutable-calls configuration option.\n\nExample:\ndef create_list() -> list[int]:\n    return [1, 2, 3]\n\n\ndef mutable_default(arg: list[int] = create_list()) -> list[int]:\n    arg.append(4)\n    return arg\n\n\n\nUse instead:\n\n\ndef better(arg: list[int] | None = None) -> list[int]:\n    if arg is None:\n        arg = create_list()\n\n    arg.append(4)\n    return arg\n\n\n\nIf the use of a singleton is intentional, assign the result call to a\nmodule-level variable, and use that variable in the default argument:\n\n\nERROR = ValueError(\"Hosts weren't successfully added\")\n\n\ndef add_host(error: Exception = ERROR) -> None: ...\n\n# Idiom B009 (get-attr-with-constant)\n\nDefinition: Checks for uses of getattr that take a constant attribute value as an\nargument (e.g., getattr(obj, \"foo\")).\n\nRationale: getattr is used to access attributes dynamically. If the attribute is\ndefined as a constant, it is no safer than a typical property access. When\npossible, prefer property access over getattr calls, as the former is\nmore concise and idiomatic.\n\nExample:\ngetattr(obj, \"foo\")\n\n\n\nUse instead:\n\n\nobj.foo\n\n# Idiom B010 (set-attr-with-constant)\n\nDefinition: Checks for uses of setattr that take a constant attribute value as an\nargument (e.g., setattr(obj, \"foo\", 42)).\n\nRationale: setattr is used to set attributes dynamically. If the attribute is\ndefined as a constant, it is no safer than a typical property access. When\npossible, prefer property access over setattr calls, as the former is\nmore concise and idiomatic.\n\nExample:\nsetattr(obj, \"foo\", 42)\n\n\n\nUse instead:\n\n\nobj.foo = 42\n\n# Idiom B011 (assert-false)\n\nDefinition: Checks for uses of assert False.\n\nRationale: Python removes assert statements when running in optimized mode\n(python -O), making assert False an unreliable means of\nraising an AssertionError.\n\n\nInstead, raise an AssertionError directly.\n\nExample:\nassert False\n\n\n\nUse instead:\n\n\nraise AssertionError\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/C417-C418-C419-C420",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom C417 (unnecessary-map)\n\nDefinition: Checks for unnecessary map() calls with lambda functions.\n\nRationale: Using map(func, iterable) when func is a lambda is slower than\nusing a generator expression or a comprehension, as the latter approach\navoids the function call overhead, in addition to being more readable.\n\n\nThis rule also applies to map() calls within list(), set(), and\ndict() calls. For example:\n\n\n\nInstead of list(map(lambda num: num * 2, nums)), use\n    [num * 2 for num in nums].\nInstead of set(map(lambda num: num % 2 == 0, nums)), use\n    {num % 2 == 0 for num in nums}.\nInstead of dict(map(lambda v: (v, v ** 2), values)), use\n    {v: v ** 2 for v in values}.\n\nExample:\nmap(lambda x: x + 1, iterable)\n\n\n\nUse instead:\n\n\n(x + 1 for x in iterable)\n\n# Idiom C418 (unnecessary-literal-within-dict-call)\n\nDefinition: Checks for dict() calls that take unnecessary dict literals or dict\ncomprehensions as arguments.\n\nRationale: It's unnecessary to wrap a dict literal or comprehension within a dict()\ncall, since the literal or comprehension syntax already returns a\ndictionary.\n\nExample:\ndict({})\ndict({\"a\": 1})\n\n\n\nUse instead:\n\n\n{}\n{\"a\": 1}\n\n# Idiom C419 (unnecessary-comprehension-in-call)\n\nDefinition: Checks for unnecessary list or set comprehensions passed to builtin functions that take an iterable.\n\n\nSet comprehensions are only a violation in the case where the builtin function does not care about\nduplication of elements in the passed iterable.\n\nRationale: Many builtin functions (this rule currently covers any and all in stable, along with min,\nmax, and sum in preview) accept any iterable, including a generator. Constructing a\ntemporary list via list comprehension is unnecessary and wastes memory for large iterables.\n\n\nany and all can also short-circuit iteration, saving a lot of time. The unnecessary\ncomprehension forces a full iteration of the input iterable, giving up the benefits of\nshort-circuiting. For example, compare the performance of all with a list comprehension\nagainst that of a generator in a case where an early short-circuit is possible (almost 40x\nfaster):\n\n\nIn [1]: %timeit all([i for i in range(1000)])\n8.14 \u00b5s \u00b1 25.4 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n\nIn [2]: %timeit all(i for i in range(1000))\n212 ns \u00b1 0.892 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\n\n\nThis performance improvement is due to short-circuiting. If the entire iterable has to be\ntraversed, the comprehension version may even be a bit faster: list allocation overhead is not\nnecessarily greater than generator overhead.\n\n\nApplying this rule simplifies the code and will usually save memory, but in the absence of\nshort-circuiting it may not improve performance. (It may even slightly regress performance,\nthough the difference will usually be small.)\n\nExample:\nany([x.id for x in bar])\nall([x.id for x in bar])\nsum([x.val for x in bar])\nmin([x.val for x in bar])\nmax([x.val for x in bar])\n\n\n\nUse instead:\n\n\nany(x.id for x in bar)\nall(x.id for x in bar)\nsum(x.val for x in bar)\nmin(x.val for x in bar)\nmax(x.val for x in bar)\n\n# Idiom C420 (unnecessary-dict-comprehension-for-iterable)\n\nDefinition: Checks for unnecessary dict comprehension when creating a dictionary from\nan iterable.\n\nRationale: It's unnecessary to use a dict comprehension to build a dictionary from\nan iterable when the value is static.\n\n\nPrefer dict.fromkeys(iterable) over {value: None for value in iterable},\nas dict.fromkeys is more readable and efficient.\n\nExample:\n{a: None for a in iterable}\n{a: 1 for a in iterable}\n\n\n\nUse instead:\n\n\ndict.fromkeys(iterable)\ndict.fromkeys(iterable, 1)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/C411-C413-C414-C415-C416",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom C411 (unnecessary-list-call)\n\nDefinition: Checks for unnecessary list() calls around list comprehensions.\n\nRationale: It is redundant to use a list() call around a list comprehension.\n\nExample:\nlist([f(x) for x in foo])\n\n\n\nUse instead\n\n\n[f(x) for x in foo]\n\n# Idiom C413 (unnecessary-call-around-sorted)\n\nDefinition: Checks for unnecessary list() or reversed() calls around sorted()\ncalls.\n\nRationale: It is unnecessary to use list() around sorted(), as the latter already\nreturns a list.\n\n\nIt is also unnecessary to use reversed() around sorted(), as the latter\nhas a reverse argument that can be used in lieu of an additional\nreversed() call.\n\n\nIn both cases, it's clearer and more efficient to avoid the redundant call.\n\nExample:\nreversed(sorted(iterable))\n\n\n\nUse instead:\n\n\nsorted(iterable, reverse=True)\n\n# Idiom C414 (unnecessary-double-cast-or-process)\n\nDefinition: Checks for unnecessary list(), reversed(), set(), sorted(), and\ntuple() call within list(), set(), sorted(), and tuple() calls.\n\nRationale: It's unnecessary to double-cast or double-process iterables by wrapping\nthe listed functions within an additional list(), set(), sorted(), or\ntuple() call. Doing so is redundant and can be confusing for readers.\n\nExample:\nlist(tuple(iterable))\n\n\n\nUse instead:\n\n\nlist(iterable)\n\n\n\nThis rule applies to a variety of functions, including list(), reversed(),\nset(), sorted(), and tuple(). For example:\n\n\n\nInstead of list(list(iterable)), use list(iterable).\nInstead of list(tuple(iterable)), use list(iterable).\nInstead of tuple(list(iterable)), use tuple(iterable).\nInstead of tuple(tuple(iterable)), use tuple(iterable).\nInstead of set(set(iterable)), use set(iterable).\nInstead of set(list(iterable)), use set(iterable).\nInstead of set(tuple(iterable)), use set(iterable).\nInstead of set(sorted(iterable)), use set(iterable).\nInstead of set(reversed(iterable)), use set(iterable).\nInstead of sorted(list(iterable)), use sorted(iterable).\nInstead of sorted(tuple(iterable)), use sorted(iterable).\nInstead of sorted(sorted(iterable)), use sorted(iterable).\nInstead of sorted(reversed(iterable)), use sorted(iterable).\n\n# Idiom C415 (unnecessary-subscript-reversal)\n\nDefinition: Checks for unnecessary subscript reversal of iterable.\n\nRationale: It's unnecessary to reverse the order of an iterable when passing it\ninto reversed(), set() or sorted() functions as they will change\nthe order of the elements again.\n\nExample:\nsorted(iterable[::-1])\nset(iterable[::-1])\nreversed(iterable[::-1])\n\n\n\nUse instead:\n\n\nsorted(iterable)\nset(iterable)\niterable\n\n# Idiom C416 (unnecessary-comprehension)\n\nDefinition: Checks for unnecessary dict, list, and set comprehension.\n\nRationale: It's unnecessary to use a dict/list/set comprehension to build a data structure if the\nelements are unchanged. Wrap the iterable with dict(), list(), or set() instead.\n\nExample:\n{a: b for a, b in iterable}\n[x for x in iterable]\n{x for x in iterable}\n\n\n\nUse instead:\n\n\ndict(iterable)\nlist(iterable)\nset(iterable)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLW0131-PLW0133-PLW0177-PLW0211-PLW0244",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLW0131 (named-expr-without-context)\n\nDefinition: Checks for uses of named expressions (e.g., a := 42) that can be\nreplaced by regular assignment statements (e.g., a = 42).\n\nRationale: While a top-level named expression is syntactically and semantically valid,\nit's less clear than a regular assignment statement. Named expressions are\nintended to be used in comprehensions and generator expressions, where\nassignment statements are not allowed.\n\nExample:\n(a := 42)\n\n\n\nUse instead:\n\n\na = 42\n\n# Idiom PLW0133 (useless-exception-statement)\n\nDefinition: Checks for an exception that is not raised.\n\nRationale: It's unnecessary to create an exception without raising it. For example,\nValueError(\"...\") on its own will have no effect (unlike\nraise ValueError(\"...\")) and is likely a mistake.\n\nExample:\nValueError(\"...\")\n\n\n\nUse instead:\n\n\nraise ValueError(\"...\")\n\n# Idiom PLW0177 (nan-comparison)\n\nDefinition: Checks for comparisons against NaN values.\n\nRationale: Comparing against a NaN value can lead to unexpected results. For example,\nfloat(\"NaN\") == float(\"NaN\") will return False and, in general,\nx == float(\"NaN\") will always return False, even if x is NaN.\n\n\nTo determine whether a value is NaN, use math.isnan or np.isnan\ninstead of comparing against NaN directly.\n\nExample:\nif x == float(\"NaN\"):\n    pass\n\n\n\nUse instead:\n\n\nimport math\n\nif math.isnan(x):\n    pass\n\n# Idiom PLW0211 (bad-staticmethod-argument)\n\nDefinition: Checks for static methods that use self or cls as their first argument.\nThis rule also applies to __new__ methods, which are implicitly static.\n\nRationale: PEP 8 recommends the use of self and cls as the first arguments for\ninstance methods and class methods, respectively. Naming the first argument\nof a static method as self or cls can be misleading, as static methods\ndo not receive an instance or class reference as their first argument.\n\nExample:\nclass Wolf:\n    @staticmethod\n    def eat(self):\n        pass\n\n\n\nUse instead:\n\n\nclass Wolf:\n    @staticmethod\n    def eat(sheep):\n        pass\n\n# Idiom PLW0244 (redefined-slots-in-subclass)\n\nDefinition: Checks for a re-defined slot in a subclass.\n\nRationale: If a class defines a slot also defined in a base class, the\ninstance variable defined by the base class slot is inaccessible\n(except by retrieving its descriptor directly from the base class).\n\nExample:\nclass Base:\n    __slots__ = (\"a\", \"b\")\n\n\nclass Subclass(Base):\n    __slots__ = (\"a\", \"d\")  # slot \"a\" redefined\n\n\n\nUse instead:\n\n\nclass Base:\n    __slots__ = (\"a\", \"b\")\n\n\nclass Subclass(Base):\n    __slots__ = \"d\"\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/FURB187-FURB188-FURB189-FURB192",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom FURB187 (list-reverse-copy)\n\nDefinition: Checks for list reversals that can be performed in-place in lieu of\ncreating a new list.\n\nRationale: When reversing a list, it's more efficient to use the in-place method\n.reverse() instead of creating a new list, if the original list is\nno longer needed.\n\nExample:\nl = [1, 2, 3]\nl = reversed(l)\n\nl = [1, 2, 3]\nl = list(reversed(l))\n\nl = [1, 2, 3]\nl = l[::-1]\n\n\n\nUse instead:\n\n\nl = [1, 2, 3]\nl.reverse()\n\n# Idiom FURB188 (slice-to-remove-prefix-or-suffix)\n\nDefinition: Checks for code that could be written more idiomatically using\nstr.removeprefix()\nor str.removesuffix().\n\n\nSpecifically, the rule flags code that conditionally removes a prefix or suffix\nusing a slice operation following an if test that uses str.startswith() or str.endswith().\n\n\nThe rule is only applied if your project targets Python 3.9 or later.\n\nRationale: The methods str.removeprefix()\nand str.removesuffix(),\nintroduced in Python 3.9, have the same behavior while being more readable and efficient.\n\nExample:\ndef example(filename: str, text: str):\n    filename = filename[:-4] if filename.endswith(\".txt\") else filename\n\n    if text.startswith(\"pre\"):\n        text = text[3:]\n\n\n\nUse instead:\n\n\ndef example(filename: str, text: str):\n    filename = filename.removesuffix(\".txt\")\n    text = text.removeprefix(\"pre\")\n\n# Idiom FURB189 (subclass-builtin)\n\nDefinition: Checks for subclasses of dict, list or str.\n\nRationale: Built-in types don't consistently use their own dunder methods. For example,\ndict.__init__ and dict.update() bypass __setitem__, making inheritance unreliable.\n\n\nUse the UserDict, UserList, and UserString objects from the collections module\ninstead.\n\nExample:\nclass UppercaseDict(dict):\n    def __setitem__(self, key, value):\n        super().__setitem__(key.upper(), value)\n\n\nd = UppercaseDict({\"a\": 1, \"b\": 2})  # Bypasses __setitem__\nprint(d)  # {'a': 1, 'b': 2}\n\n\n\nUse instead:\n\n\nfrom collections import UserDict\n\n\nclass UppercaseDict(UserDict):\n    def __setitem__(self, key, value):\n        super().__setitem__(key.upper(), value)\n\n\nd = UppercaseDict({\"a\": 1, \"b\": 2})  # Uses __setitem__\nprint(d)  # {'A': 1, 'B': 2}\n\n# Idiom FURB192 (sorted-min-max)\n\nDefinition: Checks for uses of sorted() to retrieve the minimum or maximum value in\na sequence.\n\nRationale: Using sorted() to compute the minimum or maximum value in a sequence is\ninefficient and less readable than using min() or max() directly.\n\nExample:\nnums = [3, 1, 4, 1, 5]\nlowest = sorted(nums)[0]\nhighest = sorted(nums)[-1]\nhighest = sorted(nums, reverse=True)[0]\n\n\n\nUse instead:\n\n\nnums = [3, 1, 4, 1, 5]\nlowest = min(nums)\nhighest = max(nums)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/B022-B023-B024-B025-B026",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom B022 (useless-contextlib-suppress)\n\nDefinition: Checks for contextlib.suppress without arguments.\n\nRationale: contextlib.suppress is a context manager that suppresses exceptions. It takes,\nas arguments, the exceptions to suppress within the enclosed block. If no\nexceptions are specified, then the context manager won't suppress any\nexceptions, and is thus redundant.\n\n\nConsider adding exceptions to the contextlib.suppress call, or removing the\ncontext manager entirely.\n\nExample:\nimport contextlib\n\nwith contextlib.suppress():\n    foo()\n\n\n\nUse instead:\n\n\nimport contextlib\n\nwith contextlib.suppress(Exception):\n    foo()\n\n# Idiom B023 (function-uses-loop-variable)\n\nDefinition: Checks for function definitions that use a loop variable.\n\nRationale: The loop variable is not bound in the function definition, so it will always\nhave the value it had in the last iteration when the function is called.\n\n\nInstead, consider using a default argument to bind the loop variable at\nfunction definition time. Or, use functools.partial.\n\nExample:\nadders = [lambda x: x + i for i in range(3)]\nvalues = [adder(1) for adder in adders]  # [3, 3, 3]\n\n\n\nUse instead:\n\n\nadders = [lambda x, i=i: x + i for i in range(3)]\nvalues = [adder(1) for adder in adders]  # [1, 2, 3]\n\n\n\nOr:\n\n\nfrom functools import partial\n\nadders = [partial(lambda x, i: x + i, i=i) for i in range(3)]\nvalues = [adder(1) for adder in adders]  # [1, 2, 3]\n\n# Idiom B024 (abstract-base-class-without-abstract-method)\n\nDefinition: Checks for abstract classes without abstract methods or properties.\nAnnotated but unassigned class variables are regarded as abstract.\n\nRationale: Abstract base classes are used to define interfaces. If an abstract base\nclass has no abstract methods or properties, you may have forgotten\nto add an abstract method or property to the class,\nor omitted an @abstractmethod decorator.\n\n\nIf the class is not meant to be used as an interface, consider removing\nthe ABC base class from the class definition.\n\nExample:\nfrom abc import ABC\nfrom typing import ClassVar\n\n\nclass Foo(ABC):\n    class_var: ClassVar[str] = \"assigned\"\n\n    def method(self):\n        bar()\n\n\n\nUse instead:\n\n\nfrom abc import ABC, abstractmethod\nfrom typing import ClassVar\n\n\nclass Foo(ABC):\n    class_var: ClassVar[str]  # unassigned\n\n    @abstractmethod\n    def method(self):\n        bar()\n\n# Idiom B025 (duplicate-try-block-exception)\n\nDefinition: Checks for try-except blocks with duplicate exception handlers.\n\nRationale: Duplicate exception handlers are redundant, as the first handler will catch\nthe exception, making the second handler unreachable.\n\nExample:\ntry:\n    ...\nexcept ValueError:\n    ...\nexcept ValueError:\n    ...\n\n\n\nUse instead:\n\n\ntry:\n    ...\nexcept ValueError:\n    ...\n\n# Idiom B026 (star-arg-unpacking-after-keyword-arg)\n\nDefinition: Checks for function calls that use star-argument unpacking after providing a\nkeyword argument\n\nRationale: In Python, you can use star-argument unpacking to pass a list or tuple of\narguments to a function.\n\n\nProviding a star-argument after a keyword argument can lead to confusing\nbehavior, and is only supported for backwards compatibility.\n\nExample:\ndef foo(x, y, z):\n    return x, y, z\n\n\nfoo(1, 2, 3)  # (1, 2, 3)\nfoo(1, *[2, 3])  # (1, 2, 3)\n# foo(x=1, *[2, 3])  # TypeError\n# foo(y=2, *[1, 3])  # TypeError\nfoo(z=3, *[1, 2])  # (1, 2, 3)  # No error, but confusing!\n\n\n\nUse instead:\n\n\ndef foo(x, y, z):\n    return x, y, z\n\n\nfoo(1, 2, 3)  # (1, 2, 3)\nfoo(x=1, y=2, z=3)  # (1, 2, 3)\nfoo(*[1, 2, 3])  # (1, 2, 3)\nfoo(*[1, 2], 3)  # (1, 2, 3)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/S319-S321-S323-S324-S401",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom S319 (suspicious-xml-pull-dom-usage)\n\nDefinition: Checks for uses of insecure XML parsers.\n\nRationale: Many XML parsers are vulnerable to XML attacks (such as entity expansion),\nwhich cause excessive memory and CPU usage by exploiting recursion. An\nattacker could use such methods to access unauthorized resources.\n\n\nConsider using the defusedxml package when parsing untrusted XML data,\nto protect against XML attacks.\n\n\nIn preview, this rule will also flag references to insecure XML parsers.\n\nExample:\nfrom xml.dom.pulldom import parse\n\ncontent = parse(\"untrusted.xml\")\n\n\n\nUse instead:\n\n\nfrom defusedxml.pulldom import parse\n\ncontent = parse(\"untrusted.xml\")\n\n# Idiom S321 (suspicious-ftp-lib-usage)\n\nDefinition: Checks for the use of FTP-related functions.\n\nRationale: FTP is considered insecure as it does not encrypt data sent over the\nconnection and is thus vulnerable to numerous attacks.\n\n\nInstead, consider using FTPS (which secures FTP using SSL/TLS) or SFTP.\n\n\nIn preview, this rule will also flag references to FTP-related functions.\n\n# Idiom S323 (suspicious-unverified-context-usage)\n\nDefinition: Checks for uses of ssl._create_unverified_context.\n\nRationale: PEP 476 enabled certificate and hostname validation by default in Python\nstandard library HTTP clients. Previously, Python did not validate\ncertificates by default, which could allow an attacker to perform a \"man in\nthe middle\" attack by intercepting and modifying traffic between client and\nserver.\n\n\nTo support legacy environments, ssl._create_unverified_context reverts to\nthe previous behavior that does perform verification. Otherwise, use\nssl.create_default_context to create a secure context.\n\n\nIn preview, this rule will also flag references to ssl._create_unverified_context.\n\nExample:\nimport ssl\n\ncontext = ssl._create_unverified_context()\n\n\n\nUse instead:\n\n\nimport ssl\n\ncontext = ssl.create_default_context()\n\n# Idiom S324 (hashlib-insecure-hash-function)\n\nDefinition: Checks for uses of weak or broken cryptographic hash functions in\nhashlib and crypt libraries.\n\nRationale: Weak or broken cryptographic hash functions may be susceptible to\ncollision attacks (where two different inputs produce the same hash) or\npre-image attacks (where an attacker can find an input that produces a\ngiven hash). This can lead to security vulnerabilities in applications\nthat rely on these hash functions.\n\n\nAvoid using weak or broken cryptographic hash functions in security\ncontexts. Instead, use a known secure hash function such as SHA256.\n\nExample:\nimport hashlib\n\n\ndef certificate_is_valid(certificate: bytes, known_hash: str) -> bool:\n    hash = hashlib.md5(certificate).hexdigest()\n    return hash == known_hash\n\n\n\nUse instead:\n\n\nimport hashlib\n\n\ndef certificate_is_valid(certificate: bytes, known_hash: str) -> bool:\n    hash = hashlib.sha256(certificate).hexdigest()\n    return hash == known_hash\n\n\n\nor add usedforsecurity=False if the hashing algorithm is not used in a security context, e.g.\nas a non-cryptographic one-way compression function:\n\n\nimport hashlib\n\n\ndef certificate_is_valid(certificate: bytes, known_hash: str) -> bool:\n    hash = hashlib.md5(certificate, usedforsecurity=False).hexdigest()\n    return hash == known_hash\n\n# Idiom S401 (suspicious-telnetlib-import)\n\nDefinition: Checks for imports of the telnetlib module.\n\nRationale: Telnet is considered insecure. It is deprecated since version 3.11, and\nwas removed in version 3.13. Instead, use SSH or another encrypted\nprotocol.\n\nExample:\nimport telnetlib\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLW2101-PLW2901-PLW3201-PLW3301",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLW2101 (useless-with-lock)\n\nDefinition: Checks for lock objects that are created and immediately discarded in\nwith statements.\n\nRationale: Creating a lock (via threading.Lock or similar) in a with statement\nhas no effect, as locks are only relevant when shared between threads.\n\n\nInstead, assign the lock to a variable outside the with statement,\nand share that variable between threads.\n\nExample:\nimport threading\n\ncounter = 0\n\n\ndef increment():\n    global counter\n\n    with threading.Lock():\n        counter += 1\n\n\n\nUse instead:\n\n\nimport threading\n\ncounter = 0\nlock = threading.Lock()\n\n\ndef increment():\n    global counter\n\n    with lock:\n        counter += 1\n\n# Idiom PLW2901 (redefined-loop-name)\n\nDefinition: Checks for variables defined in for loops and with statements that\nget overwritten within the body, for example by another for loop or\nwith statement or by direct assignment.\n\nRationale: Redefinition of a loop variable inside the loop's body causes its value\nto differ from the original loop iteration for the remainder of the\nblock, in a way that will likely cause bugs.\n\n\nIn Python, unlike many other languages, for loops and with\nstatements don't define their own scopes. Therefore, a nested loop that\nuses the same target variable name as an outer loop will reuse the same\nactual variable, and the value from the last iteration will \"leak out\"\ninto the remainder of the enclosing loop.\n\n\nWhile this mistake is easy to spot in small examples, it can be hidden\nin larger blocks of code, where the definition and redefinition of the\nvariable may not be visible at the same time.\n\nExample:\nfor i in range(10):\n    i = 9\n    print(i)  # prints 9 every iteration\n\nfor i in range(10):\n    for i in range(10):  # original value overwritten\n        pass\n    print(i)  # also prints 9 every iteration\n\nwith path1.open() as f:\n    with path2.open() as f:\n        f = path2.open()\n    print(f.readline())  # prints a line from path2\n\n# Idiom PLW3201 (bad-dunder-method-name)\n\nDefinition: Checks for dunder methods that have no special meaning in Python 3.\n\nRationale: Misspelled or no longer supported dunder name methods may cause your code to not function\nas expected.\n\n\nSince dunder methods are associated with customizing the behavior\nof a class in Python, introducing a dunder method such as __foo__\nthat diverges from standard Python dunder methods could potentially\nconfuse someone reading the code.\n\n\nThis rule will detect all methods starting and ending with at least\none underscore (e.g., _str_), but ignores known dunder methods (like\n__init__), as well as methods that are marked with @override.\n\n\nAdditional dunder methods names can be allowed via the\nlint.pylint.allow-dunder-method-names setting.\n\nExample:\nclass Foo:\n    def __init_(self): ...\n\n\n\nUse instead:\n\n\nclass Foo:\n    def __init__(self): ...\n\n# Idiom PLW3301 (nested-min-max)\n\nDefinition: Checks for nested min and max calls.\n\nRationale: Nested min and max calls can be flattened into a single call to improve\nreadability.\n\nExample:\nminimum = min(1, 2, min(3, 4, 5))\nmaximum = max(1, 2, max(3, 4, 5))\ndiff = maximum - minimum\n\n\n\nUse instead:\n\n\nminimum = min(1, 2, 3, 4, 5)\nmaximum = max(1, 2, 3, 4, 5)\ndiff = maximum - minimum\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/ANN001-ANN002-ANN003-ANN201-ANN202",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom ANN002 (missing-type-args)\n\nDefinition: Checks that function *args arguments have type annotations.\n\nRationale: Type annotations are a good way to document the types of function arguments. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany provided arguments match expectation.\n\nExample:\ndef foo(*args): ...\n\n\n\nUse instead:\n\n\ndef foo(*args: int): ...\n\n# Idiom ANN003 (missing-type-kwargs)\n\nDefinition: Checks that function **kwargs arguments have type annotations.\n\nRationale: Type annotations are a good way to document the types of function arguments. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany provided arguments match expectation.\n\nExample:\ndef foo(**kwargs): ...\n\n\n\nUse instead:\n\n\ndef foo(**kwargs: int): ...\n\n# Idiom ANN202 (missing-return-type-private-function)\n\nDefinition: Checks that private functions and methods have return type annotations.\n\nRationale: Type annotations are a good way to document the return types of functions. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany returned values, and the types expected by callers, match expectation.\n\nExample:\ndef _add(a, b):\n    return a + b\n\n\n\nUse instead:\n\n\ndef _add(a: int, b: int) -> int:\n    return a + b\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/ICN001-ICN002-ICN003",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom ICN001 (unconventional-import-alias)\n\nDefinition: Checks for imports that are typically imported using a common convention,\nlike import pandas as pd, and enforces that convention.\n\nRationale: Consistency is good. Use a common convention for imports to make your code\nmore readable and idiomatic.\n\n\nFor example, import pandas as pd is a common\nconvention for importing the pandas library, and users typically expect\nPandas to be aliased as pd.\n\nExample:\nimport pandas\n\n\n\nUse instead:\n\n\nimport pandas as pd\n\n# Idiom ICN002 (banned-import-alias)\n\nDefinition: Checks for imports that use non-standard naming conventions, like\nimport tensorflow.keras.backend as K.\n\nRationale: Consistency is good. Avoid using a non-standard naming convention for\nimports, and, in particular, choosing import aliases that violate PEP 8.\n\n\nFor example, aliasing via import tensorflow.keras.backend as K violates\nthe guidance of PEP 8, and is thus avoided in some projects.\n\nExample:\nimport tensorflow.keras.backend as K\n\n\n\nUse instead:\n\n\nimport tensorflow as tf\n\ntf.keras.backend\n\n# Idiom ICN003 (banned-import-from)\n\nDefinition: Checks for member imports that should instead be accessed by importing the\nmodule.\n\nRationale: Consistency is good. Use a common convention for imports to make your code\nmore readable and idiomatic.\n\n\nFor example, it's common to import pandas as pd, and then access\nmembers like Series via pd.Series, rather than importing Series\ndirectly.\n\nExample:\nfrom pandas import Series\n\n\n\nUse instead:\n\n\nimport pandas as pd\n\npd.Series\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/W391-W505-W605",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom W391 (too-many-newlines-at-end-of-file)\n\nDefinition: Checks for files with multiple trailing blank lines.\n\n\nIn the case of notebooks, this check is applied to\neach cell separately.\n\nRationale: Trailing blank lines in a file are superfluous.\n\n\nHowever, the last line of the file should end with a newline.\n\nExample:\nspam(1)\\n\\n\\n\n\n\n\nUse instead:\n\n\nspam(1)\\n\n\n# Idiom W505 (doc-line-too-long)\n\nDefinition: Checks for doc lines that exceed the specified maximum character length.\n\nRationale: For flowing long blocks of text (docstrings or comments), overlong lines\ncan hurt readability. PEP 8, for example, recommends that such lines be\nlimited to 72 characters, while this rule enforces the limit specified by\nthe lint.pycodestyle.max-doc-length setting. (If no value is provided, this\nrule will be ignored, even if it's added to your --select list.)\n\n\nIn the context of this rule, a \"doc line\" is defined as a line consisting\nof either a standalone comment or a standalone string, like a docstring.\n\n\nIn the interest of pragmatism, this rule makes a few exceptions when\ndetermining whether a line is overlong. Namely, it:\n\n\n\nIgnores lines that consist of a single \"word\" (i.e., without any\n    whitespace between its characters).\nIgnores lines that end with a URL, as long as the URL starts before\n    the line-length threshold.\nIgnores line that end with a pragma comment (e.g., # type: ignore\n    or # noqa), as long as the pragma comment starts before the\n    line-length threshold. That is, a line will not be flagged as\n    overlong if a pragma comment causes it to exceed the line length.\n    (This behavior aligns with that of the Ruff formatter.)\n\n\n\nIf lint.pycodestyle.ignore-overlong-task-comments is true, this rule will\nalso ignore comments that start with any of the specified lint.task-tags\n(e.g., # TODO:).\n\nExample:\ndef function(x):\n    \"\"\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis auctor purus ut ex fermentum, at maximus est hendrerit.\"\"\"\n\n\n\nUse instead:\n\n\ndef function(x):\n    \"\"\"\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n    Duis auctor purus ut ex fermentum, at maximus est hendrerit.\n    \"\"\"\n\n# Idiom W605 (invalid-escape-sequence)\n\nDefinition: Checks for invalid escape sequences.\n\nRationale: Invalid escape sequences are deprecated in Python 3.6.\n\nExample:\nregex = \"\\.png$\"\n\n\n\nUse instead:\n\n\nregex = r\"\\.png$\"\n\n\n\nOr, if the string already contains a valid escape sequence:\n\n\nvalue = \"new line\\nand invalid escape \\_ here\"\n\n\n\nUse instead:\n\n\nvalue = \"new line\\nand invalid escape \\\\_ here\"\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/F401-F402-F403-F404-F405",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom F401 (unused-import)\n\nDefinition: Checks for unused imports.\n\nRationale: Unused imports add a performance overhead at runtime, and risk creating\nimport cycles. They also increase the cognitive load of reading the code.\n\n\nIf an import statement is used to check for the availability or existence\nof a module, consider using importlib.util.find_spec instead.\n\n\nIf an import statement is used to re-export a symbol as part of a module's\npublic interface, consider using a \"redundant\" import alias, which\ninstructs Ruff (and other tools) to respect the re-export, and avoid\nmarking it as unused, as in:\n\n\nfrom module import member as member\n\n\n\nAlternatively, you can use __all__ to declare a symbol as part of the module's\ninterface, as in:\n\n\n# __init__.py\nimport some_module\n\n__all__ = [\"some_module\"]\n\nExample:\nimport numpy as np  # unused import\n\n\ndef area(radius):\n    return 3.14 * radius**2\n\n\n\nUse instead:\n\n\ndef area(radius):\n    return 3.14 * radius**2\n\n\n\nTo check the availability of a module, use importlib.util.find_spec:\n\n\nfrom importlib.util import find_spec\n\nif find_spec(\"numpy\") is not None:\n    print(\"numpy is installed\")\nelse:\n    print(\"numpy is not installed\")\n\n# Idiom F402 (import-shadowed-by-loop-var)\n\nDefinition: Checks for import bindings that are shadowed by loop variables.\n\nRationale: Shadowing an import with loop variables makes the code harder to read and\nreason about, as the identify of the imported binding is no longer clear.\nIt's also often indicative of a mistake, as it's unlikely that the loop\nvariable is intended to be used as the imported binding.\n\n\nConsider using a different name for the loop variable.\n\nExample:\nfrom os import path\n\nfor path in files:\n    print(path)\n\n\n\nUse instead:\n\n\nfrom os import path\n\n\nfor filename in files:\n    print(filename)\n\n# Idiom F403 (undefined-local-with-import-star)\n\nDefinition: Checks for the use of wildcard imports.\n\nRationale: Wildcard imports (e.g., from module import *) make it hard to determine\nwhich symbols are available in the current namespace, and from which module\nthey were imported. They're also discouraged by PEP 8.\n\nExample:\nfrom math import *\n\n\ndef area(radius):\n    return pi * radius**2\n\n\n\nUse instead:\n\n\nfrom math import pi\n\n\ndef area(radius):\n    return pi * radius**2\n\n# Idiom F404 (late-future-import)\n\nDefinition: Checks for __future__ imports that are not located at the beginning of a\nfile.\n\nRationale: Imports from __future__ must be placed the beginning of the file, before any\nother statements (apart from docstrings). The use of __future__ imports\nelsewhere is invalid and will result in a SyntaxError.\n\nExample:\nfrom pathlib import Path\n\nfrom __future__ import annotations\n\n\n\nUse instead:\n\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\n\n# Idiom F405 (undefined-local-with-import-star-usage)\n\nDefinition: Checks for names that might be undefined, but may also be defined in a\nwildcard import.\n\nRationale: Wildcard imports (e.g., from module import *) make it hard to determine\nwhich symbols are available in the current namespace. If a module contains\na wildcard import, and a name in the current namespace has not been\nexplicitly defined or imported, then it's unclear whether the name is\nundefined or was imported by the wildcard import.\n\n\nIf the name is defined in via a wildcard import, that member should be\nimported explicitly to avoid confusion.\n\n\nIf the name is not defined in a wildcard import, it should be defined or\nimported.\n\nExample:\nfrom math import *\n\n\ndef area(radius):\n    return pi * radius**2\n\n\n\nUse instead:\n\n\nfrom math import pi\n\n\ndef area(radius):\n    return pi * radius**2\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/UP001-UP003-UP004-UP005-UP006",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom UP001 (useless-metaclass-type)\n\nDefinition: Checks for the use of __metaclass__ = type in class definitions.\n\nRationale: Since Python 3, __metaclass__ = type is implied and can thus be omitted.\n\nExample:\nclass Foo:\n    __metaclass__ = type\n\n\n\nUse instead:\n\n\nclass Foo: ...\n\n# Idiom UP003 (type-of-primitive)\n\nDefinition: Checks for uses of type that take a primitive as an argument.\n\nRationale: type() returns the type of a given object. A type of a primitive can\nalways be known in advance and accessed directly, which is more concise\nand explicit than using type().\n\nExample:\ntype(1)\n\n\n\nUse instead:\n\n\nint\n\n# Idiom UP004 (useless-object-inheritance)\n\nDefinition: Checks for classes that inherit from object.\n\nRationale: Since Python 3, all classes inherit from object by default, so object can\nbe omitted from the list of base classes.\n\nExample:\nclass Foo(object): ...\n\n\n\nUse instead:\n\n\nclass Foo: ...\n\n# Idiom UP005 (deprecated-unittest-alias)\n\nDefinition: Checks for uses of deprecated methods from the unittest module.\n\nRationale: The unittest module has deprecated aliases for some of its methods.\nThe deprecated aliases were removed in Python 3.12. Instead of aliases,\nuse their non-deprecated counterparts.\n\nExample:\nfrom unittest import TestCase\n\n\nclass SomeTest(TestCase):\n    def test_something(self):\n        self.assertEquals(1, 1)\n\n\n\nUse instead:\n\n\nfrom unittest import TestCase\n\n\nclass SomeTest(TestCase):\n    def test_something(self):\n        self.assertEqual(1, 1)\n\n# Idiom UP006 (non-pep585-annotation)\n\nDefinition: Checks for the use of generics that can be replaced with standard library\nvariants based on PEP 585.\n\nRationale: PEP 585 enabled collections in the Python standard library (like list)\nto be used as generics directly, instead of importing analogous members\nfrom the typing module (like typing.List).\n\n\nWhen available, the PEP 585 syntax should be used instead of importing\nmembers from the typing module, as it's more concise and readable.\nImporting those members from typing is considered deprecated as of PEP\n585.\n\n\nThis rule is enabled when targeting Python 3.9 or later (see:\ntarget-version). By default, it's also enabled for earlier Python\nversions if from __future__ import annotations is present, as\n__future__ annotations are not evaluated at runtime. If your code relies\non runtime type annotations (either directly or via a library like\nPydantic), you can disable this behavior for Python versions prior to 3.9\nby setting lint.pyupgrade.keep-runtime-typing to true.\n\nExample:\nfrom typing import List\n\nfoo: List[int] = [1, 2, 3]\n\n\n\nUse instead:\n\n\nfoo: list[int] = [1, 2, 3]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PYI055-PYI056-PYI057-PYI058-PYI059",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PYI055 (unnecessary-type-union)\n\nDefinition: Checks for the presence of multiple types in a union.\n\nRationale: type[T | S] has identical semantics to type[T] | type[S] in a type\nannotation, but is cleaner and more concise.\n\nExample:\nfield: type[int] | type[float] | str\n\n\n\nUse instead:\n\n\nfield: type[int | float] | str\n\n# Idiom PYI056 (unsupported-method-call-on-all)\n\nDefinition: Checks that append, extend and remove methods are not called on\n__all__.\n\nRationale: Different type checkers have varying levels of support for calling these\nmethods on __all__. Instead, use the += operator to add items to\n__all__, which is known to be supported by all major type checkers.\n\nExample:\nimport sys\n\n__all__ = [\"A\", \"B\"]\n\nif sys.version_info >= (3, 10):\n    __all__.append(\"C\")\n\nif sys.version_info >= (3, 11):\n    __all__.remove(\"B\")\n\n\n\nUse instead:\n\n\nimport sys\n\n__all__ = [\"A\"]\n\nif sys.version_info < (3, 11):\n    __all__ += [\"B\"]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"C\"]\n\n# Idiom PYI057 (byte-string-usage)\n\nDefinition: Checks for uses of typing.ByteString or collections.abc.ByteString.\n\nRationale: ByteString has been deprecated since Python 3.9 and will be removed in\nPython 3.14. The Python documentation recommends using either\ncollections.abc.Buffer (or the typing_extensions backport\non Python \\<3.12) or a union like bytes | bytearray | memoryview instead.\n\nExample:\nfrom typing import ByteString\n\n\n\nUse instead:\n\n\nfrom collections.abc import Buffer\n\n# Idiom PYI058 (generator-return-from-iter-method)\n\nDefinition: Checks for simple __iter__ methods that return Generator, and for\nsimple __aiter__ methods that return AsyncGenerator.\n\nRationale: Using (Async)Iterator for these methods is simpler and more elegant. More\nimportantly, it also reflects the fact that the precise kind of iterator\nreturned from an __iter__ method is usually an implementation detail that\ncould change at any time. Type annotations help define a contract for a\nfunction; implementation details should not leak into that contract.\n\n\nFor example:\n\n\nfrom collections.abc import AsyncGenerator, Generator\nfrom typing import Any\n\n\nclass CustomIterator:\n    def __iter__(self) -> Generator:\n        yield from range(42)\n\n\nclass CustomIterator2:\n    def __iter__(self) -> Generator[str, Any, None]:\n        yield from \"abcdefg\"\n\n\n\nUse instead:\n\n\nfrom collections.abc import Iterator\n\n\nclass CustomIterator:\n    def __iter__(self) -> Iterator:\n        yield from range(42)\n\n\nclass CustomIterator2:\n    def __iter__(self) -> Iterator[str]:\n        yield from \"abdefg\"\n\n# Idiom PYI059 (generic-not-last-base-class)\n\nDefinition: Checks for classes inheriting from typing.Generic[] where Generic[] is\nnot the last base class in the bases tuple.\n\nRationale: If Generic[] is not the final class in the bases tuple, unexpected\nbehaviour can occur at runtime (See this CPython issue for an example).\nThe rule is also applied to stub files, but, unlike at runtime,\nin stubs it is purely enforced for stylistic consistency.\n\n\nFor example:\n\n\nclass LinkedList(Generic[T], Sized):\n    def push(self, item: T) -> None:\n        self._items.append(item)\n\nclass MyMapping(\n    Generic[K, V],\n    Iterable[Tuple[K, V]],\n    Container[Tuple[K, V]],\n):\n    ...\n\n\n\nUse instead:\n\n\nclass LinkedList(Sized, Generic[T]):\n    def push(self, item: T) -> None:\n        self._items.append(item)\n\nclass MyMapping(\n    Iterable[Tuple[K, V]],\n    Container[Tuple[K, V]],\n    Generic[K, V],\n):\n    ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/A004-A005-A006",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom A004 (builtin-import-shadowing)\n\nDefinition: Checks for imports that use the same names as builtins.\n\nRationale: Reusing a builtin for the name of an import increases the difficulty\nof reading and maintaining the code, and can cause non-obvious errors,\nas readers may mistake the variable for the builtin and vice versa.\n\n\nBuiltins can be marked as exceptions to this rule via the\nlint.flake8-builtins.ignorelist configuration option.\n\nExample:\nfrom rich import print\n\nprint(\"Some message\")\n\n\n\nUse instead:\n\n\nfrom rich import print as rich_print\n\nrich_print(\"Some message\")\n\n\n\nor:\n\n\nimport rich\n\nrich.print(\"Some message\")\n\n# Idiom A005 (stdlib-module-shadowing)\n\nDefinition: Checks for modules that use the same names as Python standard-library\nmodules.\n\nRationale: Reusing a standard-library module name for the name of a module increases\nthe difficulty of reading and maintaining the code, and can cause\nnon-obvious errors. Readers may mistake the first-party module for the\nstandard-library module and vice versa.\n\n\nStandard-library modules can be marked as exceptions to this rule via the\nlint.flake8-builtins.allowed-modules configuration option.\n\n\nBy default, the module path relative to the project root or src directories is considered,\nso a top-level logging.py or logging/__init__.py will clash with the builtin logging\nmodule, but utils/logging.py, for example, will not. With the\nlint.flake8-builtins.strict-checking option set to true, only the last component\nof the module name is considered, so logging.py, utils/logging.py, and\nutils/logging/__init__.py will all trigger the rule.\n\n\nThis rule is not applied to stub files, as the name of a stub module is out\nof the control of the author of the stub file. Instead, a stub should aim to\nfaithfully emulate the runtime module it is stubbing.\n\n\nAs of Python 3.13, errors from modules that use the same name as\nstandard-library modules now display a custom message.\n\nExample:\n$ touch random.py\n$ python3 -c 'from random import choice'\nTraceback (most recent call last):\n  File \"<string>\", line 1, in <module>\n    from random import choice\nImportError: cannot import name 'choice' from 'random' (consider renaming '/random.py' since it has the same name as the standard library module named 'random' and prevents importing that standard library module)\n\n# Idiom A006 (builtin-lambda-argument-shadowing)\n\nDefinition: Checks for lambda arguments that use the same names as Python builtins.\n\nRationale: Reusing a builtin name for the name of a lambda argument increases the\ndifficulty of reading and maintaining the code and can cause\nnon-obvious errors. Readers may mistake the variable for the\nbuiltin, and vice versa.\n\n\nBuiltins can be marked as exceptions to this rule via the\nlint.flake8-builtins.ignorelist configuration option.\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/D404-D405-D406-D407-D408",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom D404 (docstring-starts-with-this)\n\nDefinition: Checks for docstrings that start with This.\n\nRationale: PEP 257 recommends that the first line of a docstring be written in the\nimperative mood, for consistency.\n\n\nHint: to rewrite the docstring in the imperative, phrase the first line as\nif it were a command.\n\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the numpy\nconvention,, and disabled when using the google and pep257 conventions.\n\nExample:\ndef average(values: list[float]) -> float:\n    \"\"\"This function returns the mean of the given values.\"\"\"\n\n\n\nUse instead:\n\n\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n\n# Idiom D405 (non-capitalized-section-name)\n\nDefinition: Checks for section headers in docstrings that do not begin with capital\nletters.\n\nRationale: For stylistic consistency, all section headers in a docstring should be\ncapitalized.\n\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections. Each section typically has\na header and a body.\n\n\nThis rule is enabled when using the numpy and google conventions, and\ndisabled when using the pep257 convention.\n\nExample:\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    returns:\n        Speed as distance divided by time.\n\n    raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n\n\nUse instead:\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n# Idiom D406 (missing-new-line-after-section-name)\n\nDefinition: Checks for section headers in docstrings that are followed by non-newline\ncharacters.\n\nRationale: This rule enforces a consistent style for multiline numpy-style docstrings.\n\n\nMultiline numpy-style docstrings are typically composed of a summary line,\nfollowed by a blank line, followed by a series of sections. Each section\nhas a section header and a section body. The section header should be\nfollowed by a newline, rather than by some other character (like a colon).\n\n\nThis rule is enabled when using the numpy convention, and disabled\nwhen using the google or pep257 conventions.\n\nExample:\n# The `Parameters`, `Returns` and `Raises` section headers are all followed\n# by a colon in this function's docstring:\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters:\n    -----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns:\n    --------\n    float\n        Speed as distance divided by time.\n\n    Raises:\n    -------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n\n\nUse instead:\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n# Idiom D407 (missing-dashed-underline-after-section)\n\nDefinition: Checks for section headers in docstrings that are not followed by\nunderlines.\n\nRationale: This rule enforces a consistent style for multiline numpy-style docstrings,\nand helps prevent incorrect syntax in docstrings using reStructuredText.\n\n\nMultiline numpy-style docstrings are typically composed of a summary line,\nfollowed by a blank line, followed by a series of sections. Each section\nhas a section header and a section body, and the header should be followed\nby a series of underline characters in the following line.\n\n\nThis rule enforces a consistent style for multiline numpy-style docstrings\nwith sections. If your docstring uses reStructuredText, the rule also\nhelps protect against incorrect reStructuredText syntax, which would cause\nerrors if you tried to use a tool such as Sphinx to generate documentation\nfrom the docstring.\n\n\nThis rule is enabled when using the numpy convention, and disabled\nwhen using the google or pep257 conventions.\n\nExample:\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n\n    float\n        Speed as distance divided by time.\n\n    Raises\n\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n\n\nUse instead:\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n# Idiom D408 (missing-section-underline-after-name)\n\nDefinition: Checks for section underlines in docstrings that are not on the line\nimmediately following the section name.\n\nRationale: This rule enforces a consistent style for multiline numpy-style docstrings,\nand helps prevent incorrect syntax in docstrings using reStructuredText.\n\n\nMultiline numpy-style docstrings are typically composed of a summary line,\nfollowed by a blank line, followed by a series of sections. Each section\nhas a header and a body. There should be a series of underline characters\nin the line immediately below the header.\n\n\nThis rule enforces a consistent style for multiline numpy-style docstrings\nwith sections. If your docstring uses reStructuredText, the rule also\nhelps protect against incorrect reStructuredText syntax, which would cause\nerrors if you tried to use a tool such as Sphinx to generate documentation\nfrom the docstring.\n\n\nThis rule is enabled when using the numpy convention, and disabled\nwhen using the google or pep257 conventions.\n\nExample:\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n\n\nUse instead:\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PYI061-PYI062-PYI063-PYI064-PYI066",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PYI061 (redundant-none-literal)\n\nDefinition: Checks for redundant Literal[None] annotations.\n\nRationale: While Literal[None] is a valid type annotation, it is semantically equivalent to None.\nPrefer None over Literal[None] for both consistency and readability.\n\nExample:\nfrom typing import Literal\n\nLiteral[None]\nLiteral[1, 2, 3, \"foo\", 5, None]\n\n\n\nUse instead:\n\n\nfrom typing import Literal\n\nNone\nLiteral[1, 2, 3, \"foo\", 5] | None\n\n# Idiom PYI062 (duplicate-literal-member)\n\nDefinition: Checks for duplicate members in a typing.Literal[] slice.\n\nRationale: Duplicate literal members are redundant and should be removed.\n\nExample:\nfoo: Literal[\"a\", \"b\", \"a\"]\n\n\n\nUse instead:\n\n\nfoo: Literal[\"a\", \"b\"]\n\n# Idiom PYI063 (pep484-style-positional-only-parameter)\n\nDefinition: Checks for the presence of PEP 484-style positional-only parameters.\n\nRationale: Historically, PEP 484 recommended prefixing parameter names with double\nunderscores (__) to indicate to a type checker that they were\npositional-only. However, PEP 570 (introduced in Python 3.8) introduced\ndedicated syntax for positional-only arguments. If a forward slash (/) is\npresent in a function signature on Python 3.8+, all parameters prior to the\nslash are interpreted as positional-only.\n\n\nThe new syntax should be preferred as it is more widely used, more concise\nand more readable. It is also respected by Python at runtime, whereas the\nold-style syntax was only understood by type checkers.\n\nExample:\ndef foo(__x: int) -> None: ...\n\n\n\nUse instead:\n\n\ndef foo(x: int, /) -> None: ...\n\n# Idiom PYI064 (redundant-final-literal)\n\nDefinition: Checks for redundant Final[Literal[...]] annotations.\n\nRationale: All constant variables annotated as Final are understood as implicitly\nhaving Literal types by a type checker. As such, a Final[Literal[...]]\nannotation can often be replaced with a bare Final, annotation, which\nwill have the same meaning to the type checker while being more concise and\nmore readable.\n\nExample:\nfrom typing import Final, Literal\n\nx: Final[Literal[42]]\ny: Final[Literal[42]] = 42\n\n\n\nUse instead:\n\n\nfrom typing import Final, Literal\n\nx: Final = 42\ny: Final = 42\n\n# Idiom PYI066 (bad-version-info-order)\n\nDefinition: Checks for code that branches on sys.version_info comparisons where\nbranches corresponding to older Python versions come before branches\ncorresponding to newer Python versions.\n\nRationale: As a convention, branches that correspond to newer Python versions should\ncome first. This makes it easier to understand the desired behavior, which\ntypically corresponds to the latest Python versions.\n\n\nThis rule enforces the convention by checking for if tests that compare\nsys.version_info with < rather than >=.\n\n\nBy default, this rule only applies to stub files.\nIn preview, it will also flag this anti-pattern in non-stub files.\n\nExample:\nimport sys\n\nif sys.version_info < (3, 10):\n    def read_data(x, *, preserve_order=True): ...\n\nelse:\n    def read_data(x): ...\n\n\n\nUse instead:\n\n\nif sys.version_info >= (3, 10):\n    def read_data(x): ...\n\nelse:\n    def read_data(x, *, preserve_order=True): ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/FURB101-FURB103-FURB105-FURB110-FURB113",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom FURB101 (read-whole-file)\n\nDefinition: Checks for uses of open and read that can be replaced by pathlib\nmethods, like Path.read_text and Path.read_bytes.\n\nRationale: When reading the entire contents of a file into a variable, it's simpler\nand more concise to use pathlib methods like Path.read_text and\nPath.read_bytes instead of open and read calls via with statements.\n\nExample:\nwith open(filename) as f:\n    contents = f.read()\n\n\n\nUse instead:\n\n\nfrom pathlib import Path\n\ncontents = Path(filename).read_text()\n\n# Idiom FURB103 (write-whole-file)\n\nDefinition: Checks for uses of open and write that can be replaced by pathlib\nmethods, like Path.write_text and Path.write_bytes.\n\nRationale: When writing a single string to a file, it's simpler and more concise\nto use pathlib methods like Path.write_text and Path.write_bytes\ninstead of open and write calls via with statements.\n\nExample:\nwith open(filename, \"w\") as f:\n    f.write(contents)\n\n\n\nUse instead:\n\n\nfrom pathlib import Path\n\nPath(filename).write_text(contents)\n\n# Idiom FURB105 (print-empty-string)\n\nDefinition: Checks for print calls with unnecessary empty strings as positional\narguments and unnecessary sep keyword arguments.\n\nRationale: Prefer calling print without any positional arguments, which is\nequivalent and more concise.\n\n\nSimilarly, when printing one or fewer items, the sep keyword argument,\n(used to define the string that separates the print arguments) can be\nomitted, as it's redundant when there are no items to separate.\n\nExample:\nprint(\"\")\n\n\n\nUse instead:\n\n\nprint()\n\n# Idiom FURB110 (if-exp-instead-of-or-operator)\n\nDefinition: Checks for ternary if expressions that can be replaced with the or\noperator.\n\nRationale: Ternary if expressions are more verbose than or expressions while\nproviding the same functionality.\n\nExample:\nz = x if x else y\n\n\n\nUse instead:\n\n\nz = x or y\n\n# Idiom FURB113 (repeated-append)\n\nDefinition: Checks for consecutive calls to append.\n\nRationale: Consecutive calls to append can be less efficient than batching them into\na single extend. Each append resizes the list individually, whereas an\nextend can resize the list once for all elements.\n\nExample:\nnums = [1, 2, 3]\n\nnums.append(4)\nnums.append(5)\nnums.append(6)\n\n\n\nUse instead:\n\n\nnums = [1, 2, 3]\n\nnums.extend((4, 5, 6))\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/DTZ006-DTZ007-DTZ011-DTZ012-DTZ901",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom DTZ006 (call-datetime-fromtimestamp)\n\nDefinition: Checks for usage of datetime.datetime.fromtimestamp() that do not specify\na timezone.\n\nRationale: Python datetime objects can be naive or timezone-aware. While an aware\nobject represents a specific moment in time, a naive object does not\ncontain enough information to unambiguously locate itself relative to other\ndatetime objects. Since this can lead to errors, it is recommended to\nalways use timezone-aware objects.\n\n\ndatetime.datetime.fromtimestamp(ts) or\ndatetime.datetime.fromtimestampe(ts, tz=None) returns a naive datetime\nobject. Instead, use datetime.datetime.fromtimestamp(ts, tz=<timezone>)\nto create a timezone-aware object.\n\nExample:\nimport datetime\n\ndatetime.datetime.fromtimestamp(946684800)\n\n\n\nUse instead:\n\n\nimport datetime\n\ndatetime.datetime.fromtimestamp(946684800, tz=datetime.timezone.utc)\n\n\n\nOr, on Python 3.11 and later:\n\n\nimport datetime\n\ndatetime.datetime.fromtimestamp(946684800, tz=datetime.UTC)\n\n# Idiom DTZ007 (call-datetime-strptime-without-zone)\n\nDefinition: Checks for uses of datetime.datetime.strptime() that lead to naive\ndatetime objects.\n\nRationale: Python datetime objects can be naive or timezone-aware. While an aware\nobject represents a specific moment in time, a naive object does not\ncontain enough information to unambiguously locate itself relative to other\ndatetime objects. Since this can lead to errors, it is recommended to\nalways use timezone-aware objects.\n\n\ndatetime.datetime.strptime() without %z returns a naive datetime\nobject. Follow it with .replace(tzinfo=<timezone>) or .astimezone().\n\nExample:\nimport datetime\n\ndatetime.datetime.strptime(\"2022/01/31\", \"%Y/%m/%d\")\n\n\n\nInstead, use .replace(tzinfo=<timezone>):\n\n\nimport datetime\n\ndatetime.datetime.strptime(\"2022/01/31\", \"%Y/%m/%d\").replace(\n    tzinfo=datetime.timezone.utc\n)\n\n\n\nOr, use .astimezone():\n\n\nimport datetime\n\ndatetime.datetime.strptime(\"2022/01/31\", \"%Y/%m/%d\").astimezone(datetime.timezone.utc)\n\n\n\nOn Python 3.11 and later, datetime.timezone.utc can be replaced with\ndatetime.UTC.\n\n# Idiom DTZ011 (call-date-today)\n\nDefinition: Checks for usage of datetime.date.today().\n\nRationale: Python datetime objects can be naive or timezone-aware. While an aware\nobject represents a specific moment in time, a naive object does not\ncontain enough information to unambiguously locate itself relative to other\ndatetime objects. Since this can lead to errors, it is recommended to\nalways use timezone-aware objects.\n\n\ndatetime.date.today returns a naive datetime object. Instead, use\ndatetime.datetime.now(tz=...).date() to create a timezone-aware object.\n\nExample:\nimport datetime\n\ndatetime.datetime.today()\n\n\n\nUse instead:\n\n\nimport datetime\n\ndatetime.datetime.now(tz=datetime.timezone.utc).date()\n\n\n\nOr, for Python 3.11 and later:\n\n\nimport datetime\n\ndatetime.datetime.now(tz=datetime.UTC).date()\n\n# Idiom DTZ012 (call-date-fromtimestamp)\n\nDefinition: Checks for usage of datetime.date.fromtimestamp().\n\nRationale: Python datetime objects can be naive or timezone-aware. While an aware\nobject represents a specific moment in time, a naive object does not\ncontain enough information to unambiguously locate itself relative to other\ndatetime objects. Since this can lead to errors, it is recommended to\nalways use timezone-aware objects.\n\n\ndatetime.date.fromtimestamp(ts) returns a naive datetime object.\nInstead, use datetime.datetime.fromtimestamp(ts, tz=...) to create a\ntimezone-aware object.\n\nExample:\nimport datetime\n\ndatetime.date.fromtimestamp(946684800)\n\n\n\nUse instead:\n\n\nimport datetime\n\ndatetime.datetime.fromtimestamp(946684800, tz=datetime.timezone.utc)\n\n\n\nOr, for Python 3.11 and later:\n\n\nimport datetime\n\ndatetime.datetime.fromtimestamp(946684800, tz=datetime.UTC)\n\n# Idiom DTZ901 (datetime-min-max)\n\nDefinition: Checks for uses of datetime.datetime.min and datetime.datetime.max.\n\nRationale: datetime.min and datetime.max are non-timezone-aware datetime objects.\n\n\nAs such, operations on datetime.min and datetime.max may behave\nunexpectedly, as in:\n\n\n# Timezone: UTC-14\ndatetime.min.timestamp()  # ValueError: year 0 is out of range\ndatetime.max.timestamp()  # ValueError: year 10000 is out of range\n\nExample:\ndatetime.max\n\n\n\nUse instead:\n\n\ndatetime.max.replace(tzinfo=datetime.UTC)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/D207-D208-D209-D210-D211",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom D207 (under-indentation)\n\nDefinition: Checks for under-indented docstrings.\n\nRationale: PEP 257 recommends that docstrings be indented to the same level as their\nopening quotes. Avoid under-indenting docstrings, for consistency.\n\nExample:\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\nSort the list in ascending order and return a copy of the result using the bubble sort\nalgorithm.\n    \"\"\"\n\n\n\nUse instead:\n\n\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n\n# Idiom D208 (over-indentation)\n\nDefinition: Checks for over-indented docstrings.\n\nRationale: PEP 257 recommends that docstrings be indented to the same level as their\nopening quotes. Avoid over-indenting docstrings, for consistency.\n\nExample:\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n        Sort the list in ascending order and return a copy of the result using the\n        bubble sort algorithm.\n    \"\"\"\n\n\n\nUse instead:\n\n\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n\n# Idiom D209 (new-line-after-last-paragraph)\n\nDefinition: Checks for multi-line docstrings whose closing quotes are not on their\nown line.\n\nRationale: PEP 257 recommends that the closing quotes of a multi-line docstring be\non their own line, for consistency and compatibility with documentation\ntools that may need to parse the docstring.\n\nExample:\ndef sort_list(l: List[int]) -> List[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the\n    bubble sort algorithm.\"\"\"\n\n\n\nUse instead:\n\n\ndef sort_list(l: List[int]) -> List[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n\n# Idiom D210 (surrounding-whitespace)\n\nDefinition: Checks for surrounding whitespace in docstrings.\n\nRationale: Remove surrounding whitespace from the docstring, for consistency.\n\nExample:\ndef factorial(n: int) -> int:\n    \"\"\" Return the factorial of n. \"\"\"\n\n\n\nUse instead:\n\n\ndef factorial(n: int) -> int:\n    \"\"\"Return the factorial of n.\"\"\"\n\n# Idiom D211 (blank-line-before-class)\n\nDefinition: Checks for docstrings on class definitions that are preceded by a blank\nline.\n\nRationale: Avoid introducing any blank lines between a class definition and its\ndocstring, for consistency.\n\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the google,\nnumpy, and pep257 conventions.\n\n\nFor an alternative, see D203.\n\nExample:\nclass PhotoMetadata:\n\n    \"\"\"Metadata about a photo.\"\"\"\n\n\n\nUse instead:\n\n\nclass PhotoMetadata:\n    \"\"\"Metadata about a photo.\"\"\"\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/ANN204-ANN205-ANN206-ANN401",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom ANN204 (missing-return-type-special-method)\n\nDefinition: Checks that \"special\" methods, like __init__, __new__, and __call__, have\nreturn type annotations.\n\nRationale: Type annotations are a good way to document the return types of functions. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany returned values, and the types expected by callers, match expectation.\n\n\nNote that type checkers often allow you to omit the return type annotation for\n__init__ methods, as long as at least one argument has a type annotation. To\nopt in to this behavior, use the mypy-init-return setting in your pyproject.toml\nor ruff.toml file:\n\n\n[tool.ruff.lint.flake8-annotations]\nmypy-init-return = true\n\nExample:\nclass Foo:\n    def __init__(self, x: int):\n        self.x = x\n\n\n\nUse instead:\n\n\nclass Foo:\n    def __init__(self, x: int) -> None:\n        self.x = x\n\n# Idiom ANN205 (missing-return-type-static-method)\n\nDefinition: Checks that static methods have return type annotations.\n\nRationale: Type annotations are a good way to document the return types of functions. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany returned values, and the types expected by callers, match expectation.\n\nExample:\nclass Foo:\n    @staticmethod\n    def bar():\n        return 1\n\n\n\nUse instead:\n\n\nclass Foo:\n    @staticmethod\n    def bar() -> int:\n        return 1\n\n# Idiom ANN206 (missing-return-type-class-method)\n\nDefinition: Checks that class methods have return type annotations.\n\nRationale: Type annotations are a good way to document the return types of functions. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany returned values, and the types expected by callers, match expectation.\n\nExample:\nclass Foo:\n    @classmethod\n    def bar(cls):\n        return 1\n\n\n\nUse instead:\n\n\nclass Foo:\n    @classmethod\n    def bar(cls) -> int:\n        return 1\n\n# Idiom ANN401 (any-type)\n\nDefinition: Checks that function arguments are annotated with a more specific type than\nAny.\n\nRationale: Any is a special type indicating an unconstrained type. When an\nexpression is annotated with type Any, type checkers will allow all\noperations on it.\n\n\nIt's better to be explicit about the type of an expression, and to use\nAny as an \"escape hatch\" only when it is really needed.\n\nExample:\ndef foo(x: Any): ...\n\n\n\nUse instead:\n\n\ndef foo(x: int): ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/UP012-UP013-UP014-UP015-UP017",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom UP012 (unnecessary-encode-utf8)\n\nDefinition: Checks for unnecessary calls to encode as UTF-8.\n\nRationale: UTF-8 is the default encoding in Python, so there is no need to call\nencode when UTF-8 is the desired encoding. Instead, use a bytes literal.\n\nExample:\n\"foo\".encode(\"utf-8\")\n\n\n\nUse instead:\n\n\nb\"foo\"\n\n# Idiom UP013 (convert-typed-dict-functional-to-class)\n\nDefinition: Checks for TypedDict declarations that use functional syntax.\n\nRationale: TypedDict types can be defined either through a functional syntax\n(Foo = TypedDict(...)) or a class syntax (class Foo(TypedDict): ...).\n\n\nThe class syntax is more readable and generally preferred over the\nfunctional syntax.\n\n\nNonetheless, there are some situations in which it is impossible to use\nthe class-based syntax. This rule will not apply to those cases. Namely,\nit is impossible to use the class-based syntax if any TypedDict fields are:\n\n\n\nNot valid python identifiers (for example, @x)\nPython keywords such as in\nPrivate names such as __id that would undergo name mangling at runtime\n    if the class-based syntax was used\nDunder names such as __int__ that can confuse type checkers if they're used\n    with the class-based syntax.\n\nExample:\nfrom typing import TypedDict\n\nFoo = TypedDict(\"Foo\", {\"a\": int, \"b\": str})\n\n\n\nUse instead:\n\n\nfrom typing import TypedDict\n\n\nclass Foo(TypedDict):\n    a: int\n    b: str\n\n# Idiom UP014 (convert-named-tuple-functional-to-class)\n\nDefinition: Checks for NamedTuple declarations that use functional syntax.\n\nRationale: NamedTuple subclasses can be defined either through a functional syntax\n(Foo = NamedTuple(...)) or a class syntax (class Foo(NamedTuple): ...).\n\n\nThe class syntax is more readable and generally preferred over the\nfunctional syntax, which exists primarily for backwards compatibility\nwith collections.namedtuple.\n\nExample:\nfrom typing import NamedTuple\n\nFoo = NamedTuple(\"Foo\", [(\"a\", int), (\"b\", str)])\n\n\n\nUse instead:\n\n\nfrom typing import NamedTuple\n\n\nclass Foo(NamedTuple):\n    a: int\n    b: str\n\n# Idiom UP015 (redundant-open-modes)\n\nDefinition: Checks for redundant open mode arguments.\n\nRationale: Redundant open mode arguments are unnecessary and should be removed to\navoid confusion.\n\nExample:\nwith open(\"foo.txt\", \"r\") as f:\n    ...\n\n\n\nUse instead:\n\n\nwith open(\"foo.txt\") as f:\n    ...\n\n# Idiom UP017 (datetime-timezone-utc)\n\nDefinition: Checks for uses of datetime.timezone.utc.\n\nRationale: As of Python 3.11, datetime.UTC is an alias for datetime.timezone.utc.\nThe alias is more readable and generally preferred over the full path.\n\nExample:\nimport datetime\n\ndatetime.timezone.utc\n\n\n\nUse instead:\n\n\nimport datetime\n\ndatetime.UTC\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PT023-PT024-PT025-PT026-PT027",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PT023 (pytest-incorrect-mark-parentheses-style)\n\nDefinition: Checks for argument-free @pytest.mark.<marker>() decorators with or\nwithout parentheses, depending on the lint.flake8-pytest-style.mark-parentheses\nsetting.\n\n\nThe rule defaults to removing unnecessary parentheses,\nto match the documentation of the official pytest projects.\n\nRationale: If a @pytest.mark.<marker>() doesn't take any arguments, the parentheses are\noptional.\n\n\nEither removing those unnecessary parentheses or requiring them for all\nfixtures is fine, but it's best to be consistent.\n\nExample:\nimport pytest\n\n\n@pytest.mark.foo\ndef test_something(): ...\n\n\n\nUse instead:\n\n\nimport pytest\n\n\n@pytest.mark.foo()\ndef test_something(): ...\n\n# Idiom PT024 (pytest-unnecessary-asyncio-mark-on-fixture)\n\nDefinition: Checks for unnecessary @pytest.mark.asyncio decorators applied to fixtures.\n\nRationale: pytest.mark.asyncio is unnecessary for fixtures.\n\nExample:\nimport pytest\n\n\n@pytest.mark.asyncio()\n@pytest.fixture()\nasync def my_fixture():\n    return 0\n\n\n\nUse instead:\n\n\nimport pytest\n\n\n@pytest.fixture()\nasync def my_fixture():\n    return 0\n\n# Idiom PT025 (pytest-erroneous-use-fixtures-on-fixture)\n\nDefinition: Checks for pytest.mark.usefixtures decorators applied to pytest\nfixtures.\n\nRationale: The pytest.mark.usefixtures decorator has no effect on pytest fixtures.\n\nExample:\nimport pytest\n\n\n@pytest.fixture()\ndef a():\n    pass\n\n\n@pytest.mark.usefixtures(\"a\")\n@pytest.fixture()\ndef b(a):\n    pass\n\n\n\nUse instead:\n\n\nimport pytest\n\n\n@pytest.fixture()\ndef a():\n    pass\n\n\n@pytest.fixture()\ndef b(a):\n    pass\n\n# Idiom PT026 (pytest-use-fixtures-without-parameters)\n\nDefinition: Checks for @pytest.mark.usefixtures() decorators that aren't passed any\narguments.\n\nRationale: A @pytest.mark.usefixtures() decorator that isn't passed any arguments is\nuseless and should be removed.\n\nExample:\nimport pytest\n\n\n@pytest.mark.usefixtures()\ndef test_something(): ...\n\n\n\nUse instead:\n\n\ndef test_something(): ...\n\n# Idiom PT027 (pytest-unittest-raises-assertion)\n\nDefinition: Checks for uses of exception-related assertion methods from the unittest\nmodule.\n\nRationale: To enforce the assertion style recommended by pytest, pytest.raises is\npreferred over the exception-related assertion methods in unittest, like\nassertRaises.\n\nExample:\nimport unittest\n\n\nclass TestFoo(unittest.TestCase):\n    def test_foo(self):\n        with self.assertRaises(ValueError):\n            raise ValueError(\"foo\")\n\n\n\nUse instead:\n\n\nimport unittest\nimport pytest\n\n\nclass TestFoo(unittest.TestCase):\n    def test_foo(self):\n        with pytest.raises(ValueError):\n            raise ValueError(\"foo\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/D202-D203-D204-D205-D206",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom D202 (blank-line-after-function)\n\nDefinition: Checks for docstrings on functions that are separated by one or more blank\nlines from the function body.\n\nRationale: Remove any blank lines between the function body and the function\ndocstring, for consistency.\n\nExample:\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n\n    return sum(values) / len(values)\n\n\n\nUse instead:\n\n\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n    return sum(values) / len(values)\n\n# Idiom D203 (incorrect-blank-line-before-class)\n\nDefinition: Checks for docstrings on class definitions that are not preceded by a\nblank line.\n\nRationale: Use a blank line to separate the docstring from the class definition, for\nconsistency.\n\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is disabled when using the google,\nnumpy, and pep257 conventions.\n\n\nFor an alternative, see D211.\n\nExample:\nclass PhotoMetadata:\n    \"\"\"Metadata about a photo.\"\"\"\n\n\n\nUse instead:\n\n\nclass PhotoMetadata:\n\n    \"\"\"Metadata about a photo.\"\"\"\n\n# Idiom D204 (incorrect-blank-line-after-class)\n\nDefinition: Checks for class methods that are not separated from the class's docstring\nby a blank line.\n\nRationale: PEP 257 recommends the use of a blank line to separate a class's\ndocstring from its methods.\n\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the numpy and pep257\nconventions, and disabled when using the google convention.\n\nExample:\nclass PhotoMetadata:\n    \"\"\"Metadata about a photo.\"\"\"\n    def __init__(self, file: Path):\n        ...\n\n\n\nUse instead:\n\n\nclass PhotoMetadata:\n    \"\"\"Metadata about a photo.\"\"\"\n\n    def __init__(self, file: Path):\n        ...\n\n# Idiom D205 (missing-blank-line-after-summary)\n\nDefinition: Checks for docstring summary lines that are not separated from the docstring\ndescription by one blank line.\n\nRationale: PEP 257 recommends that multi-line docstrings consist of \"a summary line\njust like a one-line docstring, followed by a blank line, followed by a\nmore elaborate description.\"\n\nExample:\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n    Sort the list in ascending order and return a copy of the\n    result using the bubble sort algorithm.\n    \"\"\"\n\n\n\nUse instead:\n\n\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the\n    result using the bubble sort algorithm.\n    \"\"\"\n\n# Idiom D206 (docstring-tab-indentation)\n\nDefinition: Checks for docstrings that are indented with tabs.\n\nRationale: PEP 8 recommends using spaces over tabs for indentation.\n\nExample:\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n\n\n\nUse instead:\n\n\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PGH003-PGH004-PGH005",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PGH003 (blanket-type-ignore)\n\nDefinition: Check for type: ignore annotations that suppress all type warnings, as\nopposed to targeting specific type warnings.\n\nRationale: Suppressing all warnings can hide issues in the code.\n\n\nBlanket type: ignore annotations are also more difficult to interpret and\nmaintain, as the annotation does not clarify which warnings are intended\nto be suppressed.\n\nExample:\nfrom foo import secrets  # type: ignore\n\n\n\nUse instead:\n\n\nfrom foo import secrets  # type: ignore[attr-defined]\n\n# Idiom PGH004 (blanket-noqa)\n\nDefinition: Check for noqa annotations that suppress all diagnostics, as opposed to\ntargeting specific diagnostics.\n\nRationale: Suppressing all diagnostics can hide issues in the code.\n\n\nBlanket noqa annotations are also more difficult to interpret and\nmaintain, as the annotation does not clarify which diagnostics are intended\nto be suppressed.\n\nExample:\nfrom .base import *  # noqa\n\n\n\nUse instead:\n\n\nfrom .base import *  # noqa: F403\n\n# Idiom PGH005 (invalid-mock-access)\n\nDefinition: Checks for common mistakes when using mock objects.\n\nRationale: The mock module exposes an assertion API that can be used to verify that\nmock objects undergo expected interactions. This rule checks for common\nmistakes when using this API.\n\n\nFor example, it checks for mock attribute accesses that should be replaced\nwith mock method calls.\n\nExample:\nmy_mock.assert_called\n\n\n\nUse instead:\n\n\nmy_mock.assert_called()\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PYI030-PYI032-PYI033-PYI034-PYI035",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PYI030 (unnecessary-literal-union)\n\nDefinition: Checks for the presence of multiple literal types in a union.\n\nRationale: Literal[\"foo\", 42] has identical semantics to\nLiteral[\"foo\"] | Literal[42], but is clearer and more concise.\n\nExample:\nfrom typing import Literal\n\nfield: Literal[1] | Literal[2] | str\n\n\n\nUse instead:\n\n\nfrom typing import Literal\n\nfield: Literal[1, 2] | str\n\n# Idiom PYI032 (any-eq-ne-annotation)\n\nDefinition: Checks for __eq__ and __ne__ implementations that use typing.Any as\nthe type annotation for their second parameter.\n\nRationale: The Python documentation recommends the use of object to \"indicate that a\nvalue could be any type in a typesafe manner\". Any, on the other hand,\nshould be seen as an \"escape hatch when you need to mix dynamically and\nstatically typed code\". Since using Any allows you to write highly unsafe\ncode, you should generally only use Any when the semantics of your code\nwould otherwise be inexpressible to the type checker.\n\n\nThe expectation in Python is that a comparison of two arbitrary objects\nusing == or != should never raise an exception. This contract can be\nfully expressed in the type system and does not involve requesting unsound\nbehaviour from a type checker. As such, object is a more appropriate\nannotation than Any for the second parameter of the methods implementing\nthese comparison operators -- __eq__ and __ne__.\n\nExample:\nclass Foo:\n    def __eq__(self, obj: typing.Any) -> bool: ...\n\n\n\nUse instead:\n\n\nclass Foo:\n    def __eq__(self, obj: object) -> bool: ...\n\n# Idiom PYI033 (type-comment-in-stub)\n\nDefinition: Checks for the use of type comments (e.g., x = 1  # type: int) in stub\nfiles.\n\nRationale: Stub (.pyi) files should use type annotations directly, rather\nthan type comments, even if they're intended to support Python 2, since\nstub files are not executed at runtime. The one exception is # type: ignore.\n\nExample:\nx = 1  # type: int\n\n\n\nUse instead:\n\n\nx: int = 1\n\n# Idiom PYI034 (non-self-return-type)\n\nDefinition: Checks for methods that are annotated with a fixed return type which\nshould instead be returning Self.\n\nRationale: If methods that generally return self at runtime are annotated with a\nfixed return type, and the class is subclassed, type checkers will not be\nable to infer the correct return type.\n\n\nFor example:\n\n\nclass Shape:\n    def set_scale(self, scale: float) -> Shape:\n        self.scale = scale\n        return self\n\nclass Circle(Shape):\n    def set_radius(self, radius: float) -> Circle:\n        self.radius = radius\n        return self\n\n# Type checker infers return type as `Shape`, not `Circle`.\nCircle().set_scale(0.5)\n\n# Thus, this expression is invalid, as `Shape` has no attribute `set_radius`.\nCircle().set_scale(0.5).set_radius(2.7)\n\n\n\nSpecifically, this check enforces that the return type of the following\nmethods is Self:\n\n\n\nIn-place binary-operation dunder methods, like __iadd__, __imul__, etc.\n__new__, __enter__, and __aenter__, if those methods return the\n    class name.\n__iter__ methods that return Iterator, despite the class inheriting\n    directly from Iterator.\n__aiter__ methods that return AsyncIterator, despite the class\n    inheriting directly from AsyncIterator.\n\nExample:\nclass Foo:\n    def __new__(cls, *args: Any, **kwargs: Any) -> Foo: ...\n    def __enter__(self) -> Foo: ...\n    async def __aenter__(self) -> Foo: ...\n    def __iadd__(self, other: Foo) -> Foo: ...\n\n\n\nUse instead:\n\n\nfrom typing_extensions import Self\n\nclass Foo:\n    def __new__(cls, *args: Any, **kwargs: Any) -> Self: ...\n    def __enter__(self) -> Self: ...\n    async def __aenter__(self) -> Self: ...\n    def __iadd__(self, other: Foo) -> Self: ...\n\n# Idiom PYI035 (unassigned-special-variable-in-stub)\n\nDefinition: Checks that __all__, __match_args__, and __slots__ variables are\nassigned to values when defined in stub files.\n\nRationale: Special variables like __all__ have the same semantics in stub files\nas they do in Python modules, and so should be consistent with their\nruntime counterparts.\n\nExample:\n__all__: list[str]\n\n\n\nUse instead:\n\n\n__all__: list[str] = [\"foo\", \"bar\"]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/B905-B909-B911",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom B905 (zip-without-explicit-strict)\n\nDefinition: Checks for zip calls without an explicit strict parameter.\n\nRationale: By default, if the iterables passed to zip are of different lengths, the\nresulting iterator will be silently truncated to the length of the shortest\niterable. This can lead to subtle bugs.\n\n\nPass strict=True to raise a ValueError if the iterables are of\nnon-uniform length. Alternatively, if the iterables are deliberately of\ndifferent lengths, pass strict=False to make the intention explicit.\n\nExample:\nzip(a, b)\n\n\n\nUse instead:\n\n\nzip(a, b, strict=True)\n\n# Idiom B909 (loop-iterator-mutation)\n\nDefinition: Checks for mutations to an iterable during a loop iteration.\n\nRationale: When iterating over an iterable, mutating the iterable can lead to unexpected\nbehavior, like skipping elements or infinite loops.\n\nExample:\nitems = [1, 2, 3]\n\nfor item in items:\n    print(item)\n\n    # Create an infinite loop by appending to the list.\n    items.append(item)\n\n# Idiom B911 (batched-without-explicit-strict)\n\nDefinition: Checks for itertools.batched calls without an explicit strict parameter.\n\nRationale: By default, if the length of the iterable is not divisible by\nthe second argument to itertools.batched, the last batch\nwill be shorter than the rest.\n\n\nIn Python 3.13, a strict parameter was added which allows controlling if the batches must be of uniform length.\nPass strict=True to raise a ValueError if the batches are of non-uniform length.\nOtherwise, pass strict=False to make the intention explicit.\n\nExample:\nitertools.batched(iterable, n)\n\n\n\nUse instead if the batches must be of uniform length:\n\n\nitertools.batched(iterable, n, strict=True)\n\n\n\nOr if the batches can be of non-uniform length:\n\n\nitertools.batched(iterable, n, strict=False)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/F823-F841-F842-F901",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom F823 (undefined-local)\n\nDefinition: Checks for undefined local variables.\n\nRationale: Referencing a local variable before it has been assigned will raise\nan UnboundLocalError at runtime.\n\nExample:\nx = 1\n\n\ndef foo():\n    x += 1\n\n\n\nUse instead:\n\n\nx = 1\n\n\ndef foo():\n    global x\n    x += 1\n\n# Idiom F841 (unused-variable)\n\nDefinition: Checks for the presence of unused variables in function scopes.\n\nRationale: A variable that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\n\nIf a variable is intentionally defined-but-not-used, it should be\nprefixed with an underscore, or some other value that adheres to the\nlint.dummy-variable-rgx pattern.\n\nExample:\ndef foo():\n    x = 1\n    y = 2\n    return x\n\n\n\nUse instead:\n\n\ndef foo():\n    x = 1\n    return x\n\n# Idiom F842 (unused-annotation)\n\nDefinition: Checks for local variables that are annotated but never used.\n\nRationale: Annotations are used to provide type hints to static type checkers. If a\nvariable is annotated but never used, the annotation is unnecessary.\n\nExample:\ndef foo():\n    bar: int\n\n# Idiom F901 (raise-not-implemented)\n\nDefinition: Checks for raise statements that raise NotImplemented.\n\nRationale: NotImplemented is an exception used by binary special methods to indicate\nthat an operation is not implemented with respect to a particular type.\n\n\nNotImplemented should not be raised directly. Instead, raise\nNotImplementedError, which is used to indicate that the method is\nabstract or not implemented in the derived class.\n\nExample:\nclass Foo:\n    def bar(self):\n        raise NotImplemented\n\n\n\nUse instead:\n\n\nclass Foo:\n    def bar(self):\n        raise NotImplementedError\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/E101-E111-E112-E113-E114",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom E101 (mixed-spaces-and-tabs)\n\nDefinition: Checks for mixed tabs and spaces in indentation.\n\nRationale: Never mix tabs and spaces.\n\n\nThe most popular way of indenting Python is with spaces only. The\nsecond-most popular way is with tabs only. Code indented with a\nmixture of tabs and spaces should be converted to using spaces\nexclusively.\n\nExample:\nif a == 0:\\n        a = 1\\n\\tb = 1\n\n\n\nUse instead:\n\n\nif a == 0:\\n    a = 1\\n    b = 1\n\n# Idiom E111 (indentation-with-invalid-multiple)\n\nDefinition: Checks for indentation with a non-multiple of 4 spaces.\n\nRationale: According to PEP 8, 4 spaces per indentation level should be preferred.\n\nExample:\nif True:\n   a = 1\n\n\n\nUse instead:\n\n\nif True:\n    a = 1\n\n# Idiom E112 (no-indented-block)\n\nDefinition: Checks for indented blocks that are lacking indentation.\n\nRationale: All indented blocks should be indented; otherwise, they are not valid\nPython syntax.\n\nExample:\nfor item in items:\npass\n\n\n\nUse instead:\n\n\nfor item in items:\n    pass\n\n# Idiom E113 (unexpected-indentation)\n\nDefinition: Checks for unexpected indentation.\n\nRationale: Indentation outside of a code block is not valid Python syntax.\n\nExample:\na = 1\n    b = 2\n\n\n\nUse instead:\n\n\na = 1\nb = 2\n\n# Idiom E114 (indentation-with-invalid-multiple-comment)\n\nDefinition: Checks for indentation of comments with a non-multiple of 4 spaces.\n\nRationale: According to PEP 8, 4 spaces per indentation level should be preferred.\n\nExample:\nif True:\n   # a = 1\n\n\n\nUse instead:\n\n\nif True:\n    # a = 1\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/LOG001-LOG002-LOG004-LOG007",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom LOG001 (direct-logger-instantiation)\n\nDefinition: Checks for direct instantiation of logging.Logger, as opposed to using\nlogging.getLogger().\n\nRationale: The Logger Objects documentation states that:\n\n\n\nNote that Loggers should NEVER be instantiated directly, but always\nthrough the module-level function logging.getLogger(name).\n\n\n\nIf a logger is directly instantiated, it won't be added to the logger\ntree, and will bypass all configuration. Messages logged to it will\nonly be sent to the \"handler of last resort\", skipping any filtering\nor formatting.\n\nExample:\nimport logging\n\nlogger = logging.Logger(__name__)\n\n\n\nUse instead:\n\n\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n# Idiom LOG002 (invalid-get-logger-argument)\n\nDefinition: Checks for any usage of __cached__ and __file__ as an argument to\nlogging.getLogger().\n\nRationale: The logging documentation recommends this pattern:\n\n\nlogging.getLogger(__name__)\n\n\n\nHere, __name__ is the fully qualified module name, such as foo.bar,\nwhich is the intended format for logger names.\n\n\nThis rule detects probably-mistaken usage of similar module-level dunder constants:\n\n\n\n__cached__ - the pathname of the module's compiled version, such as foo/__pycache__/bar.cpython-311.pyc.\n__file__ - the pathname of the module, such as foo/bar.py.\n\nExample:\nimport logging\n\nlogger = logging.getLogger(__file__)\n\n\n\nUse instead:\n\n\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n# Idiom LOG004 (log-exception-outside-except-handler)\n\nDefinition: Checks for .exception() logging calls outside of exception handlers.\n\nRationale: The documentation states:\n\n\n\nThis function should only be called from an exception handler.\n\n\n\nCalling .exception() outside of an exception handler\nattaches None as exception information, leading to confusing messages:\n\n\n>>> logging.exception(\"example\")\nERROR:root:example\nNoneType: None\n\nExample:\nimport logging\n\nlogging.exception(\"Foobar\")\n\n\n\nUse instead:\n\n\nimport logging\n\nlogging.error(\"Foobar\")\n\n# Idiom LOG007 (exception-without-exc-info)\n\nDefinition: Checks for uses of logging.exception() with exc_info set to False.\n\nRationale: The logging.exception() method captures the exception automatically, but\naccepts an optional exc_info argument to override this behavior. Setting\nexc_info to False disables the automatic capture of the exception and\nstack trace.\n\n\nInstead of setting exc_info to False, prefer logging.error(), which\nhas equivalent behavior to logging.exception() with exc_info set to\nFalse, but is clearer in intent.\n\nExample:\nlogging.exception(\"...\", exc_info=False)\n\n\n\nUse instead:\n\n\nlogging.error(\"...\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/D417-D418-D419",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom D417 (undocumented-param)\n\nDefinition: Checks for function docstrings that do not include documentation for all\nparameters in the function.\n\nRationale: This rule helps prevent you from leaving Google-style docstrings unfinished\nor incomplete. Multiline Google-style docstrings should describe all\nparameters for the function they are documenting.\n\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body. Function docstrings often include a section for\nfunction arguments; this rule is concerned with that section only.\nNote that this rule only checks docstrings with an arguments (e.g. Args) section.\n\n\nThis rule is enabled when using the google convention, and disabled when\nusing the pep257 and numpy conventions.\n\nExample:\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n\n\nUse instead:\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n# Idiom D418 (overload-with-docstring)\n\nDefinition: Checks for @overload function definitions that contain a docstring.\n\nRationale: The @overload decorator is used to define multiple compatible signatures\nfor a given function, to support type-checking. A series of @overload\ndefinitions should be followed by a single non-decorated definition that\ncontains the implementation of the function.\n\n\n@overload function definitions should not contain a docstring; instead,\nthe docstring should be placed on the non-decorated definition that contains\nthe implementation.\n\nExample:\nfrom typing import overload\n\n\n@overload\ndef factorial(n: int) -> int:\n    \"\"\"Return the factorial of n.\"\"\"\n\n\n@overload\ndef factorial(n: float) -> float:\n    \"\"\"Return the factorial of n.\"\"\"\n\n\ndef factorial(n):\n    \"\"\"Return the factorial of n.\"\"\"\n\n\nfactorial.__doc__  # \"Return the factorial of n.\"\n\n\n\nUse instead:\n\n\nfrom typing import overload\n\n\n@overload\ndef factorial(n: int) -> int: ...\n\n\n@overload\ndef factorial(n: float) -> float: ...\n\n\ndef factorial(n):\n    \"\"\"Return the factorial of n.\"\"\"\n\n\nfactorial.__doc__  # \"Return the factorial of n.\"\n\n# Idiom D419 (empty-docstring)\n\nDefinition: Checks for empty docstrings.\n\nRationale: An empty docstring is indicative of incomplete documentation. It should either\nbe removed or replaced with a meaningful docstring.\n\nExample:\ndef average(values: list[float]) -> float:\n    \"\"\"\"\"\"\n\n\n\nUse instead:\n\n\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/D413-D414-D415-D416",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom D413 (missing-blank-line-after-last-section)\n\nDefinition: Checks for missing blank lines after the last section of a multiline\ndocstring.\n\nRationale: This rule enforces a consistent style for multiline docstrings.\n\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, the rule is disabled when using the google,\nnumpy, and pep257 conventions.\n\nExample:\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n\n\nUse instead:\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n# Idiom D414 (empty-docstring-section)\n\nDefinition: Checks for docstrings with empty sections.\n\nRationale: An empty section in a multiline docstring likely indicates an unfinished\nor incomplete docstring.\n\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body. Each section body should be non-empty; empty sections\nshould either have content added to them, or be removed entirely.\n\nExample:\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n\n\nUse instead:\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n# Idiom D415 (missing-terminal-punctuation)\n\nDefinition: Checks for docstrings in which the first line does not end in a punctuation\nmark, such as a period, question mark, or exclamation point.\n\nRationale: The first line of a docstring should end with a period, question mark, or\nexclamation point, for grammatical correctness and consistency.\n\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the google\nconvention, and disabled when using the numpy and pep257 conventions.\n\nExample:\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values\"\"\"\n\n\n\nUse instead:\n\n\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n\n# Idiom D416 (missing-section-name-colon)\n\nDefinition: Checks for docstring section headers that do not end with a colon.\n\nRationale: This rule enforces a consistent style for multiline Google-style\ndocstrings. If a multiline Google-style docstring consists of multiple\nsections, each section header should end with a colon.\n\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\n\nThis rule is enabled when using the google convention, and disabled when\nusing the pep257 and numpy conventions.\n\nExample:\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns\n        Speed as distance divided by time.\n\n    Raises\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n\n\nUse instead:\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/COM812-COM818-COM819",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom COM812 (missing-trailing-comma)\n\nDefinition: Checks for the absence of trailing commas.\n\nRationale: The presence of a trailing comma can reduce diff size when parameters or\nelements are added or removed from function calls, function definitions,\nliterals, etc.\n\nExample:\nfoo = {\n    \"bar\": 1,\n    \"baz\": 2\n}\n\n\n\nUse instead:\n\n\nfoo = {\n    \"bar\": 1,\n    \"baz\": 2,\n}\n\n# Idiom COM818 (trailing-comma-on-bare-tuple)\n\nDefinition: Checks for the presence of trailing commas on bare (i.e., unparenthesized)\ntuples.\n\nRationale: The presence of a misplaced comma will cause Python to interpret the value\nas a tuple, which can lead to unexpected behaviour.\n\nExample:\nimport json\n\n\nfoo = json.dumps({\"bar\": 1}),\n\n\n\nUse instead:\n\n\nimport json\n\n\nfoo = json.dumps({\"bar\": 1})\n\n\n\nIn the event that a tuple is intended, then use instead:\n\n\nimport json\n\n\nfoo = (json.dumps({\"bar\": 1}),)\n\n# Idiom COM819 (prohibited-trailing-comma)\n\nDefinition: Checks for the presence of prohibited trailing commas.\n\nRationale: Trailing commas are not essential in some cases and can therefore be viewed\nas unnecessary.\n\nExample:\nfoo = (1, 2, 3,)\n\n\n\nUse instead:\n\n\nfoo = (1, 2, 3)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PD002-PD003-PD004-PD007-PD008",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PD002 (pandas-use-of-inplace-argument)\n\nDefinition: Checks for inplace=True usages in pandas function and method\ncalls.\n\nRationale: Using inplace=True encourages mutation rather than immutable data,\nwhich is harder to reason about and may cause bugs. It also removes the\nability to use the method chaining style for pandas operations.\n\n\nFurther, in many cases, inplace=True does not provide a performance\nbenefit, as pandas will often copy DataFrames in the background.\n\nExample:\ndf.sort_values(\"col1\", inplace=True)\n\n\n\nUse instead:\n\n\nsorted_df = df.sort_values(\"col1\")\n\n# Idiom PD003 (pandas-use-of-dot-is-null)\n\nDefinition: Checks for uses of .isnull on Pandas objects.\n\nRationale: In the Pandas API, .isna and .isnull are equivalent. For consistency,\nprefer .isna over .isnull.\n\n\nAs a name, .isna more accurately reflects the behavior of the method,\nsince these methods check for NaN and NaT values in addition to None\nvalues.\n\nExample:\nimport pandas as pd\n\nanimals_df = pd.read_csv(\"animals.csv\")\npd.isnull(animals_df)\n\n\n\nUse instead:\n\n\nimport pandas as pd\n\nanimals_df = pd.read_csv(\"animals.csv\")\npd.isna(animals_df)\n\n# Idiom PD004 (pandas-use-of-dot-not-null)\n\nDefinition: Checks for uses of .notnull on Pandas objects.\n\nRationale: In the Pandas API, .notna and .notnull are equivalent. For consistency,\nprefer .notna over .notnull.\n\n\nAs a name, .notna more accurately reflects the behavior of the method,\nsince these methods check for NaN and NaT values in addition to None\nvalues.\n\nExample:\nimport pandas as pd\n\nanimals_df = pd.read_csv(\"animals.csv\")\npd.notnull(animals_df)\n\n\n\nUse instead:\n\n\nimport pandas as pd\n\nanimals_df = pd.read_csv(\"animals.csv\")\npd.notna(animals_df)\n\n# Idiom PD007 (pandas-use-of-dot-ix)\n\nDefinition: Checks for uses of .ix on Pandas objects.\n\nRationale: The .ix method is deprecated as its behavior is ambiguous. Specifically,\nit's often unclear whether .ix is indexing by label or by ordinal position.\n\n\nInstead, prefer the .loc method for label-based indexing, and .iloc for\nordinal indexing.\n\nExample:\nimport pandas as pd\n\nstudents_df = pd.read_csv(\"students.csv\")\nstudents_df.ix[0]  # 0th row or row with label 0?\n\n\n\nUse instead:\n\n\nimport pandas as pd\n\nstudents_df = pd.read_csv(\"students.csv\")\nstudents_df.iloc[0]  # 0th row.\n\n# Idiom PD008 (pandas-use-of-dot-at)\n\nDefinition: Checks for uses of .at on Pandas objects.\n\nRationale: The .at method selects a single value from a DataFrame or Series based on\na label index, and is slightly faster than using .loc. However, .loc is\nmore idiomatic and versatile, as it can be used to select multiple values at\nonce.\n\n\nIf performance is an important consideration, convert the object to a NumPy\narray, which will provide a much greater performance boost than using .at\nover .loc.\n\nExample:\nimport pandas as pd\n\nstudents_df = pd.read_csv(\"students.csv\")\nstudents_df.at[\"Maria\"]\n\n\n\nUse instead:\n\n\nimport pandas as pd\n\nstudents_df = pd.read_csv(\"students.csv\")\nstudents_df.loc[\"Maria\"]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PYI021-PYI024-PYI025-PYI026-PYI029",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PYI021 (docstring-in-stub)\n\nDefinition: Checks for the presence of docstrings in stub files.\n\nRationale: Stub files should omit docstrings, as they're intended to provide type\nhints, rather than documentation.\n\nExample:\ndef func(param: int) -> str:\n    \"\"\"This is a docstring.\"\"\"\n    ...\n\n\n\nUse instead:\n\n\ndef func(param: int) -> str: ...\n\n# Idiom PYI024 (collections-named-tuple)\n\nDefinition: Checks for uses of collections.namedtuple in stub files.\n\nRationale: typing.NamedTuple is the \"typed version\" of collections.namedtuple.\n\n\nInheriting from typing.NamedTuple creates a custom tuple subclass in\nthe same way as using the collections.namedtuple factory function.\nHowever, using typing.NamedTuple allows you to provide a type annotation\nfor each field in the class. This means that type checkers will have more\ninformation to work with, and will be able to analyze your code more\nprecisely.\n\nExample:\nfrom collections import namedtuple\n\nperson = namedtuple(\"Person\", [\"name\", \"age\"])\n\n\n\nUse instead:\n\n\nfrom typing import NamedTuple\n\nclass Person(NamedTuple):\n    name: str\n    age: int\n\n# Idiom PYI025 (unaliased-collections-abc-set-import)\n\nDefinition: Checks for from collections.abc import Set imports that do not alias\nSet to AbstractSet.\n\nRationale: The Set type in collections.abc is an abstract base class for set-like types.\nIt is easily confused with, and not equivalent to, the set builtin.\n\n\nTo avoid confusion, Set should be aliased to AbstractSet when imported. This\nmakes it clear that the imported type is an abstract base class, and not the\nset builtin.\n\nExample:\nfrom collections.abc import Set\n\n\n\nUse instead:\n\n\nfrom collections.abc import Set as AbstractSet\n\n# Idiom PYI026 (type-alias-without-annotation)\n\nDefinition: Checks for type alias definitions that are not annotated with\ntyping.TypeAlias.\n\nRationale: In Python, a type alias is defined by assigning a type to a variable (e.g.,\nVector = list[float]).\n\n\nIt's best to annotate type aliases with the typing.TypeAlias type to\nmake it clear that the statement is a type alias declaration, as opposed\nto a normal variable assignment.\n\nExample:\nVector = list[float]\n\n\n\nUse instead:\n\n\nfrom typing import TypeAlias\n\nVector: TypeAlias = list[float]\n\n# Idiom PYI029 (str-or-repr-defined-in-stub)\n\nDefinition: Checks for redundant definitions of __str__ or __repr__ in stubs.\n\nRationale: Defining __str__ or __repr__ in a stub is almost always redundant,\nas the signatures are almost always identical to those of the default\nequivalent, object.__str__ and object.__repr__, respectively.\n\nExample:\nclass Foo:\n    def __repr__(self) -> str: ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/LOG009-LOG014-LOG015",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom LOG009 (undocumented-warn)\n\nDefinition: Checks for uses of logging.WARN.\n\nRationale: The logging.WARN constant is an undocumented alias for logging.WARNING.\n\n\nAlthough it\u2019s not explicitly deprecated, logging.WARN is not mentioned\nin the logging documentation. Prefer logging.WARNING instead.\n\nExample:\nimport logging\n\n\nlogging.basicConfig(level=logging.WARN)\n\n\n\nUse instead:\n\n\nimport logging\n\n\nlogging.basicConfig(level=logging.WARNING)\n\n# Idiom LOG014 (exc-info-outside-except-handler)\n\nDefinition: Checks for logging calls with exc_info= outside exception handlers.\n\nRationale: Using exc_info=True outside of an exception handler\nattaches None as the exception information, leading to confusing messages:\n\n\n>>> logging.warning(\"Uh oh\", exc_info=True)\nWARNING:root:Uh oh\nNoneType: None\n\nExample:\nimport logging\n\n\nlogging.warning(\"Foobar\", exc_info=True)\n\n\n\nUse instead:\n\n\nimport logging\n\n\nlogging.warning(\"Foobar\")\n\n# Idiom LOG015 (root-logger-call)\n\nDefinition: Checks for usages of the following logging top-level functions:\ndebug, info, warn, warning, error, critical, log, exception.\n\nRationale: Using the root logger causes the messages to have no source information,\nmaking them less useful for debugging.\n\nExample:\nimport logging\n\nlogging.info(\"Foobar\")\n\n\n\nUse instead:\n\n\nimport logging\n\nlogger = logging.getLogger(__name__)\nlogger.info(\"Foobar\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/C400-C401-C402-C403-C404",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom C400 (unnecessary-generator-list)\n\nDefinition: Checks for unnecessary generators that can be rewritten as list\ncomprehensions (or with list() directly).\n\nRationale: It is unnecessary to use list() around a generator expression, since\nthere are equivalent comprehensions for these types. Using a\ncomprehension is clearer and more idiomatic.\n\n\nFurther, if the comprehension can be removed entirely, as in the case of\nlist(x for x in foo), it's better to use list(foo) directly, since it's\neven more direct.\n\nExample:\nlist(f(x) for x in foo)\nlist(x for x in foo)\nlist((x for x in foo))\n\n\n\nUse instead:\n\n\n[f(x) for x in foo]\nlist(foo)\nlist(foo)\n\n# Idiom C401 (unnecessary-generator-set)\n\nDefinition: Checks for unnecessary generators that can be rewritten as set\ncomprehensions (or with set() directly).\n\nRationale: It is unnecessary to use set around a generator expression, since\nthere are equivalent comprehensions for these types. Using a\ncomprehension is clearer and more idiomatic.\n\n\nFurther, if the comprehension can be removed entirely, as in the case of\nset(x for x in foo), it's better to use set(foo) directly, since it's\neven more direct.\n\nExample:\nset(f(x) for x in foo)\nset(x for x in foo)\nset((x for x in foo))\n\n\n\nUse instead:\n\n\n{f(x) for x in foo}\nset(foo)\nset(foo)\n\n# Idiom C402 (unnecessary-generator-dict)\n\nDefinition: Checks for unnecessary generators that can be rewritten as dict\ncomprehensions.\n\nRationale: It is unnecessary to use dict() around a generator expression, since\nthere are equivalent comprehensions for these types. Using a\ncomprehension is clearer and more idiomatic.\n\nExample:\ndict((x, f(x)) for x in foo)\n\n\n\nUse instead:\n\n\n{x: f(x) for x in foo}\n\n# Idiom C403 (unnecessary-list-comprehension-set)\n\nDefinition: Checks for unnecessary list comprehensions.\n\nRationale: It's unnecessary to use a list comprehension inside a call to set(),\nsince there is an equivalent comprehension for this type.\n\nExample:\nset([f(x) for x in foo])\n\n\n\nUse instead:\n\n\n{f(x) for x in foo}\n\n# Idiom C404 (unnecessary-list-comprehension-dict)\n\nDefinition: Checks for unnecessary list comprehensions.\n\nRationale: It's unnecessary to use a list comprehension inside a call to dict(),\nsince there is an equivalent comprehension for this type.\n\nExample:\ndict([(x, f(x)) for x in foo])\n\n\n\nUse instead:\n\n\n{x: f(x) for x in foo}\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/RUF059-RUF100-RUF101-RUF102-RUF200",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom RUF059 (unused-unpacked-variable)\n\nDefinition: Checks for the presence of unused variables in unpacked assignments.\n\nRationale: A variable that is defined but never used can confuse readers.\n\n\nIf a variable is intentionally defined-but-not-used, it should be\nprefixed with an underscore, or some other value that adheres to the\nlint.dummy-variable-rgx pattern.\n\nExample:\ndef get_pair():\n    return 1, 2\n\n\ndef foo():\n    x, y = get_pair()\n    return x\n\n\n\nUse instead:\n\n\ndef foo():\n    x, _ = get_pair()\n    return x\n\n# Idiom RUF100 (unused-noqa)\n\nDefinition: Checks for noqa directives that are no longer applicable.\n\nRationale: A noqa directive that no longer matches any diagnostic violations is\nlikely included by mistake, and should be removed to avoid confusion.\n\nExample:\nimport foo  # noqa: F401\n\n\ndef bar():\n    foo.bar()\n\n\n\nUse instead:\n\n\nimport foo\n\n\ndef bar():\n    foo.bar()\n\n# Idiom RUF101 (redirected-noqa)\n\nDefinition: Checks for noqa directives that use redirected rule codes.\n\nRationale: When one of Ruff's rule codes has been redirected, the implication is that the rule has\nbeen deprecated in favor of another rule or code. To keep your codebase\nconsistent and up-to-date, prefer the canonical rule code over the deprecated\ncode.\n\nExample:\nx = eval(command)  # noqa: PGH001\n\n\n\nUse instead:\n\n\nx = eval(command)  # noqa: S307\n\n# Idiom RUF102 (invalid-rule-code)\n\nDefinition: Checks for noqa codes that are invalid.\n\nRationale: Invalid rule codes serve no purpose and may indicate outdated code suppressions.\n\nExample:\nimport os  # noqa: XYZ999\n\n\n\nUse instead:\n\n\nimport os\n\n\n\nOr if there are still valid codes needed:\n\n\nimport os  # noqa: E402\n\n# Idiom RUF200 (invalid-pyproject-toml)\n\nDefinition: Checks for any pyproject.toml that does not conform to the schema from the relevant PEPs.\n\nRationale: Your project may contain invalid metadata or configuration without you noticing\n\nExample:\n[project]\nname = \"crab\"\nversion = \"1.0.0\"\nauthors = [\"Ferris the Crab <[email\u00a0protected]>\"]\n\n\n\nUse instead:\n\n\n[project]\nname = \"crab\"\nversion = \"1.0.0\"\nauthors = [\n  { name = \"Ferris the Crab\", email = \"[email\u00a0protected]\" }\n]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/D105-D106-D107-D200-D201",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom D105 (undocumented-magic-method)\n\nDefinition: Checks for undocumented magic method definitions.\n\nRationale: Magic methods (methods with names that start and end with double\nunderscores) are used to implement operator overloading and other special\nbehavior. Such methods should be documented via docstrings to\noutline their behavior.\n\n\nGenerally, magic method docstrings should describe the method's behavior,\narguments, side effects, exceptions, return values, and any other\ninformation that may be relevant to the user.\n\n\nIf the codebase adheres to a standard format for method docstrings, follow\nthat format for consistency.\n\nExample:\nclass Cat(Animal):\n    def __str__(self) -> str:\n        return f\"Cat: {self.name}\"\n\n\ncat = Cat(\"Dusty\")\nprint(cat)  # \"Cat: Dusty\"\n\n\n\nUse instead:\n\n\nclass Cat(Animal):\n    def __str__(self) -> str:\n        \"\"\"Return a string representation of the cat.\"\"\"\n        return f\"Cat: {self.name}\"\n\n\ncat = Cat(\"Dusty\")\nprint(cat)  # \"Cat: Dusty\"\n\n# Idiom D106 (undocumented-public-nested-class)\n\nDefinition: Checks for undocumented public class definitions, for nested classes.\n\nRationale: Public classes should be documented via docstrings to outline their\npurpose and behavior.\n\n\nNested classes do not inherit the docstring of their enclosing class, so\nthey should have their own docstrings.\n\n\nIf the codebase adheres to a standard format for class docstrings, follow\nthat format for consistency.\n\nExample:\nclass Foo:\n    \"\"\"Class Foo.\"\"\"\n\n    class Bar: ...\n\n\nbar = Foo.Bar()\nbar.__doc__  # None\n\n\n\nUse instead:\n\n\nclass Foo:\n    \"\"\"Class Foo.\"\"\"\n\n    class Bar:\n        \"\"\"Class Bar.\"\"\"\n\n\nbar = Foo.Bar()\nbar.__doc__  # \"Class Bar.\"\n\n# Idiom D107 (undocumented-public-init)\n\nDefinition: Checks for public __init__ method definitions that are missing\ndocstrings.\n\nRationale: Public __init__ methods are used to initialize objects. __init__\nmethods should be documented via docstrings to describe the method's\nbehavior, arguments, side effects, exceptions, and any other information\nthat may be relevant to the user.\n\n\nIf the codebase adheres to a standard format for __init__ method docstrings,\nfollow that format for consistency.\n\nExample:\nclass City:\n    def __init__(self, name: str, population: int) -> None:\n        self.name: str = name\n        self.population: int = population\n\n\n\nUse instead:\n\n\nclass City:\n    def __init__(self, name: str, population: int) -> None:\n        \"\"\"Initialize a city with a name and population.\"\"\"\n        self.name: str = name\n        self.population: int = population\n\n# Idiom D200 (unnecessary-multiline-docstring)\n\nDefinition: Checks for single-line docstrings that are broken across multiple lines.\n\nRationale: PEP 257 recommends that docstrings that can fit on one line should be\nformatted on a single line, for consistency and readability.\n\nExample:\ndef average(values: list[float]) -> float:\n    \"\"\"\n    Return the mean of the given values.\n    \"\"\"\n\n\n\nUse instead:\n\n\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n\n# Idiom D201 (blank-line-before-function)\n\nDefinition: Checks for docstrings on functions that are separated by one or more blank\nlines from the function definition.\n\nRationale: Remove any blank lines between the function definition and its docstring,\nfor consistency.\n\nExample:\ndef average(values: list[float]) -> float:\n\n    \"\"\"Return the mean of the given values.\"\"\"\n\n\n\nUse instead:\n\n\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/S509-S601-S602-S603-S604",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom S509 (snmp-weak-cryptography)\n\nDefinition: Checks for uses of the SNMPv3 protocol without encryption.\n\nRationale: Unencrypted SNMPv3 communication can be intercepted and read by\nunauthorized parties. Instead, enable encryption when using SNMPv3.\n\nExample:\nfrom pysnmp.hlapi import UsmUserData\n\nUsmUserData(\"user\")\n\n\n\nUse instead:\n\n\nfrom pysnmp.hlapi import UsmUserData\n\nUsmUserData(\"user\", \"authkey\", \"privkey\")\n\n# Idiom S601 (paramiko-call)\n\nDefinition: Checks for paramiko calls.\n\nRationale: paramiko calls allow users to execute arbitrary shell commands on a\nremote machine. If the inputs to these calls are not properly sanitized,\nthey can be vulnerable to shell injection attacks.\n\nExample:\nimport paramiko\n\nclient = paramiko.SSHClient()\nclient.exec_command(\"echo $HOME\")\n\n# Idiom S602 (subprocess-popen-with-shell-equals-true)\n\nDefinition: Check for method calls that initiate a subprocess with a shell.\n\nRationale: Starting a subprocess with a shell can allow attackers to execute arbitrary\nshell commands. Consider starting the process without a shell call and\nsanitize the input to mitigate the risk of shell injection.\n\nExample:\nimport subprocess\n\nsubprocess.run(\"ls -l\", shell=True)\n\n\n\nUse instead:\n\n\nimport subprocess\n\nsubprocess.run([\"ls\", \"-l\"])\n\n# Idiom S603 (subprocess-without-shell-equals-true)\n\nDefinition: Check for method calls that initiate a subprocess without a shell.\n\nRationale: Starting a subprocess without a shell can prevent attackers from executing\narbitrary shell commands; however, it is still error-prone. Consider\nvalidating the input.\n\nExample:\nimport subprocess\n\ncmd = input(\"Enter a command: \").split()\nsubprocess.run(cmd)\n\n# Idiom S604 (call-with-shell-equals-true)\n\nDefinition: Checks for method calls that set the shell parameter to true or another\ntruthy value when invoking a subprocess.\n\nRationale: Setting the shell parameter to true or another truthy value when\ninvoking a subprocess can introduce security vulnerabilities, as it allows\nshell metacharacters and whitespace to be passed to child processes,\npotentially leading to shell injection attacks.\n\n\nIt is recommended to avoid using shell=True unless absolutely necessary\nand, when used, to ensure that all inputs are properly sanitized and quoted\nto prevent such vulnerabilities.\n\nExample:\nimport subprocess\n\nuser_input = input(\"Enter a command: \")\nsubprocess.run(user_input, shell=True)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/ASYNC100-ASYNC105-ASYNC109-ASYNC110",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom ASYNC100 (cancel-scope-no-checkpoint)\n\nDefinition: Checks for timeout context managers which do not contain a checkpoint.\n\n\nFor the purposes of this check, yield is considered a checkpoint,\nsince checkpoints may occur in the caller to which we yield.\n\nRationale: Some asynchronous context managers, such as asyncio.timeout and\ntrio.move_on_after, have no effect unless they contain a checkpoint.\nThe use of such context managers without an await, async with or\nasync for statement is likely a mistake.\n\nExample:\nasync def func():\n    async with asyncio.timeout(2):\n        do_something()\n\n\n\nUse instead:\n\n\nasync def func():\n    async with asyncio.timeout(2):\n        do_something()\n        await awaitable()\n\n# Idiom ASYNC105 (trio-sync-call)\n\nDefinition: Checks for calls to trio functions that are not immediately awaited.\n\nRationale: Many of the functions exposed by trio are asynchronous, and must be awaited\nto take effect. Calling a trio function without an await can lead to\nRuntimeWarning diagnostics and unexpected behaviour.\n\nExample:\nasync def double_sleep(x):\n    trio.sleep(2 * x)\n\n\n\nUse instead:\n\n\nasync def double_sleep(x):\n    await trio.sleep(2 * x)\n\n# Idiom ASYNC109 (async-function-with-timeout)\n\nDefinition: Checks for async function definitions with timeout parameters.\n\nRationale: Rather than implementing asynchronous timeout behavior manually, prefer\nbuilt-in timeout functionality, such as asyncio.timeout, trio.fail_after,\nor anyio.move_on_after, among others.\n\n\nThis rule is highly opinionated to enforce a design pattern\ncalled \"structured concurrency\" that allows for\nasync functions to be oblivious to timeouts,\ninstead letting callers to handle the logic with a context manager.\n\nExample:\nasync def long_running_task(timeout): ...\n\n\nasync def main():\n    await long_running_task(timeout=2)\n\n\n\nUse instead:\n\n\nasync def long_running_task(): ...\n\n\nasync def main():\n    async with asyncio.timeout(2):\n        await long_running_task()\n\n# Idiom ASYNC110 (async-busy-wait)\n\nDefinition: Checks for the use of an async sleep function in a while loop.\n\nRationale: Instead of sleeping in a while loop, and waiting for a condition\nto become true, it's preferable to await on an Event object such\nas: asyncio.Event, trio.Event, or anyio.Event.\n\nExample:\nDONE = False\n\n\nasync def func():\n    while not DONE:\n        await asyncio.sleep(1)\n\n\n\nUse instead:\n\n\nDONE = asyncio.Event()\n\n\nasync def func():\n    await DONE.wait()\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PD013-PD015-PD101-PD901",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PD013 (pandas-use-of-dot-stack)\n\nDefinition: Checks for uses of .stack on Pandas objects.\n\nRationale: Prefer .melt to .stack, which has the same functionality but with\nsupport for direct column renaming and no dependence on MultiIndex.\n\nExample:\nimport pandas as pd\n\ncities_df = pd.read_csv(\"cities.csv\")\ncities_df.set_index(\"city\").stack()\n\n\n\nUse instead:\n\n\nimport pandas as pd\n\ncities_df = pd.read_csv(\"cities.csv\")\ncities_df.melt(id_vars=\"city\")\n\n# Idiom PD015 (pandas-use-of-pd-merge)\n\nDefinition: Checks for uses of pd.merge on Pandas objects.\n\nRationale: In Pandas, the .merge method (exposed on, e.g., DataFrame objects) and\nthe pd.merge function (exposed on the Pandas module) are equivalent.\n\n\nFor consistency, prefer calling .merge on an object over calling\npd.merge on the Pandas module, as the former is more idiomatic.\n\n\nFurther, pd.merge is not a method, but a function, which prohibits it\nfrom being used in method chains, a common pattern in Pandas code.\n\nExample:\nimport pandas as pd\n\ncats_df = pd.read_csv(\"cats.csv\")\ndogs_df = pd.read_csv(\"dogs.csv\")\nrabbits_df = pd.read_csv(\"rabbits.csv\")\npets_df = pd.merge(pd.merge(cats_df, dogs_df), rabbits_df)  # Hard to read.\n\n\n\nUse instead:\n\n\nimport pandas as pd\n\ncats_df = pd.read_csv(\"cats.csv\")\ndogs_df = pd.read_csv(\"dogs.csv\")\nrabbits_df = pd.read_csv(\"rabbits.csv\")\npets_df = cats_df.merge(dogs_df).merge(rabbits_df)\n\n# Idiom PD101 (pandas-nunique-constant-series-check)\n\nDefinition: Check for uses of .nunique() to check if a Pandas Series is constant\n(i.e., contains only one unique value).\n\nRationale: .nunique() is computationally inefficient for checking if a Series is\nconstant.\n\n\nConsider, for example, a Series of length n that consists of increasing\ninteger values (e.g., 1, 2, 3, 4). The .nunique() method will iterate\nover the entire Series to count the number of unique values. But in this\ncase, we can detect that the Series is non-constant after visiting the\nfirst two values, which are non-equal.\n\n\nIn general, .nunique() requires iterating over the entire Series, while a\nmore efficient approach allows short-circuiting the operation as soon as a\nnon-equal value is found.\n\n\nInstead of calling .nunique(), convert the Series to a NumPy array, and\ncheck if all values in the array are equal to the first observed value.\n\nExample:\nimport pandas as pd\n\ndata = pd.Series(range(1000))\nif data.nunique() <= 1:\n    print(\"Series is constant\")\n\n\n\nUse instead:\n\n\nimport pandas as pd\n\ndata = pd.Series(range(1000))\narray = data.to_numpy()\nif array.shape[0] == 0 or (array[0] == array).all():\n    print(\"Series is constant\")\n\n# Idiom PD901 (pandas-df-variable-name)\n\nDefinition: Checks for assignments to the variable df.\n\nRationale: Although df is a common variable name for a Pandas DataFrame, it's not a\ngreat variable name for production code, as it's non-descriptive and\nprone to name conflicts.\n\n\nInstead, use a more descriptive variable name.\n\nExample:\nimport pandas as pd\n\ndf = pd.read_csv(\"animals.csv\")\n\n\n\nUse instead:\n\n\nimport pandas as pd\n\nanimals = pd.read_csv(\"animals.csv\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/TC001-TC002-TC003-TC004-TC005",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom TC001 (typing-only-first-party-import)\n\nDefinition: Checks for first-party imports that are only used for type annotations, but\naren't defined in a type-checking block.\n\nRationale: Unused imports add a performance overhead at runtime, and risk creating\nimport cycles. If an import is only used in typing-only contexts, it can\ninstead be imported conditionally under an if TYPE_CHECKING: block to\nminimize runtime overhead.\n\n\nIf lint.flake8-type-checking.quote-annotations is set to true,\nannotations will be wrapped in quotes if doing so would enable the\ncorresponding import to be moved into an if TYPE_CHECKING: block.\n\n\nIf a class requires that type annotations be available at runtime (as is\nthe case for Pydantic, SQLAlchemy, and other libraries), consider using\nthe lint.flake8-type-checking.runtime-evaluated-base-classes and\nlint.flake8-type-checking.runtime-evaluated-decorators settings to mark them\nas such.\n\nExample:\nfrom __future__ import annotations\n\nimport local_module\n\n\ndef func(sized: local_module.Container) -> int:\n    return len(sized)\n\n\n\nUse instead:\n\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    import local_module\n\n\ndef func(sized: local_module.Container) -> int:\n    return len(sized)\n\n# Idiom TC002 (typing-only-third-party-import)\n\nDefinition: Checks for third-party imports that are only used for type annotations, but\naren't defined in a type-checking block.\n\nRationale: Unused imports add a performance overhead at runtime, and risk creating\nimport cycles. If an import is only used in typing-only contexts, it can\ninstead be imported conditionally under an if TYPE_CHECKING: block to\nminimize runtime overhead.\n\n\nIf lint.flake8-type-checking.quote-annotations is set to true,\nannotations will be wrapped in quotes if doing so would enable the\ncorresponding import to be moved into an if TYPE_CHECKING: block.\n\n\nIf a class requires that type annotations be available at runtime (as is\nthe case for Pydantic, SQLAlchemy, and other libraries), consider using\nthe lint.flake8-type-checking.runtime-evaluated-base-classes and\nlint.flake8-type-checking.runtime-evaluated-decorators settings to mark them\nas such.\n\nExample:\nfrom __future__ import annotations\n\nimport pandas as pd\n\n\ndef func(df: pd.DataFrame) -> int:\n    return len(df)\n\n\n\nUse instead:\n\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    import pandas as pd\n\n\ndef func(df: pd.DataFrame) -> int:\n    return len(df)\n\n# Idiom TC003 (typing-only-standard-library-import)\n\nDefinition: Checks for standard library imports that are only used for type\nannotations, but aren't defined in a type-checking block.\n\nRationale: Unused imports add a performance overhead at runtime, and risk creating\nimport cycles. If an import is only used in typing-only contexts, it can\ninstead be imported conditionally under an if TYPE_CHECKING: block to\nminimize runtime overhead.\n\n\nIf lint.flake8-type-checking.quote-annotations is set to true,\nannotations will be wrapped in quotes if doing so would enable the\ncorresponding import to be moved into an if TYPE_CHECKING: block.\n\n\nIf a class requires that type annotations be available at runtime (as is\nthe case for Pydantic, SQLAlchemy, and other libraries), consider using\nthe lint.flake8-type-checking.runtime-evaluated-base-classes and\nlint.flake8-type-checking.runtime-evaluated-decorators settings to mark them\nas such.\n\nExample:\nfrom __future__ import annotations\n\nfrom pathlib import Path\n\n\ndef func(path: Path) -> str:\n    return str(path)\n\n\n\nUse instead:\n\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from pathlib import Path\n\n\ndef func(path: Path) -> str:\n    return str(path)\n\n# Idiom TC004 (runtime-import-in-type-checking-block)\n\nDefinition: Checks for imports that are required at runtime but are only defined in\ntype-checking blocks.\n\nRationale: The type-checking block is not executed at runtime, so if the only definition\nof a symbol is in a type-checking block, it will not be available at runtime.\n\n\nIf lint.flake8-type-checking.quote-annotations is set to true,\nannotations will be wrapped in quotes if doing so would enable the\ncorresponding import to remain in the type-checking block.\n\nExample:\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    import foo\n\n\ndef bar() -> None:\n    foo.bar()  # raises NameError: name 'foo' is not defined\n\n\n\nUse instead:\n\n\nimport foo\n\n\ndef bar() -> None:\n    foo.bar()\n\n# Idiom TC005 (empty-type-checking-block)\n\nDefinition: Checks for an empty type-checking block.\n\nRationale: The type-checking block does not do anything and should be removed to avoid\nconfusion.\n\nExample:\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    pass\n\nprint(\"Hello, world!\")\n\n\n\nUse instead:\n\n\nprint(\"Hello, world!\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/DJ001-DJ003-DJ006-DJ007",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom DJ001 (django-nullable-model-string-field)\n\nDefinition: Checks nullable string-based fields (like CharField and TextField)\nin Django models.\n\nRationale: If a string-based field is nullable, then your model will have two possible\nrepresentations for \"no data\": None and the empty string. This can lead to\nconfusion, as clients of the API have to check for both None and the\nempty string when trying to determine if the field has data.\n\n\nThe Django convention is to use the empty string in lieu of None for\nstring-based fields.\n\nExample:\nfrom django.db import models\n\n\nclass MyModel(models.Model):\n    field = models.CharField(max_length=255, null=True)\n\n\n\nUse instead:\n\n\nfrom django.db import models\n\n\nclass MyModel(models.Model):\n    field = models.CharField(max_length=255, default=\"\")\n\n# Idiom DJ003 (django-locals-in-render-function)\n\nDefinition: Checks for the use of locals() in render functions.\n\nRationale: Using locals() can expose internal variables or other unintentional\ndata to the rendered template.\n\nExample:\nfrom django.shortcuts import render\n\n\ndef index(request):\n    posts = Post.objects.all()\n    return render(request, \"app/index.html\", locals())\n\n\n\nUse instead:\n\n\nfrom django.shortcuts import render\n\n\ndef index(request):\n    posts = Post.objects.all()\n    context = {\"posts\": posts}\n    return render(request, \"app/index.html\", context)\n\n# Idiom DJ006 (django-exclude-with-model-form)\n\nDefinition: Checks for the use of exclude in Django ModelForm classes.\n\nRationale: If a ModelForm includes the exclude attribute, any new field that\nis added to the model will automatically be exposed for modification.\n\nExample:\nfrom django.forms import ModelForm\n\n\nclass PostForm(ModelForm):\n    class Meta:\n        model = Post\n        exclude = [\"author\"]\n\n\n\nUse instead:\n\n\nfrom django.forms import ModelForm\n\n\nclass PostForm(ModelForm):\n    class Meta:\n        model = Post\n        fields = [\"title\", \"content\"]\n\n# Idiom DJ007 (django-all-with-model-form)\n\nDefinition: Checks for the use of fields = \"__all__\" in Django ModelForm\nclasses.\n\nRationale: If a ModelForm includes the fields = \"__all__\" attribute, any new\nfield that is added to the model will automatically be exposed for\nmodification.\n\nExample:\nfrom django.forms import ModelForm\n\n\nclass PostForm(ModelForm):\n    class Meta:\n        model = Post\n        fields = \"__all__\"\n\n\n\nUse instead:\n\n\nfrom django.forms import ModelForm\n\n\nclass PostForm(ModelForm):\n    class Meta:\n        model = Post\n        fields = [\"title\", \"content\"]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLC0208-PLC0414-PLC0415-PLC1802-PLC1901",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLC0208 (iteration-over-set)\n\nDefinition: Checks for iteration over a set literal where each element in the set is\nitself a literal value.\n\nRationale: Iterating over a set is less efficient than iterating over a sequence\ntype, like list or tuple.\n\nExample:\nfor number in {1, 2, 3}:\n    ...\n\n\n\nUse instead:\n\n\nfor number in (1, 2, 3):\n    ...\n\n# Idiom PLC0414 (useless-import-alias)\n\nDefinition: Checks for import aliases that do not rename the original package.\n\nRationale: The import alias is redundant and should be removed to avoid confusion.\n\nExample:\nimport numpy as numpy\n\n\n\nUse instead:\n\n\nimport numpy as np\n\n\n\nor\n\n\nimport numpy\n\n# Idiom PLC0415 (import-outside-top-level)\n\nDefinition: Checks for import statements outside of a module's top-level scope, such\nas within a function or class definition.\n\nRationale: PEP 8 recommends placing imports not only at the top-level of a module,\nbut at the very top of the file, \"just after any module comments and\ndocstrings, and before module globals and constants.\"\n\n\nimport statements have effects that are global in scope; defining them at\nthe top level has a number of benefits. For example, it makes it easier to\nidentify the dependencies of a module, and ensures that any invalid imports\nare caught regardless of whether a specific function is called or class is\ninstantiated.\n\n\nAn import statement would typically be placed within a function only to\navoid a circular dependency, to defer a costly module load, or to avoid\nloading a dependency altogether in a certain runtime environment.\n\nExample:\ndef print_python_version():\n    import platform\n\n    print(python.python_version())\n\n\n\nUse instead:\n\n\nimport platform\n\n\ndef print_python_version():\n    print(python.python_version())\n\n# Idiom PLC1802 (len-test)\n\nDefinition: Checks for len calls on sequences in a boolean test context.\n\nRationale: Empty sequences are considered false in a boolean context.\nYou can either remove the call to len\nor compare the length against a scalar.\n\nExample:\nfruits = [\"orange\", \"apple\"]\nvegetables = []\n\nif len(fruits):\n    print(fruits)\n\nif not len(vegetables):\n    print(vegetables)\n\n\n\nUse instead:\n\n\nfruits = [\"orange\", \"apple\"]\nvegetables = []\n\nif fruits:\n    print(fruits)\n\nif not vegetables:\n    print(vegetables)\n\n# Idiom PLC1901 (compare-to-empty-string)\n\nDefinition: Checks for comparisons to empty strings.\n\nRationale: An empty string is falsy, so it is unnecessary to compare it to \"\". If\nthe value can be something else Python considers falsy, such as None,\n0, or another empty container, then the code is not equivalent.\n\nExample:\nx: str = ...\n\nif x == \"\":\n    print(\"x is empty\")\n\n\n\nUse instead:\n\n\nx: str = ...\n\nif not x:\n    print(\"x is empty\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/S308-S310-S311-S312-S313",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom S308 (suspicious-mark-safe-usage)\n\nDefinition: Checks for uses of calls to django.utils.safestring.mark_safe.\n\nRationale: Cross-site scripting (XSS) vulnerabilities allow attackers to execute\narbitrary JavaScript. To guard against XSS attacks, Django templates\nassumes that data is unsafe and automatically escapes malicious strings\nbefore rending them.\n\n\ndjango.utils.safestring.mark_safe marks a string as safe for use in HTML\ntemplates, bypassing XSS protection. Its usage can be dangerous if the\ncontents of the string are dynamically generated, because it may allow\ncross-site scripting attacks if the string is not properly escaped.\n\n\nFor dynamically generated strings, consider utilizing\ndjango.utils.html.format_html.\n\n\nIn preview, this rule will also flag references to django.utils.safestring.mark_safe.\n\nExample:\nfrom django.utils.safestring import mark_safe\n\n\ndef render_username(username):\n    return mark_safe(f\"<i>{username}</i>\")  # Dangerous if username is user-provided.\n\n\n\nUse instead:\n\n\nfrom django.utils.html import format_html\n\n\ndef render_username(username):\n    return django.utils.html.format_html(\"<i>{}</i>\", username)  # username is escaped.\n\n# Idiom S310 (suspicious-url-open-usage)\n\nDefinition: Checks for instances where URL open functions are used with unexpected schemes.\n\nRationale: Some URL open functions allow the use of file: or custom schemes (for use\ninstead of http: or https:). An attacker may be able to use these\nschemes to access or modify unauthorized resources, and cause unexpected\nbehavior.\n\n\nTo mitigate this risk, audit all uses of URL open functions and ensure that\nonly permitted schemes are used (e.g., allowing http: and https:, and\ndisallowing file: and ftp:).\n\n\nIn preview, this rule will also flag references to URL open functions.\n\nExample:\nfrom urllib.request import urlopen\n\nurl = input(\"Enter a URL: \")\n\nwith urlopen(url) as response:\n    ...\n\n\n\nUse instead:\n\n\nfrom urllib.request import urlopen\n\nurl = input(\"Enter a URL: \")\n\nif not url.startswith((\"http:\", \"https:\")):\n    raise ValueError(\"URL must start with 'http:' or 'https:'\")\n\nwith urlopen(url) as response:\n    ...\n\n# Idiom S311 (suspicious-non-cryptographic-random-usage)\n\nDefinition: Checks for uses of cryptographically weak pseudo-random number generators.\n\nRationale: Cryptographically weak pseudo-random number generators are insecure, as they\nare easily predictable. This can allow an attacker to guess the generated\nnumbers and compromise the security of the system.\n\n\nInstead, use a cryptographically secure pseudo-random number generator\n(such as using the secrets module)\nwhen generating random numbers for security purposes.\n\n\nIn preview, this rule will also flag references to these generators.\n\nExample:\nimport random\n\nrandom.randrange(10)\n\n\n\nUse instead:\n\n\nimport secrets\n\nsecrets.randbelow(10)\n\n# Idiom S312 (suspicious-telnet-usage)\n\nDefinition: Checks for the use of Telnet-related functions.\n\nRationale: Telnet is considered insecure because it does not encrypt data sent over\nthe connection and is vulnerable to numerous attacks.\n\n\nInstead, consider using a more secure protocol such as SSH.\n\n\nIn preview, this rule will also flag references to Telnet-related functions.\n\n# Idiom S313 (suspicious-xmlc-element-tree-usage)\n\nDefinition: Checks for uses of insecure XML parsers.\n\nRationale: Many XML parsers are vulnerable to XML attacks (such as entity expansion),\nwhich cause excessive memory and CPU usage by exploiting recursion. An\nattacker could use such methods to access unauthorized resources.\n\n\nConsider using the defusedxml package when parsing untrusted XML data,\nto protect against XML attacks.\n\n\nIn preview, this rule will also flag references to insecure XML parsers.\n\nExample:\nfrom xml.etree.cElementTree import parse\n\ntree = parse(\"untrusted.xml\")  # Vulnerable to XML attacks.\n\n\n\nUse instead:\n\n\nfrom defusedxml.cElementTree import parse\n\ntree = parse(\"untrusted.xml\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PERF101-PERF102-PERF203",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PERF101 (unnecessary-list-cast)\n\nDefinition: Checks for explicit casts to list on for-loop iterables.\n\nRationale: Using a list() call to eagerly iterate over an already-iterable type\n(like a tuple, list, or set) is inefficient, as it forces Python to create\na new list unnecessarily.\n\n\nRemoving the list() call will not change the behavior of the code, but\nmay improve performance.\n\n\nNote that, as with all perflint rules, this is only intended as a\nmicro-optimization, and will have a negligible impact on performance in\nmost cases.\n\nExample:\nitems = (1, 2, 3)\nfor i in list(items):\n    print(i)\n\n\n\nUse instead:\n\n\nitems = (1, 2, 3)\nfor i in items:\n    print(i)\n\n# Idiom PERF102 (incorrect-dict-iterator)\n\nDefinition: Checks for uses of dict.items() that discard either the key or the value\nwhen iterating over the dictionary.\n\nRationale: If you only need the keys or values of a dictionary, you should use\ndict.keys() or dict.values() respectively, instead of dict.items().\nThese specialized methods are more efficient than dict.items(), as they\navoid allocating tuples for every item in the dictionary. They also\ncommunicate the intent of the code more clearly.\n\n\nNote that, as with all perflint rules, this is only intended as a\nmicro-optimization, and will have a negligible impact on performance in\nmost cases.\n\nExample:\nobj = {\"a\": 1, \"b\": 2}\nfor key, value in obj.items():\n    print(value)\n\n\n\nUse instead:\n\n\nobj = {\"a\": 1, \"b\": 2}\nfor value in obj.values():\n    print(value)\n\n# Idiom PERF203 (try-except-in-loop)\n\nDefinition: Checks for uses of except handling via try-except within for and\nwhile loops.\n\nRationale: Exception handling via try-except blocks incurs some performance\noverhead, regardless of whether an exception is raised.\n\n\nTo optimize your code, two techniques are possible:\n\n\n\nRefactor your code to put the entire loop into the try-except block,\n    rather than wrapping each iteration in a separate try-except block.\nUse \"Look Before You Leap\" idioms that attempt to avoid exceptions\n    being raised in the first place, avoiding the need to use try-except\n    blocks in the first place.\n\n\n\nThis rule is only enforced for Python versions prior to 3.11, which\nintroduced \"zero-cost\" exception handling. However, note that even on\nPython 3.11 and newer, refactoring your code to avoid exception handling in\ntight loops can provide a significant speedup in some cases, as zero-cost\nexception handling is only zero-cost in the \"happy path\" where no exception\nis raised in the try-except block.\n\n\nAs with all perflint rules, this is only intended as a\nmicro-optimization. In many cases, it will have a negligible impact on\nperformance.\n\nExample:\nstring_numbers: list[str] = [\"1\", \"2\", \"three\", \"4\", \"5\"]\n\n# `try`/`except` that could be moved out of the loop:\nint_numbers: list[int] = []\nfor num in string_numbers:\n    try:\n        int_numbers.append(int(num))\n    except ValueError as e:\n        print(f\"Couldn't convert to integer: {e}\")\n        break\n\n# `try`/`except` used when \"look before you leap\" idioms could be used:\nnumber_names: dict[int, str] = {1: \"one\", 3: \"three\", 4: \"four\"}\nfor number in range(5):\n    try:\n        name = number_names[number]\n    except KeyError:\n        continue\n    else:\n        print(f\"The name of {number} is {name}\")\n\n\n\nUse instead:\n\n\nstring_numbers: list[str] = [\"1\", \"2\", \"three\", \"4\", \"5\"]\n\nint_numbers: list[int] = []\ntry:\n    for num in string_numbers:\n        int_numbers.append(int(num))\nexcept ValueError as e:\n    print(f\"Couldn't convert to integer: {e}\")\n\nnumber_names: dict[int, str] = {1: \"one\", 3: \"three\", 4: \"four\"}\nfor number in range(5):\n    name = number_names.get(number)\n    if name is not None:\n        print(f\"The name of {number} is {name}\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PIE790-PIE794-PIE796-PIE800",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PIE790 (unnecessary-placeholder)\n\nDefinition: Checks for unnecessary pass statements and ellipsis (...) literals in\nfunctions, classes, and other blocks.\n\nRationale: In Python, the pass statement and ellipsis (...) literal serve as\nplaceholders, allowing for syntactically correct empty code blocks. The\nprimary purpose of these nodes is to avoid syntax errors in situations\nwhere a statement or expression is syntactically required, but no code\nneeds to be executed.\n\n\nIf a pass or ellipsis is present in a code block that includes at least\none other statement (even, e.g., a docstring), it is unnecessary and should\nbe removed.\n\nExample:\ndef func():\n    \"\"\"Placeholder docstring.\"\"\"\n    pass\n\n\n\nUse instead:\n\n\ndef func():\n    \"\"\"Placeholder docstring.\"\"\"\n\n\n\nOr, given:\n\n\ndef func():\n    \"\"\"Placeholder docstring.\"\"\"\n    ...\n\n\n\nUse instead:\n\n\ndef func():\n    \"\"\"Placeholder docstring.\"\"\"\n\n# Idiom PIE794 (duplicate-class-field-definition)\n\nDefinition: Checks for duplicate field definitions in classes.\n\nRationale: Defining a field multiple times in a class body is redundant and likely a\nmistake.\n\nExample:\nclass Person:\n    name = Tom\n    ...\n    name = Ben\n\n\n\nUse instead:\n\n\nclass Person:\n    name = Tom\n    ...\n\n# Idiom PIE796 (non-unique-enums)\n\nDefinition: Checks for enums that contain duplicate values.\n\nRationale: Enum values should be unique. Non-unique values are redundant and likely a\nmistake.\n\nExample:\nfrom enum import Enum\n\n\nclass Foo(Enum):\n    A = 1\n    B = 2\n    C = 1\n\n\n\nUse instead:\n\n\nfrom enum import Enum\n\n\nclass Foo(Enum):\n    A = 1\n    B = 2\n    C = 3\n\n# Idiom PIE800 (unnecessary-spread)\n\nDefinition: Checks for unnecessary dictionary unpacking operators (**).\n\nRationale: Unpacking a dictionary into another dictionary is redundant. The unpacking\noperator can be removed, making the code more readable.\n\nExample:\nfoo = {\"A\": 1, \"B\": 2}\nbar = {**foo, **{\"C\": 3}}\n\n\n\nUse instead:\n\n\nfoo = {\"A\": 1, \"B\": 2}\nbar = {**foo, \"C\": 3}\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PTH105-PTH106-PTH107-PTH108-PTH109",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PTH105 (os-replace)\n\nDefinition: Checks for uses of os.replace.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os. When possible, using Path object\nmethods such as Path.replace() can improve readability over the os\nmodule's counterparts (e.g., os.replace()).\n\n\nNote that os functions may be preferable if performance is a concern,\ne.g., in hot loops.\n\n# Idiom PTH106 (os-rmdir)\n\nDefinition: Checks for uses of os.rmdir.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os. When possible, using Path object\nmethods such as Path.rmdir() can improve readability over the os\nmodule's counterparts (e.g., os.rmdir()).\n\n# Idiom PTH107 (os-remove)\n\nDefinition: Checks for uses of os.remove.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os. When possible, using Path object\nmethods such as Path.unlink() can improve readability over the os\nmodule's counterparts (e.g., os.remove()).\n\n# Idiom PTH108 (os-unlink)\n\nDefinition: Checks for uses of os.unlink.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os. When possible, using Path object\nmethods such as Path.unlink() can improve readability over the os\nmodule's counterparts (e.g., os.unlink()).\n\n# Idiom PTH109 (os-getcwd)\n\nDefinition: Checks for uses of os.getcwd and os.getcwdb.\n\nRationale: pathlib offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by os. When possible, using Path object\nmethods such as Path.cwd() can improve readability over the os\nmodule's counterparts (e.g., os.getcwd()).\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/RET501-RET502-RET503-RET504",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom RET501 (unnecessary-return-none)\n\nDefinition: Checks for the presence of a return None statement when None is the only\npossible return value.\n\nRationale: Python implicitly assumes return None if an explicit return value is\nomitted. Therefore, explicitly returning None is redundant and should be\navoided when it is the only possible return value across all code paths\nin a given function.\n\nExample:\ndef foo(bar):\n    if not bar:\n        return\n    return None\n\n\n\nUse instead:\n\n\ndef foo(bar):\n    if not bar:\n        return\n    return\n\n# Idiom RET502 (implicit-return-value)\n\nDefinition: Checks for the presence of a return statement with no explicit value,\nfor functions that return non-None values elsewhere.\n\nRationale: Including a return statement with no explicit value can cause confusion\nwhen other return statements in the function return non-None values.\nPython implicitly assumes return None if no other return value is present.\nAdding an explicit return None can make the code more readable by clarifying\nintent.\n\nExample:\ndef foo(bar):\n    if not bar:\n        return\n    return 1\n\n\n\nUse instead:\n\n\ndef foo(bar):\n    if not bar:\n        return None\n    return 1\n\n# Idiom RET503 (implicit-return)\n\nDefinition: Checks for missing explicit return statements at the end of functions\nthat can return non-None values.\n\nRationale: The lack of an explicit return statement at the end of a function that\ncan return non-None values can cause confusion. Python implicitly returns\nNone if no other return value is present. Adding an explicit\nreturn None can make the code more readable by clarifying intent.\n\nExample:\ndef foo(bar):\n    if not bar:\n        return 1\n\n\n\nUse instead:\n\n\ndef foo(bar):\n    if not bar:\n        return 1\n    return None\n\n# Idiom RET504 (unnecessary-assign)\n\nDefinition: Checks for variable assignments that immediately precede a return of the\nassigned variable.\n\nRationale: The variable assignment is not necessary, as the value can be returned\ndirectly.\n\nExample:\ndef foo():\n    bar = 1\n    return bar\n\n\n\nUse instead:\n\n\ndef foo():\n    return 1\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PT013-PT014-PT015-PT016-PT017",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PT013 (pytest-incorrect-pytest-import)\n\nDefinition: Checks for incorrect import of pytest.\n\nRationale: For consistency, pytest should be imported as import pytest and its members should be\naccessed in the form of pytest.xxx.yyy for consistency\n\nExample:\nimport pytest as pt\nfrom pytest import fixture\n\n\n\nUse instead:\n\n\nimport pytest\n\n# Idiom PT014 (pytest-duplicate-parametrize-test-cases)\n\nDefinition: Checks for duplicate test cases in pytest.mark.parametrize.\n\nRationale: Duplicate test cases are redundant and should be removed.\n\nExample:\nimport pytest\n\n\n@pytest.mark.parametrize(\n    (\"param1\", \"param2\"),\n    [\n        (1, 2),\n        (1, 2),\n    ],\n)\ndef test_foo(param1, param2): ...\n\n\n\nUse instead:\n\n\nimport pytest\n\n\n@pytest.mark.parametrize(\n    (\"param1\", \"param2\"),\n    [\n        (1, 2),\n    ],\n)\ndef test_foo(param1, param2): ...\n\n# Idiom PT015 (pytest-assert-always-false)\n\nDefinition: Checks for assert statements whose test expression is a falsy value.\n\nRationale: pytest.fail conveys the intent more clearly than assert falsy_value.\n\nExample:\ndef test_foo():\n    if some_condition:\n        assert False, \"some_condition was True\"\n\n\n\nUse instead:\n\n\nimport pytest\n\n\ndef test_foo():\n    if some_condition:\n        pytest.fail(\"some_condition was True\")\n    ...\n\n# Idiom PT016 (pytest-fail-without-message)\n\nDefinition: Checks for pytest.fail calls without a message.\n\nRationale: pytest.fail calls without a message make it harder to understand and debug test failures.\n\nExample:\nimport pytest\n\n\ndef test_foo():\n    pytest.fail()\n\n\ndef test_bar():\n    pytest.fail(\"\")\n\n\ndef test_baz():\n    pytest.fail(reason=\"\")\n\n\n\nUse instead:\n\n\nimport pytest\n\n\ndef test_foo():\n    pytest.fail(\"...\")\n\n\ndef test_bar():\n    pytest.fail(reason=\"...\")\n\n# Idiom PT017 (pytest-assert-in-except)\n\nDefinition: Checks for assert statements in except clauses.\n\nRationale: When testing for exceptions, pytest.raises() should be used instead of\nassert statements in except clauses, as it's more explicit and\nidiomatic. Further, pytest.raises() will fail if the exception is not\nraised, unlike the assert statement.\n\nExample:\ndef test_foo():\n    try:\n        1 / 0\n    except ZeroDivisionError as e:\n        assert e.args\n\n\n\nUse instead:\n\n\nimport pytest\n\n\ndef test_foo():\n    with pytest.raises(ZeroDivisionError) as exc_info:\n        1 / 0\n    assert exc_info.value.args\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/S605-S606-S607-S608-S609",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom S605 (start-process-with-a-shell)\n\nDefinition: Checks for calls that start a process with a shell, providing guidance on\nwhether the usage is safe or not.\n\nRationale: Starting a process with a shell can introduce security risks, such as\ncode injection vulnerabilities. It's important to be aware of whether the\nusage of the shell is safe or not.\n\n\nThis rule triggers on functions like os.system, popen, etc., which\nstart processes with a shell. It evaluates whether the provided command\nis a literal string or an expression. If the command is a literal string,\nit's considered safe. If the command is an expression, it's considered\n(potentially) unsafe.\n\nExample:\nimport os\n\n# Safe usage (literal string)\ncommand = \"ls -l\"\nos.system(command)\n\n# Potentially unsafe usage (expression)\ncmd = get_user_input()\nos.system(cmd)\n\n# Idiom S606 (start-process-with-no-shell)\n\nDefinition: Checks for functions that start a process without a shell.\n\nRationale: Invoking any kind of external executable via a function call can pose\nsecurity risks if arbitrary variables are passed to the executable, or if\nthe input is otherwise unsanitised or unvalidated.\n\n\nThis rule specifically flags functions in the os module that spawn\nsubprocesses without the use of a shell. Note that these typically pose a\nmuch smaller security risk than subprocesses that are started with a\nshell, which are flagged by start-process-with-a-shell (S605).\nThis gives you the option of enabling one rule while disabling the other\nif you decide that the security risk from these functions is acceptable\nfor your use case.\n\nExample:\nimport os\n\n\ndef insecure_function(arbitrary_user_input: str):\n    os.spawnlp(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", arbitrary_user_input)\n\n# Idiom S607 (start-process-with-partial-path)\n\nDefinition: Checks for the starting of a process with a partial executable path.\n\nRationale: Starting a process with a partial executable path can allow attackers to\nexecute an arbitrary executable by adjusting the PATH environment variable.\nConsider using a full path to the executable instead.\n\nExample:\nimport subprocess\n\nsubprocess.Popen([\"ruff\", \"check\", \"file.py\"])\n\n\n\nUse instead:\n\n\nimport subprocess\n\nsubprocess.Popen([\"/usr/bin/ruff\", \"check\", \"file.py\"])\n\n# Idiom S608 (hardcoded-sql-expression)\n\nDefinition: Checks for strings that resemble SQL statements involved in some form\nstring building operation.\n\nRationale: SQL injection is a common attack vector for web applications. Directly\ninterpolating user input into SQL statements should always be avoided.\nInstead, favor parameterized queries, in which the SQL statement is\nprovided separately from its parameters, as supported by psycopg3\nand other database drivers and ORMs.\n\nExample:\nquery = \"DELETE FROM foo WHERE id = '%s'\" % identifier\n\n# Idiom S609 (unix-command-wildcard-injection)\n\nDefinition: Checks for possible wildcard injections in calls to subprocess.Popen().\n\nRationale: Wildcard injections can lead to unexpected behavior if unintended files are\nmatched by the wildcard. Consider using a more specific path instead.\n\nExample:\nimport subprocess\n\nsubprocess.Popen([\"chmod\", \"777\", \"*.py\"])\n\n\n\nUse instead:\n\n\nimport subprocess\n\nsubprocess.Popen([\"chmod\", \"777\", \"main.py\"])\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/E306-E401-E402-E502",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom E306 (blank-lines-before-nested-definition)\n\nDefinition: Checks for 1 blank line between nested function or class definitions.\n\nRationale: PEP 8 recommends using blank lines as follows:\n\n\n\nTwo blank lines are expected between functions and classes\nOne blank line is expected between methods of a class.\n\nExample:\ndef outer():\n    def inner():\n        pass\n    def inner2():\n        pass\n\n\n\nUse instead:\n\n\ndef outer():\n    def inner():\n        pass\n\n    def inner2():\n        pass\n\n# Idiom E401 (multiple-imports-on-one-line)\n\nDefinition: Check for multiple imports on one line.\n\nRationale: According to PEP 8, \"imports should usually be on separate lines.\"\n\nExample:\nimport sys, os\n\n\n\nUse instead:\n\n\nimport os\nimport sys\n\n# Idiom E402 (module-import-not-at-top-of-file)\n\nDefinition: Checks for imports that are not at the top of the file.\n\nRationale: According to PEP 8, \"imports are always put at the top of the file, just after any\nmodule comments and docstrings, and before module globals and constants.\"\n\n\nThis rule makes an exception for both sys.path modifications (allowing for\nsys.path.insert, sys.path.append, etc.) and os.environ modifications\nbetween imports.\n\nExample:\n\"One string\"\n\"Two string\"\na = 1\nimport os\nfrom sys import x\n\n\n\nUse instead:\n\n\nimport os\nfrom sys import x\n\n\"One string\"\n\"Two string\"\na = 1\n\n# Idiom E502 (redundant-backslash)\n\nDefinition: Checks for redundant backslashes between brackets.\n\nRationale: Explicit line joins using a backslash are redundant between brackets.\n\nExample:\nx = (2 + \\\n    2)\n\n\n\nUse instead:\n\n\nx = (2 +\n    2)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/TRY002-TRY003-TRY004-TRY201-TRY203",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom TRY002 (raise-vanilla-class)\n\nDefinition: Checks for code that raises Exception or BaseException directly.\n\nRationale: Handling such exceptions requires the use of except Exception or\nexcept BaseException. These will capture almost any raised exception,\nincluding failed assertions, division by zero, and more.\n\n\nPrefer to raise your own exception, or a more specific built-in\nexception, so that you can avoid over-capturing exceptions that you\ndon't intend to handle.\n\nExample:\ndef main_function():\n    if not cond:\n        raise Exception()\n\n\ndef consumer_func():\n    try:\n        do_step()\n        prepare()\n        main_function()\n    except Exception:\n        logger.error(\"Oops\")\n\n\n\nUse instead:\n\n\ndef main_function():\n    if not cond:\n        raise CustomException()\n\n\ndef consumer_func():\n    try:\n        do_step()\n        prepare()\n        main_function()\n    except CustomException:\n        logger.error(\"Main function failed\")\n    except Exception:\n        logger.error(\"Oops\")\n\n# Idiom TRY003 (raise-vanilla-args)\n\nDefinition: Checks for long exception messages that are not defined in the exception\nclass itself.\n\nRationale: By formatting an exception message at the raise site, the exception class\nbecomes less reusable, and may now raise inconsistent messages depending on\nwhere it is raised.\n\n\nIf the exception message is instead defined within the exception class, it\nwill be consistent across all raise invocations.\n\n\nThis rule is not enforced for some built-in exceptions that are commonly\nraised with a message and would be unusual to subclass, such as\nNotImplementedError.\n\nExample:\nclass CantBeNegative(Exception):\n    pass\n\n\ndef foo(x):\n    if x < 0:\n        raise CantBeNegative(f\"{x} is negative\")\n\n\n\nUse instead:\n\n\nclass CantBeNegative(Exception):\n    def __init__(self, number):\n        super().__init__(f\"{number} is negative\")\n\n\ndef foo(x):\n    if x < 0:\n        raise CantBeNegative(x)\n\n# Idiom TRY004 (type-check-without-type-error)\n\nDefinition: Checks for type checks that do not raise TypeError.\n\nRationale: The Python documentation states that TypeError should be raised upon\nencountering an inappropriate type.\n\nExample:\ndef foo(n: int):\n    if isinstance(n, int):\n        pass\n    else:\n        raise ValueError(\"n must be an integer\")\n\n\n\nUse instead:\n\n\ndef foo(n: int):\n    if isinstance(n, int):\n        pass\n    else:\n        raise TypeError(\"n must be an integer\")\n\n# Idiom TRY201 (verbose-raise)\n\nDefinition: Checks for needless exception names in raise statements.\n\nRationale: It's redundant to specify the exception name in a raise statement if the\nexception is being re-raised.\n\nExample:\ndef foo():\n    try:\n        ...\n    except ValueError as exc:\n        raise exc\n\n\n\nUse instead:\n\n\ndef foo():\n    try:\n        ...\n    except ValueError:\n        raise\n\n# Idiom TRY203 (useless-try-except)\n\nDefinition: Checks for immediate uses of raise within exception handlers.\n\nRationale: Capturing an exception, only to immediately reraise it, has no effect.\nInstead, remove the error-handling code and let the exception propagate\nupwards without the unnecessary try-except block.\n\nExample:\ndef foo():\n    try:\n        bar()\n    except NotImplementedError:\n        raise\n\n\n\nUse instead:\n\n\ndef foo():\n    bar()\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/SIM905-SIM910-SIM911-RSE102",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom SIM905 (split-static-string)\n\nDefinition: Checks for static str.split calls that can be replaced with list literals.\n\nRationale: List literals are more readable and do not require the overhead of calling str.split.\n\nExample:\n\"a,b,c,d\".split(\",\")\n\n\n\nUse instead:\n\n\n[\"a\", \"b\", \"c\", \"d\"]\n\n# Idiom SIM910 (dict-get-with-none-default)\n\nDefinition: Checks for dict.get() calls that pass None as the default value.\n\nRationale: None is the default value for dict.get(), so it is redundant to pass it\nexplicitly.\n\nExample:\nages = {\"Tom\": 23, \"Maria\": 23, \"Dog\": 11}\nage = ages.get(\"Cat\", None)\n\n\n\nUse instead:\n\n\nages = {\"Tom\": 23, \"Maria\": 23, \"Dog\": 11}\nage = ages.get(\"Cat\")\n\n# Idiom SIM911 (zip-dict-keys-and-values)\n\nDefinition: Checks for use of zip() to iterate over keys and values of a dictionary at once.\n\nRationale: The dict type provides an .items() method which is faster and more readable.\n\nExample:\nflag_stars = {\"USA\": 50, \"Slovenia\": 3, \"Panama\": 2, \"Australia\": 6}\n\nfor country, stars in zip(flag_stars.keys(), flag_stars.values()):\n    print(f\"{country}'s flag has {stars} stars.\")\n\n\n\nUse instead:\n\n\nflag_stars = {\"USA\": 50, \"Slovenia\": 3, \"Panama\": 2, \"Australia\": 6}\n\nfor country, stars in flag_stars.items():\n    print(f\"{country}'s flag has {stars} stars.\")\n\n# Idiom RSE102 (unnecessary-paren-on-raise-exception)\n\nDefinition: Checks for unnecessary parentheses on raised exceptions.\n\nRationale: If an exception is raised without any arguments, parentheses are not\nrequired, as the raise statement accepts either an exception instance\nor an exception class (which is then implicitly instantiated).\n\n\nRemoving the parentheses makes the code more concise.\n\nExample:\nraise TypeError()\n\n\n\nUse instead:\n\n\nraise TypeError\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/S314-S315-S316-S317-S318",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom S314 (suspicious-xml-element-tree-usage)\n\nDefinition: Checks for uses of insecure XML parsers.\n\nRationale: Many XML parsers are vulnerable to XML attacks (such as entity expansion),\nwhich cause excessive memory and CPU usage by exploiting recursion. An\nattacker could use such methods to access unauthorized resources.\n\n\nConsider using the defusedxml package when parsing untrusted XML data,\nto protect against XML attacks.\n\n\nIn preview, this rule will also flag references to insecure XML parsers.\n\nExample:\nfrom xml.etree.ElementTree import parse\n\ntree = parse(\"untrusted.xml\")  # Vulnerable to XML attacks.\n\n\n\nUse instead:\n\n\nfrom defusedxml.ElementTree import parse\n\ntree = parse(\"untrusted.xml\")\n\n# Idiom S315 (suspicious-xml-expat-reader-usage)\n\nDefinition: Checks for uses of insecure XML parsers.\n\nRationale: Many XML parsers are vulnerable to XML attacks (such as entity expansion),\nwhich cause excessive memory and CPU usage by exploiting recursion. An\nattacker could use such methods to access unauthorized resources.\n\n\nConsider using the defusedxml package when parsing untrusted XML data,\nto protect against XML attacks.\n\n\nIn preview, this rule will also flag references to insecure XML parsers.\n\nExample:\nfrom xml.sax.expatreader import create_parser\n\nparser = create_parser()\n\n\n\nUse instead:\n\n\nfrom defusedxml.sax import create_parser\n\nparser = create_parser()\n\n# Idiom S316 (suspicious-xml-expat-builder-usage)\n\nDefinition: Checks for uses of insecure XML parsers.\n\nRationale: Many XML parsers are vulnerable to XML attacks (such as entity expansion),\nwhich cause excessive memory and CPU usage by exploiting recursion. An\nattacker could use such methods to access unauthorized resources.\n\n\nConsider using the defusedxml package when parsing untrusted XML data,\nto protect against XML attacks.\n\n\nIn preview, this rule will also flag references to insecure XML parsers.\n\nExample:\nfrom xml.dom.expatbuilder import parse\n\nparse(\"untrusted.xml\")\n\n\n\nUse instead:\n\n\nfrom defusedxml.expatbuilder import parse\n\ntree = parse(\"untrusted.xml\")\n\n# Idiom S317 (suspicious-xml-sax-usage)\n\nDefinition: Checks for uses of insecure XML parsers.\n\nRationale: Many XML parsers are vulnerable to XML attacks (such as entity expansion),\nwhich cause excessive memory and CPU usage by exploiting recursion. An\nattacker could use such methods to access unauthorized resources.\n\n\nConsider using the defusedxml package when parsing untrusted XML data,\nto protect against XML attacks.\n\n\nIn preview, this rule will also flag references to insecure XML parsers.\n\nExample:\nfrom xml.sax import make_parser\n\nmake_parser()\n\n\n\nUse instead:\n\n\nfrom defusedxml.sax import make_parser\n\nmake_parser()\n\n# Idiom S318 (suspicious-xml-mini-dom-usage)\n\nDefinition: Checks for uses of insecure XML parsers.\n\nRationale: Many XML parsers are vulnerable to XML attacks (such as entity expansion),\nwhich cause excessive memory and CPU usage by exploiting recursion. An\nattacker could use such methods to access unauthorized resources.\n\n\nConsider using the defusedxml package when parsing untrusted XML data,\nto protect against XML attacks.\n\n\nIn preview, this rule will also flag references to insecure XML parsers.\n\nExample:\nfrom xml.dom.minidom import parse\n\ncontent = parse(\"untrusted.xml\")\n\n\n\nUse instead:\n\n\nfrom defusedxml.minidom import parse\n\ncontent = parse(\"untrusted.xml\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PT018-PT019-PT020-PT021-PT022",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PT018 (pytest-composite-assertion)\n\nDefinition: Checks for assertions that combine multiple independent conditions.\n\nRationale: Composite assertion statements are harder to debug upon failure, as the\nfailure message will not indicate which condition failed.\n\nExample:\ndef test_foo():\n    assert something and something_else\n\n\ndef test_bar():\n    assert not (something or something_else)\n\n\n\nUse instead:\n\n\ndef test_foo():\n    assert something\n    assert something_else\n\n\ndef test_bar():\n    assert not something\n    assert not something_else\n\n# Idiom PT019 (pytest-fixture-param-without-value)\n\nDefinition: Checks for pytest test functions that should be decorated with\n@pytest.mark.usefixtures.\n\nRationale: In pytest, fixture injection is used to activate fixtures in a test\nfunction.\n\n\nFixtures can be injected either by passing them as parameters to the test\nfunction, or by using the @pytest.mark.usefixtures decorator.\n\n\nIf the test function depends on the fixture being activated, but does not\nuse it in the test body or otherwise rely on its return value, prefer\nthe @pytest.mark.usefixtures decorator, to make the dependency explicit\nand avoid the confusion caused by unused arguments.\n\nExample:\nimport pytest\n\n\n@pytest.fixture\ndef _patch_something(): ...\n\n\ndef test_foo(_patch_something): ...\n\n\n\nUse instead:\n\n\nimport pytest\n\n\n@pytest.fixture\ndef _patch_something(): ...\n\n\n@pytest.mark.usefixtures(\"_patch_something\")\ndef test_foo(): ...\n\n# Idiom PT020 (pytest-deprecated-yield-fixture)\n\nDefinition: Checks for pytest.yield_fixture usage.\n\nRationale: pytest.yield_fixture is deprecated. pytest.fixture should be used instead.\n\nExample:\nimport pytest\n\n\n@pytest.yield_fixture()\ndef my_fixture():\n    obj = SomeClass()\n    yield obj\n    obj.cleanup()\n\n\n\nUse instead:\n\n\nimport pytest\n\n\n@pytest.fixture()\ndef my_fixture():\n    obj = SomeClass()\n    yield obj\n    obj.cleanup()\n\n# Idiom PT021 (pytest-fixture-finalizer-callback)\n\nDefinition: Checks for unnecessary request.addfinalizer usages in pytest fixtures.\n\nRationale: pytest offers two ways to perform cleanup in fixture code. The first is\nsequential (via the yield statement), the second callback-based (via\nrequest.addfinalizer).\n\n\nThe sequential approach is more readable and should be preferred, unless\nthe fixture uses the \"factory as fixture\" pattern.\n\nExample:\nimport pytest\n\n\n@pytest.fixture()\ndef my_fixture(request):\n    resource = acquire_resource()\n    request.addfinalizer(resource.release)\n    return resource\n\n\n\nUse instead:\n\n\nimport pytest\n\n\n@pytest.fixture()\ndef my_fixture():\n    resource = acquire_resource()\n    yield resource\n    resource.release()\n\n\n# \"factory-as-fixture\" pattern\n@pytest.fixture()\ndef my_factory(request):\n    def create_resource(arg):\n        resource = acquire_resource(arg)\n        request.addfinalizer(resource.release)\n        return resource\n\n    return create_resource\n\n# Idiom PT022 (pytest-useless-yield-fixture)\n\nDefinition: Checks for unnecessary yield expressions in pytest fixtures.\n\nRationale: In pytest fixtures, the yield expression should only be used for fixtures\nthat include teardown code, to clean up the fixture after the test function\nhas finished executing.\n\nExample:\nimport pytest\n\n\n@pytest.fixture()\ndef my_fixture():\n    resource = acquire_resource()\n    yield resource\n\n\n\nUse instead:\n\n\nimport pytest\n\n\n@pytest.fixture()\ndef my_fixture_with_teardown():\n    resource = acquire_resource()\n    yield resource\n    resource.release()\n\n\n@pytest.fixture()\ndef my_fixture_without_teardown():\n    resource = acquire_resource()\n    return resource\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/FIX001-FIX002-FIX003-FIX004",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom FIX001 (line-contains-fixme)\n\nDefinition: Checks for \"FIXME\" comments.\n\nRationale: \"FIXME\" comments are used to describe an issue that should be resolved\n(usually, a bug or unexpected behavior).\n\n\nConsider resolving the issue before deploying the code.\n\n\nNote that if you use \"FIXME\" comments as a form of documentation, this\nrule may not be appropriate for your project.\n\nExample:\ndef speed(distance, time):\n    return distance / time  # FIXME: Raises ZeroDivisionError for time = 0.\n\n# Idiom FIX002 (line-contains-todo)\n\nDefinition: Checks for \"TODO\" comments.\n\nRationale: \"TODO\" comments are used to describe an issue that should be resolved\n(usually, a missing feature, optimization, or refactoring opportunity).\n\n\nConsider resolving the issue before deploying the code.\n\n\nNote that if you use \"TODO\" comments as a form of documentation (e.g.,\nto provide context for future work),\nthis rule may not be appropriate for your project.\n\nExample:\ndef greet(name):\n    return f\"Hello, {name}!\"  # TODO: Add support for custom greetings.\n\n# Idiom FIX003 (line-contains-xxx)\n\nDefinition: Checks for \"XXX\" comments.\n\nRationale: \"XXX\" comments are used to describe an issue that should be resolved.\n\n\nConsider resolving the issue before deploying the code, or, at minimum,\nusing a more descriptive comment tag (e.g, \"TODO\").\n\nExample:\ndef speed(distance, time):\n    return distance / time  # XXX: Raises ZeroDivisionError for time = 0.\n\n# Idiom FIX004 (line-contains-hack)\n\nDefinition: Checks for \"HACK\" comments.\n\nRationale: \"HACK\" comments are used to describe an issue that should be resolved\n(usually, a suboptimal solution or temporary workaround).\n\n\nConsider resolving the issue before deploying the code.\n\n\nNote that if you use \"HACK\" comments as a form of documentation, this\nrule may not be appropriate for your project.\n\nExample:\nimport os\n\n\ndef running_windows():  # HACK: Use platform module instead.\n    try:\n        os.mkdir(\"C:\\\\Windows\\\\System32\\\\\")\n    except FileExistsError:\n        return True\n    else:\n        os.rmdir(\"C:\\\\Windows\\\\System32\\\\\")\n        return False\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLE0100-PLE0101-PLE0115-PLE0116-PLE0117",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLE0100 (yield-in-init)\n\nDefinition: Checks for __init__ methods that are turned into generators by the\ninclusion of yield or yield from expressions.\n\nRationale: The __init__ method is the constructor for a given Python class,\nresponsible for initializing, rather than creating, new objects.\n\n\nThe __init__ method has to return None. By including a yield or\nyield from expression in an __init__, the method will return a\ngenerator object when called at runtime, resulting in a runtime error.\n\nExample:\nclass InitIsGenerator:\n    def __init__(self, i):\n        yield i\n\n# Idiom PLE0101 (return-in-init)\n\nDefinition: Checks for __init__ methods that return values.\n\nRationale: The __init__ method is the constructor for a given Python class,\nresponsible for initializing, rather than creating, new objects.\n\n\nThe __init__ method has to return None. Returning any value from\nan __init__ method will result in a runtime error.\n\nExample:\nclass Example:\n    def __init__(self):\n        return []\n\n\n\nUse instead:\n\n\nclass Example:\n    def __init__(self):\n        self.value = []\n\n# Idiom PLE0115 (nonlocal-and-global)\n\nDefinition: Checks for variables which are both declared as both nonlocal and\nglobal.\n\nRationale: A nonlocal variable is a variable that is defined in the nearest\nenclosing scope, but not in the global scope, while a global variable is\na variable that is defined in the global scope.\n\n\nDeclaring a variable as both nonlocal and global is contradictory and\nwill raise a SyntaxError.\n\nExample:\ncounter = 0\n\n\ndef increment():\n    global counter\n    nonlocal counter\n    counter += 1\n\n\n\nUse instead:\n\n\ncounter = 0\n\n\ndef increment():\n    global counter\n    counter += 1\n\n# Idiom PLE0116 (continue-in-finally)\n\nDefinition: Checks for continue statements inside finally\n\nRationale: continue statements were not allowed within finally clauses prior to\nPython 3.8. Using a continue statement within a finally clause can\ncause a SyntaxError.\n\nExample:\nwhile True:\n    try:\n        pass\n    finally:\n        continue\n\n\n\nUse instead:\n\n\nwhile True:\n    try:\n        pass\n    except Exception:\n        pass\n    else:\n        continue\n\n# Idiom PLE0117 (nonlocal-without-binding)\n\nDefinition: Checks for nonlocal names without bindings.\n\nRationale: nonlocal names must be bound to a name in an outer scope.\nViolating this rule leads to a SyntaxError at runtime.\n\nExample:\ndef foo():\n    def get_bar(self):\n        nonlocal bar\n        ...\n\n\n\nUse instead:\n\n\ndef foo():\n    bar = 1\n\n    def get_bar(self):\n        nonlocal bar\n        ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/E701-E702-E703-E711-E713",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom E701 (multiple-statements-on-one-line-colon)\n\nDefinition: Checks for compound statements (multiple statements on the same line).\n\nRationale: According to PEP 8, \"compound statements are generally discouraged\".\n\nExample:\nif foo == \"blah\": do_blah_thing()\n\n\n\nUse instead:\n\n\nif foo == \"blah\":\n    do_blah_thing()\n\n# Idiom E702 (multiple-statements-on-one-line-semicolon)\n\nDefinition: Checks for multiline statements on one line.\n\nRationale: According to PEP 8, including multi-clause statements on the same line is\ndiscouraged.\n\nExample:\ndo_one(); do_two(); do_three()\n\n\n\nUse instead:\n\n\ndo_one()\ndo_two()\ndo_three()\n\n# Idiom E703 (useless-semicolon)\n\nDefinition: Checks for statements that end with an unnecessary semicolon.\n\nRationale: A trailing semicolon is unnecessary and should be removed.\n\nExample:\ndo_four();  # useless semicolon\n\n\n\nUse instead:\n\n\ndo_four()\n\n# Idiom E711 (none-comparison)\n\nDefinition: Checks for comparisons to None which are not using the is operator.\n\nRationale: According to PEP 8, \"Comparisons to singletons like None should always be done with\nis or is not, never the equality operators.\"\n\nExample:\nif arg != None:\n    pass\nif None == arg:\n    pass\n\n\n\nUse instead:\n\n\nif arg is not None:\n    pass\n\n# Idiom E713 (not-in-test)\n\nDefinition: Checks for membership tests using not {element} in {collection}.\n\nRationale: Testing membership with {element} not in {collection} is more readable.\n\nExample:\nZ = not X in Y\nif not X.B in Y:\n    pass\n\n\n\nUse instead:\n\n\nZ = X not in Y\nif X.B not in Y:\n    pass\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PYI036-PYI041-PYI042-PYI043-PYI044",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PYI036 (bad-exit-annotation)\n\nDefinition: Checks for incorrect function signatures on __exit__ and __aexit__\nmethods.\n\nRationale: Improperly annotated __exit__ and __aexit__ methods can cause\nunexpected behavior when interacting with type checkers.\n\nExample:\nfrom types import TracebackType\n\nclass Foo:\n    def __exit__(\n        self, typ: BaseException, exc: BaseException, tb: TracebackType\n    ) -> None: ...\n\n\n\nUse instead:\n\n\nfrom types import TracebackType\n\nclass Foo:\n    def __exit__(\n        self,\n        typ: type[BaseException] | None,\n        exc: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None: ...\n\n# Idiom PYI041 (redundant-numeric-union)\n\nDefinition: Checks for parameter annotations that contain redundant unions between\nbuiltin numeric types (e.g., int | float).\n\nRationale: The typing specification states:\n\n\n\nPython\u2019s numeric types complex, float and int are not subtypes of\neach other, but to support common use cases, the type system contains a\nstraightforward shortcut: when an argument is annotated as having type\nfloat, an argument of type int is acceptable; similar, for an\nargument annotated as having type complex, arguments of type float or\nint are acceptable.\n\n\n\nAs such, a union that includes both int and float is redundant in the\nspecific context of a parameter annotation, as it is equivalent to a union\nthat only includes float. For readability and clarity, unions should omit\nredundant elements.\n\nExample:\ndef foo(x: float | int | str) -> None: ...\n\n\n\nUse instead:\n\n\ndef foo(x: float | str) -> None: ...\n\n# Idiom PYI042 (snake-case-type-alias)\n\nDefinition: Checks for type aliases that do not use the CamelCase naming convention.\n\nRationale: It's conventional to use the CamelCase naming convention for type aliases,\nto distinguish them from other variables.\n\nExample:\ntype_alias_name: TypeAlias = int\n\n\n\nUse instead:\n\n\nTypeAliasName: TypeAlias = int\n\n# Idiom PYI043 (t-suffixed-type-alias)\n\nDefinition: Checks for private type alias definitions suffixed with 'T'.\n\nRationale: It's conventional to use the 'T' suffix for type variables; the use of\nsuch a suffix implies that the object is a TypeVar.\n\n\nAdding the 'T' suffix to a non-TypeVar, it can be misleading and should\nbe avoided.\n\nExample:\nfrom typing import TypeAlias\n\n_MyTypeT: TypeAlias = int\n\n\n\nUse instead:\n\n\nfrom typing import TypeAlias\n\n_MyType: TypeAlias = int\n\n# Idiom PYI044 (future-annotations-in-stub)\n\nDefinition: Checks for the presence of the from __future__ import annotations import\nstatement in stub files.\n\nRationale: Stub files natively support forward references in all contexts, as stubs are\nnever executed at runtime. (They should be thought of as \"data files\" for\ntype checkers.) As such, the from __future__ import annotations import\nstatement has no effect and should be omitted.\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/N801-N802-N803-N804",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom N801 (invalid-class-name)\n\nDefinition: Checks for class names that do not follow the CamelCase convention.\n\nRationale: PEP 8 recommends the use of the CapWords (or CamelCase) convention\nfor class names:\n\n\n\nClass names should normally use the CapWords convention.\nThe naming convention for functions may be used instead in cases where the interface is\ndocumented and used primarily as a callable.\nNote that there is a separate convention for builtin names: most builtin names are single\nwords (or two words run together), with the CapWords convention used only for exception\nnames and builtin constants.\n\nExample:\nclass my_class:\n    pass\n\n\n\nUse instead:\n\n\nclass MyClass:\n    pass\n\n# Idiom N802 (invalid-function-name)\n\nDefinition: Checks for functions names that do not follow the snake_case naming\nconvention.\n\nRationale: PEP 8 recommends that function names follow snake_case:\n\n\n\nFunction names should be lowercase, with words separated by underscores as necessary to\nimprove readability. mixedCase is allowed only in contexts where that\u2019s already the\nprevailing style (e.g. threading.py), to retain backwards compatibility.\n\n\n\nNames can be excluded from this rule using the lint.pep8-naming.ignore-names\nor lint.pep8-naming.extend-ignore-names configuration options. For example,\nto ignore all functions starting with test_ from this rule, set the\nlint.pep8-naming.extend-ignore-names option to [\"test_*\"].\n\nExample:\ndef myFunction():\n    pass\n\n\n\nUse instead:\n\n\ndef my_function():\n    pass\n\n# Idiom N803 (invalid-argument-name)\n\nDefinition: Checks for argument names that do not follow the snake_case convention.\n\nRationale: PEP 8 recommends that function names should be lower case and separated\nby underscores (also known as snake_case).\n\n\n\nFunction names should be lowercase, with words separated by underscores\nas necessary to improve readability.\nVariable names follow the same convention as function names.\nmixedCase is allowed only in contexts where that\u2019s already the\nprevailing style (e.g. threading.py), to retain backwards compatibility.\n\n\n\nMethods decorated with @typing.override are ignored.\n\nExample:\ndef my_function(A, myArg):\n    pass\n\n\n\nUse instead:\n\n\ndef my_function(a, my_arg):\n    pass\n\n# Idiom N804 (invalid-first-argument-name-for-class-method)\n\nDefinition: Checks for class methods that use a name other than cls for their\nfirst argument.\n\n\nThe method __new__ is exempted from this\ncheck and the corresponding violation is caught by\nbad-staticmethod-argument.\n\nRationale: PEP 8 recommends the use of cls as the first argument for all class\nmethods:\n\n\n\nAlways use cls for the first argument to class methods.\nIf a function argument\u2019s name clashes with a reserved keyword, it is generally better to\nappend a single trailing underscore rather than use an abbreviation or spelling corruption.\nThus class_ is better than clss. (Perhaps better is to avoid such clashes by using a synonym.)\n\n\n\nNames can be excluded from this rule using the lint.pep8-naming.ignore-names\nor lint.pep8-naming.extend-ignore-names configuration options. For example,\nto allow the use of klass as the first argument to class methods, set\nthe lint.pep8-naming.extend-ignore-names option to [\"klass\"].\n\nExample:\nclass Example:\n    @classmethod\n    def function(self, data): ...\n\n\n\nUse instead:\n\n\nclass Example:\n    @classmethod\n    def function(cls, data): ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PD009-PD010-PD011-PD012",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PD009 (pandas-use-of-dot-iat)\n\nDefinition: Checks for uses of .iat on Pandas objects.\n\nRationale: The .iat method selects a single value from a DataFrame or Series based\non an ordinal index, and is slightly faster than using .iloc. However,\n.iloc is more idiomatic and versatile, as it can be used to select\nmultiple values at once.\n\n\nIf performance is an important consideration, convert the object to a NumPy\narray, which will provide a much greater performance boost than using .iat\nover .iloc.\n\nExample:\nimport pandas as pd\n\nstudents_df = pd.read_csv(\"students.csv\")\nstudents_df.iat[0]\n\n\n\nUse instead:\n\n\nimport pandas as pd\n\nstudents_df = pd.read_csv(\"students.csv\")\nstudents_df.iloc[0]\n\n\n\nOr, using NumPy:\n\n\nimport numpy as np\nimport pandas as pd\n\nstudents_df = pd.read_csv(\"students.csv\")\nstudents_df.to_numpy()[0]\n\n# Idiom PD010 (pandas-use-of-dot-pivot-or-unstack)\n\nDefinition: Checks for uses of .pivot or .unstack on Pandas objects.\n\nRationale: Prefer .pivot_table to .pivot or .unstack. .pivot_table is more general\nand can be used to implement the same behavior as .pivot and .unstack.\n\nExample:\nimport pandas as pd\n\ndf = pd.read_csv(\"cities.csv\")\ndf.pivot(index=\"city\", columns=\"year\", values=\"population\")\n\n\n\nUse instead:\n\n\nimport pandas as pd\n\ndf = pd.read_csv(\"cities.csv\")\ndf.pivot_table(index=\"city\", columns=\"year\", values=\"population\")\n\n# Idiom PD011 (pandas-use-of-dot-values)\n\nDefinition: Checks for uses of .values on Pandas Series and Index objects.\n\nRationale: The .values attribute is ambiguous as its return type is unclear. As\nsuch, it is no longer recommended by the Pandas documentation.\n\n\nInstead, use .to_numpy() to return a NumPy array, or .array to return a\nPandas ExtensionArray.\n\nExample:\nimport pandas as pd\n\nanimals = pd.read_csv(\"animals.csv\").values  # Ambiguous.\n\n\n\nUse instead:\n\n\nimport pandas as pd\n\nanimals = pd.read_csv(\"animals.csv\").to_numpy()  # Explicit.\n\n# Idiom PD012 (pandas-use-of-dot-read-table)\n\nDefinition: Checks for uses of pd.read_table to read CSV files.\n\nRationale: In the Pandas API, pd.read_csv and pd.read_table are equivalent apart\nfrom their default separator: pd.read_csv defaults to a comma (,),\nwhile pd.read_table defaults to a tab (\\t) as the default separator.\n\n\nPrefer pd.read_csv over pd.read_table when reading comma-separated\ndata (like CSV files), as it is more idiomatic.\n\nExample:\nimport pandas as pd\n\ncities_df = pd.read_table(\"cities.csv\", sep=\",\")\n\n\n\nUse instead:\n\n\nimport pandas as pd\n\ncities_df = pd.read_csv(\"cities.csv\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/D212-D213-D214-D215-D300",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom D212 (multi-line-summary-first-line)\n\nDefinition: Checks for docstring summary lines that are not positioned on the first\nphysical line of the docstring.\n\nRationale: PEP 257 recommends that multi-line docstrings consist of \"a summary line\njust like a one-line docstring, followed by a blank line, followed by a\nmore elaborate description.\"\n\n\nThe summary line should be located on the first physical line of the\ndocstring, immediately after the opening quotes.\n\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the google\nconvention, and disabled when using the numpy and pep257 conventions.\n\n\nFor an alternative, see D213.\n\nExample:\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"\n    Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the\n    bubble sort algorithm.\n    \"\"\"\n\n\n\nUse instead:\n\n\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n\n# Idiom D213 (multi-line-summary-second-line)\n\nDefinition: Checks for docstring summary lines that are not positioned on the second\nphysical line of the docstring.\n\nRationale: PEP 257 recommends that multi-line docstrings consist of \"a summary line\njust like a one-line docstring, followed by a blank line, followed by a\nmore elaborate description.\"\n\n\nThe summary line should be located on the second physical line of the\ndocstring, immediately after the opening quotes and the blank line.\n\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is disabled when using the google,\nnumpy, and pep257 conventions.\n\n\nFor an alternative, see D212.\n\nExample:\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the\n    bubble sort algorithm.\n    \"\"\"\n\n\n\nUse instead:\n\n\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"\n    Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n\n# Idiom D214 (overindented-section)\n\nDefinition: Checks for over-indented sections in docstrings.\n\nRationale: This rule enforces a consistent style for docstrings with multiple\nsections.\n\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body. The convention is that all sections should use\nconsistent indentation. In each section, the header should match the\nindentation of the docstring's opening quotes, and the body should be\nindented one level further.\n\n\nThis rule is enabled when using the numpy and google conventions, and\ndisabled when using the pep257 convention.\n\nExample:\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n        Args:\n            distance: Distance traveled.\n            time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n\n\nUse instead:\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n# Idiom D215 (overindented-section-underline)\n\nDefinition: Checks for over-indented section underlines in docstrings.\n\nRationale: This rule enforces a consistent style for multiline numpy-style docstrings,\nand helps prevent incorrect syntax in docstrings using reStructuredText.\n\n\nMultiline numpy-style docstrings are typically composed of a summary line,\nfollowed by a blank line, followed by a series of sections. Each section\nhas a section header and a section body, and there should be a series of\nunderline characters in the line following the header. The underline should\nhave the same indentation as the header.\n\n\nThis rule enforces a consistent style for multiline numpy-style docstrings\nwith sections. If your docstring uses reStructuredText, the rule also\nhelps protect against incorrect reStructuredText syntax, which would cause\nerrors if you tried to use a tool such as Sphinx to generate documentation\nfrom the docstring.\n\n\nThis rule is enabled when using the numpy convention, and disabled when\nusing the google or pep257 conventions.\n\nExample:\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n        ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n          -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n      ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n\n\nUse instead:\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n\n# Idiom D300 (triple-single-quotes)\n\nDefinition: Checks for docstrings that use '''triple single quotes''' instead of\n\"\"\"triple double quotes\"\"\".\n\nRationale: PEP 257 recommends\nthe use of \"\"\"triple double quotes\"\"\" for docstrings, to ensure\nconsistency.\n\nExample:\ndef kos_root():\n    '''Return the pathname of the KOS root directory.'''\n\n\n\nUse instead:\n\n\ndef kos_root():\n    \"\"\"Return the pathname of the KOS root directory.\"\"\"\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/S413-S415-S501-S502-S503",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom S413 (suspicious-pycrypto-import)\n\nDefinition: Checks for imports of several unsafe cryptography modules.\n\nRationale: The pycrypto library is known to have a publicly disclosed buffer\noverflow vulnerability. It is no longer actively maintained and has been\ndeprecated in favor of the pyca/cryptography library.\n\nExample:\nimport Crypto.Random\n\n# Idiom S415 (suspicious-pyghmi-import)\n\nDefinition: Checks for imports of the pyghmi module.\n\nRationale: pyghmi is an IPMI-related module, but IPMI is considered insecure.\nInstead, use an encrypted protocol.\n\nExample:\nimport pyghmi\n\n# Idiom S501 (request-with-no-cert-validation)\n\nDefinition: Checks for HTTPS requests that disable SSL certificate checks.\n\nRationale: If SSL certificates are not verified, an attacker could perform a \"man in\nthe middle\" attack by intercepting and modifying traffic between the client\nand server.\n\nExample:\nimport requests\n\nrequests.get(\"https://www.example.com\", verify=False)\n\n\n\nUse instead:\n\n\nimport requests\n\nrequests.get(\"https://www.example.com\")  # By default, `verify=True`.\n\n# Idiom S502 (ssl-insecure-version)\n\nDefinition: Checks for function calls with parameters that indicate the use of insecure\nSSL and TLS protocol versions.\n\nRationale: Several highly publicized exploitable flaws have been discovered in all\nversions of SSL and early versions of TLS. The following versions are\nconsidered insecure, and should be avoided:\n\n\n\nSSL v2\nSSL v3\nTLS v1\nTLS v1.1\n\n\n\nThis method supports detection on the Python's built-in ssl module and\nthe pyOpenSSL module.\n\nExample:\nimport ssl\n\nssl.wrap_socket(ssl_version=ssl.PROTOCOL_TLSv1)\n\n\n\nUse instead:\n\n\nimport ssl\n\nssl.wrap_socket(ssl_version=ssl.PROTOCOL_TLSv1_2)\n\n# Idiom S503 (ssl-with-bad-defaults)\n\nDefinition: Checks for function definitions with default arguments set to insecure SSL\nand TLS protocol versions.\n\nRationale: Several highly publicized exploitable flaws have been discovered in all\nversions of SSL and early versions of TLS. The following versions are\nconsidered insecure, and should be avoided:\n\n\n\nSSL v2\nSSL v3\nTLS v1\nTLS v1.1\n\nExample:\nimport ssl\n\n\ndef func(version=ssl.PROTOCOL_TLSv1): ...\n\n\n\nUse instead:\n\n\nimport ssl\n\n\ndef func(version=ssl.PROTOCOL_TLSv1_2): ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/G010-G101-G201-G202",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom G010 (logging-warn)\n\nDefinition: Checks for uses of logging.warn and logging.Logger.warn.\n\nRationale: logging.warn and logging.Logger.warn are deprecated in favor of\nlogging.warning and logging.Logger.warning, which are functionally\nequivalent.\n\nExample:\nimport logging\n\nlogging.warn(\"Something happened\")\n\n\n\nUse instead:\n\n\nimport logging\n\nlogging.warning(\"Something happened\")\n\n# Idiom G101 (logging-extra-attr-clash)\n\nDefinition: Checks for extra keywords in logging statements that clash with\nLogRecord attributes.\n\nRationale: The logging module provides a mechanism for passing additional values to\nbe logged using the extra keyword argument. These values are then passed\nto the LogRecord constructor.\n\n\nProviding a value via extra that clashes with one of the attributes of\nthe LogRecord constructor will raise a KeyError when the LogRecord is\nconstructed.\n\nExample:\nimport logging\n\nlogging.basicConfig(format=\"%(name) - %(message)s\", level=logging.INFO)\n\nusername = \"Maria\"\n\nlogging.info(\"Something happened\", extra=dict(name=username))\n\n\n\nUse instead:\n\n\nimport logging\n\nlogging.basicConfig(format=\"%(user_id)s - %(message)s\", level=logging.INFO)\n\nusername = \"Maria\"\n\nlogging.info(\"Something happened\", extra=dict(user_id=username))\n\n# Idiom G201 (logging-exc-info)\n\nDefinition: Checks for uses of logging.error that pass exc_info=True.\n\nRationale: Calling logging.error with exc_info=True is equivalent to calling\nlogging.exception. Using logging.exception is more concise, more\nreadable, and conveys the intent of the logging statement more clearly.\n\nExample:\nimport logging\n\ntry:\n    ...\nexcept ValueError:\n    logging.error(\"Exception occurred\", exc_info=True)\n\n\n\nUse instead:\n\n\nimport logging\n\ntry:\n    ...\nexcept ValueError:\n    logging.exception(\"Exception occurred\")\n\n# Idiom G202 (logging-redundant-exc-info)\n\nDefinition: Checks for redundant exc_info keyword arguments in logging statements.\n\nRationale: exc_info is True by default for logging.exception, and False by\ndefault for logging.error.\n\n\nPassing exc_info=True to logging.exception calls is redundant, as is\npassing exc_info=False to logging.error calls.\n\nExample:\nimport logging\n\ntry:\n    ...\nexcept ValueError:\n    logging.exception(\"Exception occurred\", exc_info=True)\n\n\n\nUse instead:\n\n\nimport logging\n\ntry:\n    ...\nexcept ValueError:\n    logging.exception(\"Exception occurred\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/NPY001-NPY002-NPY003-NPY201",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom NPY001 (numpy-deprecated-type-alias)\n\nDefinition: Checks for deprecated NumPy type aliases.\n\nRationale: NumPy's np.int has long been an alias of the builtin int; the same\nis true of np.float and others. These aliases exist primarily\nfor historic reasons, and have been a cause of frequent confusion\nfor newcomers.\n\n\nThese aliases were deprecated in 1.20, and removed in 1.24.\nNote, however, that np.bool and np.long were reintroduced in 2.0 with\ndifferent semantics, and are thus omitted from this rule.\n\nExample:\nimport numpy as np\n\nnp.int\n\n\n\nUse instead:\n\n\nint\n\n# Idiom NPY002 (numpy-legacy-random)\n\nDefinition: Checks for the use of legacy np.random function calls.\n\nRationale: According to the NumPy documentation's Legacy Random Generation:\n\n\n\nThe RandomState provides access to legacy generators... This class\nshould only be used if it is essential to have randoms that are\nidentical to what would have been produced by previous versions of\nNumPy.\n\n\n\nThe members exposed directly on the random module are convenience\nfunctions that alias to methods on a global singleton RandomState\ninstance. NumPy recommends using a dedicated Generator instance\nrather than the random variate generation methods exposed directly on\nthe random module, as the new Generator is both faster and has\nbetter statistical properties.\n\n\nSee the documentation on Random Sampling and NEP 19 for further\ndetails.\n\nExample:\nimport numpy as np\n\nnp.random.seed(1337)\nnp.random.normal()\n\n\n\nUse instead:\n\n\nrng = np.random.default_rng(1337)\nrng.normal()\n\n# Idiom NPY003 (numpy-deprecated-function)\n\nDefinition: Checks for uses of deprecated NumPy functions.\n\nRationale: When NumPy functions are deprecated, they are usually replaced with\nnewer, more efficient versions, or with functions that are more\nconsistent with the rest of the NumPy API.\n\n\nPrefer newer APIs over deprecated ones.\n\nExample:\nimport numpy as np\n\nnp.alltrue([True, False])\n\n\n\nUse instead:\n\n\nimport numpy as np\n\nnp.all([True, False])\n\n# Idiom NPY201 (numpy2-deprecation)\n\nDefinition: Checks for uses of NumPy functions and constants that were removed from\nthe main namespace in NumPy 2.0.\n\nRationale: NumPy 2.0 includes an overhaul of NumPy's Python API, intended to remove\nredundant aliases and routines, and establish unambiguous mechanisms for\naccessing constants, dtypes, and functions.\n\n\nAs part of this overhaul, a variety of deprecated NumPy functions and\nconstants were removed from the main namespace.\n\n\nThe majority of these functions and constants can be automatically replaced\nby other members of the NumPy API or by equivalents from the Python\nstandard library. With the exception of renaming numpy.byte_bounds to\nnumpy.lib.array_utils.byte_bounds, all such replacements are backwards\ncompatible with earlier versions of NumPy.\n\n\nThis rule flags all uses of removed members, along with automatic fixes for\nany backwards-compatible replacements.\n\nExample:\nimport numpy as np\n\narr1 = [np.Infinity, np.NaN, np.nan, np.PINF, np.inf]\narr2 = [np.float_(1.5), np.float64(5.1)]\nnp.round_(arr2)\n\n\n\nUse instead:\n\n\nimport numpy as np\n\narr1 = [np.inf, np.nan, np.nan, np.inf, np.inf]\narr2 = [np.float64(1.5), np.float64(5.1)]\nnp.round(arr2)\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PYI050-PYI051-PYI052-PYI053-PYI054",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PYI050 (no-return-argument-annotation-in-stub)\n\nDefinition: Checks for uses of typing.NoReturn (and typing_extensions.NoReturn) for\nparameter annotations.\n\nRationale: Prefer Never over NoReturn for parameter annotations. Never has a\nclearer name in these contexts, since it makes little sense to talk about a\nparameter annotation \"not returning\".\n\n\nThis is a purely stylistic lint: the two types have identical semantics for\ntype checkers. Both represent Python's \"bottom type\" (a type that has no\nmembers).\n\nExample:\nfrom typing import NoReturn\n\ndef foo(x: NoReturn): ...\n\n\n\nUse instead:\n\n\nfrom typing import Never\n\ndef foo(x: Never): ...\n\n# Idiom PYI051 (redundant-literal-union)\n\nDefinition: Checks for redundant unions between a Literal and a builtin supertype of\nthat Literal.\n\nRationale: Using a Literal type in a union with its builtin supertype is redundant,\nas the supertype will be strictly more general than the Literal type.\nFor example, Literal[\"A\"] | str is equivalent to str, and\nLiteral[1] | int is equivalent to int, as str and int are the\nsupertypes of \"A\" and 1 respectively.\n\nExample:\nfrom typing import Literal\n\nx: Literal[\"A\", b\"B\"] | str\n\n\n\nUse instead:\n\n\nfrom typing import Literal\n\nx: Literal[b\"B\"] | str\n\n# Idiom PYI052 (unannotated-assignment-in-stub)\n\nDefinition: Checks for unannotated assignments in stub (.pyi) files.\n\nRationale: Stub files exist to provide type hints, and are never executed. As such,\nall assignments in stub files should be annotated with a type.\n\n# Idiom PYI053 (string-or-bytes-too-long)\n\nDefinition: Checks for the use of string and bytes literals longer than 50 characters\nin stub (.pyi) files.\n\nRationale: If a function or variable has a default value where the string or bytes\nrepresentation is greater than 50 characters long, it is likely to be an\nimplementation detail or a constant that varies depending on the system\nyou're running on.\n\n\nAlthough IDEs may find them useful, default values are ignored by type\ncheckers, the primary consumers of stub files. Replace very long constants\nwith ellipses (...) to simplify the stub.\n\nExample:\ndef foo(arg: str = \"51 character stringgggggggggggggggggggggggggggggggg\") -> None: ...\n\n\n\nUse instead:\n\n\ndef foo(arg: str = ...) -> None: ...\n\n# Idiom PYI054 (numeric-literal-too-long)\n\nDefinition: Checks for numeric literals with a string representation longer than ten\ncharacters.\n\nRationale: If a function has a default value where the literal representation is\ngreater than 10 characters, the value is likely to be an implementation\ndetail or a constant that varies depending on the system you're running on.\n\n\nDefault values like these should generally be omitted from stubs. Use\nellipses (...) instead.\n\nExample:\ndef foo(arg: int = 693568516352839939918568862861217771399698285293568) -> None: ...\n\n\n\nUse instead:\n\n\ndef foo(arg: int = ...) -> None: ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/UP040-UP041-UP042-UP043-UP044",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom UP040 (non-pep695-type-alias)\n\nDefinition: Checks for use of TypeAlias annotations and TypeAliasType assignments\nfor declaring type aliases.\n\nRationale: The type keyword was introduced in Python 3.12 by PEP 695 for defining\ntype aliases. The type keyword is easier to read and provides cleaner\nsupport for generics.\n\nExample:\nListOfInt: TypeAlias = list[int]\nPositiveInt = TypeAliasType(\"PositiveInt\", Annotated[int, Gt(0)])\n\n\n\nUse instead:\n\n\ntype ListOfInt = list[int]\ntype PositiveInt = Annotated[int, Gt(0)]\n\n# Idiom UP041 (timeout-error-alias)\n\nDefinition: Checks for uses of exceptions that alias TimeoutError.\n\nRationale: TimeoutError is the builtin error type used for exceptions when a system\nfunction timed out at the system level.\n\n\nIn Python 3.10, socket.timeout was aliased to TimeoutError. In Python\n3.11, asyncio.TimeoutError was aliased to TimeoutError.\n\n\nThese aliases remain in place for compatibility with older versions of\nPython, but may be removed in future versions.\n\n\nPrefer using TimeoutError directly, as it is more idiomatic and future-proof.\n\nExample:\nraise asyncio.TimeoutError\n\n\n\nUse instead:\n\n\nraise TimeoutError\n\n# Idiom UP042 (replace-str-enum)\n\nDefinition: Checks for classes that inherit from both str and enum.Enum.\n\nRationale: Python 3.11 introduced enum.StrEnum, which is preferred over inheriting\nfrom both str and enum.Enum.\n\nExample:\nimport enum\n\n\nclass Foo(str, enum.Enum): ...\n\n\n\nUse instead:\n\n\nimport enum\n\n\nclass Foo(enum.StrEnum): ...\n\n# Idiom UP043 (unnecessary-default-type-args)\n\nDefinition: Checks for unnecessary default type arguments for Generator and\nAsyncGenerator on Python 3.13+.\n\nRationale: Python 3.13 introduced the ability for type parameters to specify default\nvalues. Following this change, several standard-library classes were\nupdated to add default values for some of their type parameters. For\nexample, Generator[int] is now equivalent to\nGenerator[int, None, None], as the second and third type parameters of\nGenerator now default to None.\n\n\nOmitting type arguments that match the default values can make the code\nmore concise and easier to read.\n\nExample:\nfrom collections.abc import Generator, AsyncGenerator\n\n\ndef sync_gen() -> Generator[int, None, None]:\n    yield 42\n\n\nasync def async_gen() -> AsyncGenerator[int, None]:\n    yield 42\n\n\n\nUse instead:\n\n\nfrom collections.abc import Generator, AsyncGenerator\n\n\ndef sync_gen() -> Generator[int]:\n    yield 42\n\n\nasync def async_gen() -> AsyncGenerator[int]:\n    yield 42\n\n# Idiom UP044 (non-pep646-unpack)\n\nDefinition: Checks for uses of Unpack[] on Python 3.11 and above, and suggests\nusing * instead.\n\nRationale: PEP 646 introduced a new syntax for unpacking sequences based on the *\noperator. This syntax is more concise and readable than the previous\nUnpack[] syntax.\n\nExample:\nfrom typing import Unpack\n\n\ndef foo(*args: Unpack[tuple[int, ...]]) -> None:\n    pass\n\n\n\nUse instead:\n\n\ndef foo(*args: *tuple[int, ...]) -> None:\n    pass\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PLE1307-PLE1310-PLE1507-PLE1519-PLE1520",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PLE1307 (bad-string-format-type)\n\nDefinition: Checks for mismatched argument types in \"old-style\" format strings.\n\nRationale: The format string is not checked at compile time, so it is easy to\nintroduce bugs by mistyping the format string.\n\nExample:\nprint(\"%d\" % \"1\")\n\n\n\nUse instead:\n\n\nprint(\"%d\" % 1)\n\n# Idiom PLE1310 (bad-str-strip-call)\n\nDefinition: Checks duplicate characters in str.strip calls.\n\nRationale: All characters in str.strip calls are removed from both the leading and\ntrailing ends of the string. Including duplicate characters in the call\nis redundant and often indicative of a mistake.\n\n\nIn Python 3.9 and later, you can use str.removeprefix and\nstr.removesuffix to remove an exact prefix or suffix from a string,\nrespectively, which should be preferred when possible.\n\nExample:\n# Evaluates to \"foo\".\n\"bar foo baz\".strip(\"bar baz \")\n\n\n\nUse instead:\n\n\n# Evaluates to \"foo\".\n\"bar foo baz\".strip(\"abrz \")  # \"foo\"\n\n\n\nOr:\n\n\n# Evaluates to \"foo\".\n\"bar foo baz\".removeprefix(\"bar \").removesuffix(\" baz\")\n\n# Idiom PLE1507 (invalid-envvar-value)\n\nDefinition: Checks for os.getenv calls with an invalid key argument.\n\nRationale: os.getenv only supports strings as the first argument (key).\n\n\nIf the provided argument is not a string, os.getenv will throw a\nTypeError at runtime.\n\nExample:\nos.getenv(1)\n\n\n\nUse instead:\n\n\nos.getenv(\"1\")\n\n# Idiom PLE1519 (singledispatch-method)\n\nDefinition: Checks for methods decorated with @singledispatch.\n\nRationale: The @singledispatch decorator is intended for use with functions, not methods.\n\n\nInstead, use the @singledispatchmethod decorator, or migrate the method to a\nstandalone function.\n\nExample:\nfrom functools import singledispatch\n\n\nclass Class:\n    @singledispatch\n    def method(self, arg): ...\n\n\n\nUse instead:\n\n\nfrom functools import singledispatchmethod\n\n\nclass Class:\n    @singledispatchmethod\n    def method(self, arg): ...\n\n# Idiom PLE1520 (singledispatchmethod-function)\n\nDefinition: Checks for non-method functions decorated with @singledispatchmethod.\n\nRationale: The @singledispatchmethod decorator is intended for use with methods, not\nfunctions.\n\n\nInstead, use the @singledispatch decorator.\n\nExample:\nfrom functools import singledispatchmethod\n\n\n@singledispatchmethod\ndef func(arg): ...\n\n\n\nUse instead:\n\n\nfrom functools import singledispatch\n\n\n@singledispatch\ndef func(arg): ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PYI045-PYI046-PYI047-PYI048-PYI049",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PYI045 (iter-method-return-iterable)\n\nDefinition: Checks for __iter__ methods in stubs that return Iterable[T] instead\nof an Iterator[T].\n\nRationale: __iter__ methods should always should return an Iterator of some kind,\nnot an Iterable.\n\n\nIn Python, an Iterable is an object that has an __iter__ method; an\nIterator is an object that has __iter__ and __next__ methods. All\n__iter__ methods are expected to return Iterators. Type checkers may\nnot always recognize an object as being iterable if its __iter__ method\ndoes not return an Iterator.\n\n\nEvery Iterator is an Iterable, but not every Iterable is an Iterator.\nFor example, list is an Iterable, but not an Iterator; you can obtain\nan iterator over a list's elements by passing the list to iter():\n\n\n>>> import collections.abc\n>>> x = [42]\n>>> isinstance(x, collections.abc.Iterable)\nTrue\n>>> isinstance(x, collections.abc.Iterator)\nFalse\n>>> next(x)\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nTypeError: 'list' object is not an iterator\n>>> y = iter(x)\n>>> isinstance(y, collections.abc.Iterable)\nTrue\n>>> isinstance(y, collections.abc.Iterator)\nTrue\n>>> next(y)\n42\n\n\n\nUsing Iterable rather than Iterator as a return type for an __iter__\nmethods would imply that you would not necessarily be able to call next()\non the returned object, violating the expectations of the interface.\n\nExample:\nimport collections.abc\n\n\nclass Klass:\n    def __iter__(self) -> collections.abc.Iterable[str]: ...\n\n\n\nUse instead:\n\n\nimport collections.abc\n\n\nclass Klass:\n    def __iter__(self) -> collections.abc.Iterator[str]: ...\n\n# Idiom PYI046 (unused-private-protocol)\n\nDefinition: Checks for the presence of unused private typing.Protocol definitions.\n\nRationale: A private typing.Protocol that is defined but not used is likely a\nmistake. It should either be used, made public, or removed to avoid\nconfusion.\n\nExample:\nimport typing\n\nclass _PrivateProtocol(typing.Protocol):\n    foo: int\n\n\n\nUse instead:\n\n\nimport typing\n\nclass _PrivateProtocol(typing.Protocol):\n    foo: int\n\ndef func(arg: _PrivateProtocol) -> None: ...\n\n# Idiom PYI047 (unused-private-type-alias)\n\nDefinition: Checks for the presence of unused private type aliases.\n\nRationale: A private type alias that is defined but not used is likely a\nmistake. It should either be used, made public, or removed to avoid\nconfusion.\n\nExample:\nimport typing\n\n_UnusedTypeAlias: typing.TypeAlias = int\n\n\n\nUse instead:\n\n\nimport typing\n\n_UsedTypeAlias: typing.TypeAlias = int\n\ndef func(arg: _UsedTypeAlias) -> _UsedTypeAlias: ...\n\n# Idiom PYI048 (stub-body-multiple-statements)\n\nDefinition: Checks for functions in stub (.pyi) files that contain multiple\nstatements.\n\nRationale: Stub files are never executed, and are only intended to define type hints.\nAs such, functions in stub files should not contain functional code, and\nshould instead contain only a single statement (e.g., ...).\n\nExample:\ndef function():\n    x = 1\n    y = 2\n    return x + y\n\n\n\nUse instead:\n\n\ndef function(): ...\n\n# Idiom PYI049 (unused-private-typed-dict)\n\nDefinition: Checks for the presence of unused private typing.TypedDict definitions.\n\nRationale: A private typing.TypedDict that is defined but not used is likely a\nmistake. It should either be used, made public, or removed to avoid\nconfusion.\n\nExample:\nimport typing\n\nclass _UnusedPrivateTypedDict(typing.TypedDict):\n    foo: list[int]\n\n\n\nUse instead:\n\n\nimport typing\n\nclass _UsedPrivateTypedDict(typing.TypedDict):\n    foo: set[str]\n\ndef func(arg: _UsedPrivateTypedDict) -> _UsedPrivateTypedDict: ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/FURB171-FURB177-FURB180-FURB181",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom FURB171 (single-item-membership-test)\n\nDefinition: Checks for membership tests against single-item containers.\n\nRationale: Performing a membership test against a container (like a list or set)\nwith a single item is less readable and less efficient than comparing\nagainst the item directly.\n\nExample:\n1 in [1]\n\n\n\nUse instead:\n\n\n1 == 1\n\n# Idiom FURB177 (implicit-cwd)\n\nDefinition: Checks for current-directory lookups using Path().resolve().\n\nRationale: When looking up the current directory, prefer Path.cwd() over\nPath().resolve(), as Path.cwd() is more explicit in its intent.\n\nExample:\ncwd = Path().resolve()\n\n\n\nUse instead:\n\n\ncwd = Path.cwd()\n\n# Idiom FURB180 (meta-class-abc-meta)\n\nDefinition: Checks for uses of metaclass=abc.ABCMeta to define abstract base classes\n(ABCs).\n\nRationale: Instead of class C(metaclass=abc.ABCMeta): ..., use class C(ABC): ...\nto define an abstract base class. Inheriting from the ABC wrapper class\nis semantically identical to setting metaclass=abc.ABCMeta, but more\nsuccinct.\n\nExample:\nclass C(metaclass=ABCMeta):\n    pass\n\n\n\nUse instead:\n\n\nclass C(ABC):\n    pass\n\n# Idiom FURB181 (hashlib-digest-hex)\n\nDefinition: Checks for the use of .digest().hex() on a hashlib hash, like sha512.\n\nRationale: When generating a hex digest from a hash, it's preferable to use the\n.hexdigest() method, rather than calling .digest() and then .hex(),\nas the former is more concise and readable.\n\nExample:\nfrom hashlib import sha512\n\nhashed = sha512(b\"some data\").digest().hex()\n\n\n\nUse instead:\n\n\nfrom hashlib import sha512\n\nhashed = sha512(b\"some data\").hexdigest()\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/PYI011-PYI012-PYI013-PYI014-PYI015",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom PYI011 (typed-argument-default-in-stub)\n\nDefinition: Checks for typed function arguments in stubs with complex default values.\n\nRationale: Stub (.pyi) files exist as \"data files\" for static analysis tools, and\nare not evaluated at runtime. While simple default values may be useful for\nsome tools that consume stubs, such as IDEs, they are ignored by type\ncheckers.\n\n\nInstead of including and reproducing a complex value, use ... to indicate\nthat the assignment has a default value, but that the value is \"complex\" or\nvaries according to the current platform or Python version. For the\npurposes of this rule, any default value counts as \"complex\" unless it is\na literal int, float, complex, bytes, str, bool, None, ...,\nor a simple container literal.\n\nExample:\ndef foo(arg: list[int] = list(range(10_000))) -> None: ...\n\n\n\nUse instead:\n\n\ndef foo(arg: list[int] = ...) -> None: ...\n\n# Idiom PYI012 (pass-in-class-body)\n\nDefinition: Checks for the presence of the pass statement in non-empty class bodies\nin .pyi files.\n\nRationale: The pass statement is always unnecessary in non-empty class bodies in\nstubs.\n\nExample:\nclass MyClass:\n    x: int\n    pass\n\n\n\nUse instead:\n\n\nclass MyClass:\n    x: int\n\n# Idiom PYI013 (ellipsis-in-non-empty-class-body)\n\nDefinition: Removes ellipses (...) in otherwise non-empty class bodies.\n\nRationale: An ellipsis in a class body is only necessary if the class body is\notherwise empty. If the class body is non-empty, then the ellipsis\nis redundant.\n\nExample:\nclass Foo:\n    ...\n    value: int\n\n\n\nUse instead:\n\n\nclass Foo:\n    value: int\n\n# Idiom PYI014 (argument-default-in-stub)\n\nDefinition: Checks for untyped function arguments in stubs with default values that\nare not \"simple\" /// (i.e., int, float, complex, bytes, str,\nbool, None, ..., or simple container literals).\n\nRationale: Stub (.pyi) files exist to define type hints, and are not evaluated at\nruntime. As such, function arguments in stub files should not have default\nvalues, as they are ignored by type checkers.\n\n\nHowever, the use of default values may be useful for IDEs and other\nconsumers of stub files, and so \"simple\" values may be worth including and\nare permitted by this rule.\n\n\nInstead of including and reproducing a complex value, use ... to indicate\nthat the assignment has a default value, but that the value is non-simple\nor varies according to the current platform or Python version.\n\nExample:\ndef foo(arg=[]) -> None: ...\n\n\n\nUse instead:\n\n\ndef foo(arg=...) -> None: ...\n\n# Idiom PYI015 (assignment-default-in-stub)\n\nDefinition: Checks for assignments in stubs with default values that are not \"simple\"\n(i.e., int, float, complex, bytes, str, bool, None, ..., or\nsimple container literals).\n\nRationale: Stub (.pyi) files exist to define type hints, and are not evaluated at\nruntime. As such, assignments in stub files should not include values,\nas they are ignored by type checkers.\n\n\nHowever, the use of such values may be useful for IDEs and other consumers\nof stub files, and so \"simple\" values may be worth including and are\npermitted by this rule.\n\n\nInstead of including and reproducing a complex value, use ... to indicate\nthat the assignment has a default value, but that the value is non-simple\nor varies according to the current platform or Python version.\n\nExample:\nfoo: str = \"...\"\n\n\n\nUse instead:\n\n\nfoo: str = ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/RUF024-RUF026-RUF027-RUF028-RUF029",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom RUF024 (mutable-fromkeys-value)\n\nDefinition: Checks for mutable objects passed as a value argument to dict.fromkeys.\n\nRationale: All values in the dictionary created by the dict.fromkeys method\nrefer to the same instance of the provided object. If that object is\nmodified, all values are modified, which can lead to unexpected behavior.\nFor example, if the empty list ([]) is provided as the default value,\nall values in the dictionary will use the same list; as such, appending to\nany one entry will append to all entries.\n\n\nInstead, use a comprehension to generate a dictionary with distinct\ninstances of the default value.\n\nExample:\ncities = dict.fromkeys([\"UK\", \"Poland\"], [])\ncities[\"UK\"].append(\"London\")\ncities[\"Poland\"].append(\"Poznan\")\nprint(cities)  # {'UK': ['London', 'Poznan'], 'Poland': ['London', 'Poznan']}\n\n\n\nUse instead:\n\n\ncities = {country: [] for country in [\"UK\", \"Poland\"]}\ncities[\"UK\"].append(\"London\")\ncities[\"Poland\"].append(\"Poznan\")\nprint(cities)  # {'UK': ['London'], 'Poland': ['Poznan']}\n\n# Idiom RUF026 (default-factory-kwarg)\n\nDefinition: Checks for incorrect usages of default_factory as a keyword argument when\ninitializing a defaultdict.\n\nRationale: The defaultdict constructor accepts a callable as its first argument.\nFor example, it's common to initialize a defaultdict with int or list\nvia defaultdict(int) or defaultdict(list), to create a dictionary that\nreturns 0 or [] respectively when a key is missing.\n\n\nThe default factory must be provided as a positional argument, as all\nkeyword arguments to defaultdict are interpreted as initial entries in\nthe dictionary. For example, defaultdict(foo=1, bar=2) will create a\ndictionary with {\"foo\": 1, \"bar\": 2} as its initial entries.\n\n\nAs such, defaultdict(default_factory=list) will create a dictionary with\n{\"default_factory\": list} as its initial entry, instead of a dictionary\nthat returns [] when a key is missing. Specifying a default_factory\nkeyword argument is almost always a mistake, and one that type checkers\ncan't reliably detect.\n\nExample:\ndefaultdict(default_factory=int)\ndefaultdict(default_factory=list)\n\n\n\nUse instead:\n\n\ndefaultdict(int)\ndefaultdict(list)\n\n# Idiom RUF027 (missing-f-string-syntax)\n\nDefinition: Searches for strings that look like they were meant to be f-strings, but are missing an f prefix.\n\nRationale: Expressions inside curly braces are only evaluated if the string has an f prefix.\n\nExample:\nname = \"Sarah\"\nday_of_week = \"Tuesday\"\nprint(\"Hello {name}! It is {day_of_week} today!\")\n\n\n\nUse instead:\n\n\nname = \"Sarah\"\nday_of_week = \"Tuesday\"\nprint(f\"Hello {name}! It is {day_of_week} today!\")\n\n# Idiom RUF028 (invalid-formatter-suppression-comment)\n\nDefinition: Checks for formatter suppression comments that are ineffective or incompatible\nwith Ruff's formatter.\n\nRationale: Suppression comments that do not actually prevent formatting could cause unintended changes\nwhen the formatter is run.\n\nExample:\nIn the following example, all suppression comments would cause\na rule violation.\n\n\ndef decorator():\n    pass\n\n\n@decorator\n# fmt: off\ndef example():\n    if True:\n        # fmt: skip\n        expression = [\n            # fmt: off\n            1,\n            2,\n        ]\n        # yapf: disable\n    # fmt: on\n    # yapf: enable\n\n# Idiom RUF029 (unused-async)\n\nDefinition: Checks for functions declared async that do not await or otherwise use features requiring the\nfunction to be declared async.\n\nRationale: Declaring a function async when it's not is usually a mistake, and will artificially limit the\ncontexts where that function may be called. In some cases, labeling a function async is\nsemantically meaningful (e.g. with the trio library).\n\nExample:\nasync def foo():\n    bar()\n\n\n\nUse instead:\n\n\ndef foo():\n    bar()\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    }
]