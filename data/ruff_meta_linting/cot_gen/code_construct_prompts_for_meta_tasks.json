[
    {
        "id": "rull_linter/B007-B008-B009-B010-B012",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom B007 (unused-loop-control-variable)\n\nDefinition: Checks for unused variables in loops (e.g., for and while statements).\n\nRationale: Defining a variable in a loop statement that is never used can confuse\nreaders.\n\n\nIf the variable is intended to be unused (e.g., to facilitate\ndestructuring of a tuple or other object), prefix it with an underscore\nto indicate the intent. Otherwise, remove the variable entirely.\n\nExample:\nfor i, j in foo:\n    bar(i)\n\n\n\nUse instead:\n\n\nfor i, _j in foo:\n    bar(i)\n\n# Idiom B008 (function-call-in-default-argument)\n\nDefinition: Checks for function calls in default function arguments.\n\nRationale: Any function call that's used in a default argument will only be performed\nonce, at definition time. The returned value will then be reused by all\ncalls to the function, which can lead to unexpected behaviour.\n\n\nCalls can be marked as an exception to this rule with the\nlint.flake8-bugbear.extend-immutable-calls configuration option.\n\n\nArguments with immutable type annotations will be ignored by this rule.\nTypes outside of the standard library can be marked as immutable with the\nlint.flake8-bugbear.extend-immutable-calls configuration option as well.\n\nExample:\ndef create_list() -> list[int]:\n    return [1, 2, 3]\n\n\ndef mutable_default(arg: list[int] = create_list()) -> list[int]:\n    arg.append(4)\n    return arg\n\n\n\nUse instead:\n\n\ndef better(arg: list[int] | None = None) -> list[int]:\n    if arg is None:\n        arg = create_list()\n\n    arg.append(4)\n    return arg\n\n\n\nIf the use of a singleton is intentional, assign the result call to a\nmodule-level variable, and use that variable in the default argument:\n\n\nERROR = ValueError(\"Hosts weren't successfully added\")\n\n\ndef add_host(error: Exception = ERROR) -> None: ...\n\n# Idiom B009 (get-attr-with-constant)\n\nDefinition: Checks for uses of getattr that take a constant attribute value as an\nargument (e.g., getattr(obj, \"foo\")).\n\nRationale: getattr is used to access attributes dynamically. If the attribute is\ndefined as a constant, it is no safer than a typical property access. When\npossible, prefer property access over getattr calls, as the former is\nmore concise and idiomatic.\n\nExample:\ngetattr(obj, \"foo\")\n\n\n\nUse instead:\n\n\nobj.foo\n\n# Idiom B010 (set-attr-with-constant)\n\nDefinition: Checks for uses of setattr that take a constant attribute value as an\nargument (e.g., setattr(obj, \"foo\", 42)).\n\nRationale: setattr is used to set attributes dynamically. If the attribute is\ndefined as a constant, it is no safer than a typical property access. When\npossible, prefer property access over setattr calls, as the former is\nmore concise and idiomatic.\n\nExample:\nsetattr(obj, \"foo\", 42)\n\n\n\nUse instead:\n\n\nobj.foo = 42\n\n# Idiom B012 (jump-statement-in-finally)\n\nDefinition: Checks for break, continue, and return statements in finally\nblocks.\n\nRationale: The use of break, continue, and return statements in finally blocks\ncan cause exceptions to be silenced.\n\n\nfinally blocks execute regardless of whether an exception is raised. If a\nbreak, continue, or return statement is reached in a finally block,\nany exception raised in the try or except blocks will be silenced.\n\nExample:\ndef speed(distance, time):\n    try:\n        return distance / time\n    except ZeroDivisionError:\n        raise ValueError(\"Time cannot be zero\")\n    finally:\n        return 299792458  # `ValueError` is silenced\n\n\n\nUse instead:\n\n\ndef speed(distance, time):\n    try:\n        return distance / time\n    except ZeroDivisionError:\n        raise ValueError(\"Time cannot be zero\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/N801-N802-N803-N804-N805",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom N801 (invalid-class-name)\n\nDefinition: Checks for class names that do not follow the CamelCase convention.\n\nRationale: PEP 8 recommends the use of the CapWords (or CamelCase) convention\nfor class names:\n\n\n\nClass names should normally use the CapWords convention.\nThe naming convention for functions may be used instead in cases where the interface is\ndocumented and used primarily as a callable.\nNote that there is a separate convention for builtin names: most builtin names are single\nwords (or two words run together), with the CapWords convention used only for exception\nnames and builtin constants.\n\nExample:\nclass my_class:\n    pass\n\n\n\nUse instead:\n\n\nclass MyClass:\n    pass\n\n# Idiom N802 (invalid-function-name)\n\nDefinition: Checks for functions names that do not follow the snake_case naming\nconvention.\n\nRationale: PEP 8 recommends that function names follow snake_case:\n\n\n\nFunction names should be lowercase, with words separated by underscores as necessary to\nimprove readability. mixedCase is allowed only in contexts where that\u2019s already the\nprevailing style (e.g. threading.py), to retain backwards compatibility.\n\n\n\nNames can be excluded from this rule using the lint.pep8-naming.ignore-names\nor lint.pep8-naming.extend-ignore-names configuration options. For example,\nto ignore all functions starting with test_ from this rule, set the\nlint.pep8-naming.extend-ignore-names option to [\"test_*\"].\n\nExample:\ndef myFunction():\n    pass\n\n\n\nUse instead:\n\n\ndef my_function():\n    pass\n\n# Idiom N803 (invalid-argument-name)\n\nDefinition: Checks for argument names that do not follow the snake_case convention.\n\nRationale: PEP 8 recommends that function names should be lower case and separated\nby underscores (also known as snake_case).\n\n\n\nFunction names should be lowercase, with words separated by underscores\nas necessary to improve readability.\nVariable names follow the same convention as function names.\nmixedCase is allowed only in contexts where that\u2019s already the\nprevailing style (e.g. threading.py), to retain backwards compatibility.\n\nExample:\ndef my_function(A, myArg):\n    pass\n\n\n\nUse instead:\n\n\ndef my_function(a, my_arg):\n    pass\n\n# Idiom N804 (invalid-first-argument-name-for-class-method)\n\nDefinition: Checks for class methods that use a name other than cls for their\nfirst argument.\n\nRationale: PEP 8 recommends the use of cls as the first argument for all class\nmethods:\n\n\n\nAlways use cls for the first argument to class methods.\nIf a function argument\u2019s name clashes with a reserved keyword, it is generally better to\nappend a single trailing underscore rather than use an abbreviation or spelling corruption.\nThus class_ is better than clss. (Perhaps better is to avoid such clashes by using a synonym.)\n\n\n\nNames can be excluded from this rule using the lint.pep8-naming.ignore-names\nor lint.pep8-naming.extend-ignore-names configuration options. For example,\nto allow the use of klass as the first argument to class methods, set\nthe lint.pep8-naming.extend-ignore-names option to [\"klass\"].\n\nExample:\nclass Example:\n    @classmethod\n    def function(self, data): ...\n\n\n\nUse instead:\n\n\nclass Example:\n    @classmethod\n    def function(cls, data): ...\n\n# Idiom N805 (invalid-first-argument-name-for-method)\n\nDefinition: Checks for instance methods that use a name other than self for their\nfirst argument.\n\nRationale: PEP 8 recommends the use of self as first argument for all instance\nmethods:\n\n\n\nAlways use self for the first argument to instance methods.\nIf a function argument\u2019s name clashes with a reserved keyword, it is generally better to\nappend a single trailing underscore rather than use an abbreviation or spelling corruption.\nThus class_ is better than clss. (Perhaps better is to avoid such clashes by using a synonym.)\n\n\n\nNames can be excluded from this rule using the lint.pep8-naming.ignore-names\nor lint.pep8-naming.extend-ignore-names configuration options. For example,\nto allow the use of this as the first argument to instance methods, set\nthe lint.pep8-naming.extend-ignore-names option to [\"this\"].\n\nExample:\nclass Example:\n    def function(cls, data): ...\n\n\n\nUse instead:\n\n\nclass Example:\n    def function(self, data): ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/UP007-UP008-UP009-UP010-UP011",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom UP007 (non-pep604-annotation-union)\n\nDefinition: Check for type annotations that can be rewritten based on PEP 604 syntax.\n\nRationale: PEP 604 introduced a new syntax for union type annotations based on the\n| operator. This syntax is more concise and readable than the previous\ntyping.Union and typing.Optional syntaxes.\n\n\nThis rule is enabled when targeting Python 3.10 or later (see:\ntarget-version). By default, it's also enabled for earlier Python\nversions if from __future__ import annotations is present, as\n__future__ annotations are not evaluated at runtime. If your code relies\non runtime type annotations (either directly or via a library like\nPydantic), you can disable this behavior for Python versions prior to 3.10\nby setting lint.pyupgrade.keep-runtime-typing to true.\n\nExample:\nfrom typing import Union\n\nfoo: Union[int, str] = 1\n\n\n\nUse instead:\n\n\nfoo: int | str = 1\n\n# Idiom UP008 (super-call-with-parameters)\n\nDefinition: Checks for super calls that pass redundant arguments.\n\nRationale: In Python 3, super can be invoked without any arguments when: (1) the\nfirst argument is __class__, and (2) the second argument is equivalent to\nthe first argument of the enclosing method.\n\n\nWhen possible, omit the arguments to super to make the code more concise\nand maintainable.\n\nExample:\nclass A:\n    def foo(self):\n        pass\n\n\nclass B(A):\n    def bar(self):\n        super(B, self).foo()\n\n\n\nUse instead:\n\n\nclass A:\n    def foo(self):\n        pass\n\n\nclass B(A):\n    def bar(self):\n        super().foo()\n\n# Idiom UP009 (utf8-encoding-declaration)\n\nDefinition: Checks for unnecessary UTF-8 encoding declarations.\n\nRationale: PEP 3120 makes UTF-8 the default encoding, so a UTF-8 encoding\ndeclaration is unnecessary.\n\nExample:\n# -*- coding: utf-8 -*-\nprint(\"Hello, world!\")\n\n\n\nUse instead:\n\n\nprint(\"Hello, world!\")\n\n# Idiom UP010 (unnecessary-future-import)\n\nDefinition: Checks for unnecessary __future__ imports.\n\nRationale: The __future__ module is used to enable features that are not yet\navailable in the current Python version. If a feature is already\navailable in the minimum supported Python version, importing it\nfrom __future__ is unnecessary and should be removed to avoid\nconfusion.\n\nExample:\nfrom __future__ import print_function\n\nprint(\"Hello, world!\")\n\n\n\nUse instead:\n\n\nprint(\"Hello, world!\")\n\n# Idiom UP011 (lru-cache-without-parameters)\n\nDefinition: Checks for unnecessary parentheses on functools.lru_cache decorators.\n\nRationale: Since Python 3.8, functools.lru_cache can be used as a decorator without\ntrailing parentheses, as long as no arguments are passed to it.\n\nExample:\nimport functools\n\n\n@functools.lru_cache()\ndef foo(): ...\n\n\n\nUse instead:\n\n\nimport functools\n\n\n@functools.lru_cache\ndef foo(): ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/ERA001-C901-I001-I002-BLE001",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom ERA001 (commented-out-code)\n\nDefinition: Checks for commented-out Python code.\n\nRationale: Commented-out code is dead code, and is often included inadvertently.\nIt should be removed.\n\nExample:\n# print(\"Hello, world!\")\n\n# Idiom C901 (complex-structure)\n\nDefinition: Checks for functions with a high McCabe complexity.\n\nRationale: The McCabe complexity of a function is a measure of the complexity of\nthe control flow graph of the function. It is calculated by adding\none to the number of decision points in the function. A decision\npoint is a place in the code where the program has a choice of two\nor more paths to follow.\n\n\nFunctions with a high complexity are hard to understand and maintain.\n\nExample:\ndef foo(a, b, c):\n    if a:\n        if b:\n            if c:\n                return 1\n            else:\n                return 2\n        else:\n            return 3\n    else:\n        return 4\n\n\n\nUse instead:\n\n\ndef foo(a, b, c):\n    if not a:\n        return 4\n    if not b:\n        return 3\n    if not c:\n        return 2\n    return 1\n\n# Idiom I001 (unsorted-imports)\n\nDefinition: De-duplicates, groups, and sorts imports based on the provided isort settings.\n\nRationale: Consistency is good. Use a common convention for imports to make your code\nmore readable and idiomatic.\n\nExample:\nimport pandas\nimport numpy as np\n\n\n\nUse instead:\n\n\nimport numpy as np\nimport pandas\n\n# Idiom I002 (missing-required-import)\n\nDefinition: Adds any required imports, as specified by the user, to the top of the\nfile.\n\nRationale: In some projects, certain imports are required to be present in all\nfiles. For example, some projects assume that\nfrom __future__ import annotations is enabled,\nand thus require that import to be\npresent in all files. Omitting a \"required\" import (as specified by\nthe user) can cause errors or unexpected behavior.\n\nExample:\nimport typing\n\n\n\nUse instead:\n\n\nfrom __future__ import annotations\n\nimport typing\n\n# Idiom BLE001 (blind-except)\n\nDefinition: Checks for except clauses that catch all exceptions. This includes\nbare except, except BaseException and except Exception.\n\nRationale: Overly broad except clauses can lead to unexpected behavior, such as\ncatching KeyboardInterrupt or SystemExit exceptions that prevent the\nuser from exiting the program.\n\n\nInstead of catching all exceptions, catch only those that are expected to\nbe raised in the try block.\n\nExample:\ntry:\n    foo()\nexcept BaseException:\n    ...\n\n\n\nUse instead:\n\n\ntry:\n    foo()\nexcept FileNotFoundError:\n    ...\n\n\n\nExceptions that are re-raised will not be flagged, as they're expected to\nbe caught elsewhere:\n\n\ntry:\n    foo()\nexcept BaseException:\n    raise\n\n\n\nExceptions that are logged via logging.exception() or logging.error()\nwith exc_info enabled will not be flagged, as this is a common pattern\nfor propagating exception traces:\n\n\ntry:\n    foo()\nexcept BaseException:\n    logging.exception(\"Something went wrong\")\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/B002-B003-B004-B005-B006",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom B002 (unary-prefix-increment-decrement)\n\nDefinition: Checks for the attempted use of the unary prefix increment (++) or\ndecrement operator (--).\n\nRationale: Python does not support the unary prefix increment or decrement operator.\nWriting ++n is equivalent to +(+(n)) and writing --n is equivalent to\n-(-(n)). In both cases, it is equivalent to n.\n\nExample:\n++x\n--y\n\n\n\nUse instead:\n\n\nx += 1\ny -= 1\n\n# Idiom B003 (assignment-to-os-environ)\n\nDefinition: Checks for assignments to os.environ.\n\nRationale: In Python, os.environ is a mapping that represents the environment of the\ncurrent process.\n\n\nHowever, reassigning to os.environ does not clear the environment. Instead,\nit merely updates the os.environ for the current process. This can lead to\nunexpected behavior, especially when running the program in a subprocess.\n\n\nInstead, use os.environ.clear() to clear the environment, or use the\nenv argument of subprocess.Popen to pass a custom environment to\na subprocess.\n\nExample:\nimport os\n\nos.environ = {\"foo\": \"bar\"}\n\n\n\nUse instead:\n\n\nimport os\n\nos.environ.clear()\nos.environ[\"foo\"] = \"bar\"\n\n# Idiom B004 (unreliable-callable-check)\n\nDefinition: Checks for uses of hasattr to test if an object is callable (e.g.,\nhasattr(obj, \"__call__\")).\n\nRationale: Using hasattr is an unreliable mechanism for testing if an object is\ncallable. If obj implements a custom __getattr__, or if its __call__\nis itself not callable, you may get misleading results.\n\n\nInstead, use callable(obj) to test if obj is callable.\n\nExample:\nhasattr(obj, \"__call__\")\n\n\n\nUse instead:\n\n\ncallable(obj)\n\n# Idiom B005 (strip-with-multi-characters)\n\nDefinition: Checks for uses of multi-character strings in .strip(), .lstrip(), and\n.rstrip() calls.\n\nRationale: All characters in the call to .strip(), .lstrip(), or .rstrip() are\nremoved from the leading and trailing ends of the string. If the string\ncontains multiple characters, the reader may be misled into thinking that\na prefix or suffix is being removed, rather than a set of characters.\n\n\nIn Python 3.9 and later, you can use str.removeprefix and\nstr.removesuffix to remove an exact prefix or suffix from a string,\nrespectively, which should be preferred when possible.\n\nExample:\n\"text.txt\".strip(\".txt\")  # \"e\"\n\n\n\nUse instead:\n\n\n\"text.txt\".removesuffix(\".txt\")  # \"text\"\n\n# Idiom B006 (mutable-argument-default)\n\nDefinition: Checks for uses of mutable objects as function argument defaults.\n\nRationale: Function defaults are evaluated once, when the function is defined.\n\n\nThe same mutable object is then shared across all calls to the function.\nIf the object is modified, those modifications will persist across calls,\nwhich can lead to unexpected behavior.\n\n\nInstead, prefer to use immutable data structures, or take None as a\ndefault, and initialize a new mutable object inside the function body\nfor each call.\n\n\nArguments with immutable type annotations will be ignored by this rule.\nTypes outside of the standard library can be marked as immutable with the\nlint.flake8-bugbear.extend-immutable-calls configuration option.\n\nExample:\ndef add_to_list(item, some_list=[]):\n    some_list.append(item)\n    return some_list\n\n\nl1 = add_to_list(0)  # [0]\nl2 = add_to_list(1)  # [0, 1]\n\n\n\nUse instead:\n\n\ndef add_to_list(item, some_list=None):\n    if some_list is None:\n        some_list = []\n    some_list.append(item)\n    return some_list\n\n\nl1 = add_to_list(0)  # [0]\nl2 = add_to_list(1)  # [1]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/N806-N807-N811-N812-N813",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom N806 (non-lowercase-variable-in-function)\n\nDefinition: Checks for the use of non-lowercase variable names in functions.\n\nRationale: PEP 8 recommends that all function variables use lowercase names:\n\n\n\nFunction names should be lowercase, with words separated by underscores as necessary to\nimprove readability. Variable names follow the same convention as function names. mixedCase\nis allowed only in contexts where that's already the prevailing style (e.g. threading.py),\nto retain backwards compatibility.\n\nExample:\ndef my_function(a):\n    B = a + 3\n    return B\n\n\n\nUse instead:\n\n\ndef my_function(a):\n    b = a + 3\n    return b\n\n# Idiom N807 (dunder-function-name)\n\nDefinition: Checks for functions with \"dunder\" names (that is, names with two\nleading and trailing underscores) that are not documented.\n\nRationale: PEP 8 recommends that only documented \"dunder\" methods are used:\n\n\n\n...\"magic\" objects or attributes that live in user-controlled\nnamespaces. E.g. __init__, __import__ or __file__. Never invent\nsuch names; only use them as documented.\n\nExample:\ndef __my_function__():\n    pass\n\n\n\nUse instead:\n\n\ndef my_function():\n    pass\n\n# Idiom N811 (constant-imported-as-non-constant)\n\nDefinition: Checks for constant imports that are aliased to non-constant-style\nnames.\n\nRationale: PEP 8 recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\nExample:\nfrom example import CONSTANT_VALUE as ConstantValue\n\n\n\nUse instead:\n\n\nfrom example import CONSTANT_VALUE\n\n# Idiom N812 (lowercase-imported-as-non-lowercase)\n\nDefinition: Checks for lowercase imports that are aliased to non-lowercase names.\n\nRationale: PEP 8 recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\nExample:\nfrom example import myclassname as MyClassName\n\n\n\nUse instead:\n\n\nfrom example import myclassname\n\n# Idiom N813 (camelcase-imported-as-lowercase)\n\nDefinition: Checks for CamelCase imports that are aliased to lowercase names.\n\nRationale: PEP 8 recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\nExample:\nfrom example import MyClassName as myclassname\n\n\n\nUse instead:\n\n\nfrom example import MyClassName\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/UP001-UP003-UP004-UP005-UP006",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom UP001 (useless-metaclass-type)\n\nDefinition: Checks for the use of __metaclass__ = type in class definitions.\n\nRationale: Since Python 3, __metaclass__ = type is implied and can thus be omitted.\n\nExample:\nclass Foo:\n    __metaclass__ = type\n\n\n\nUse instead:\n\n\nclass Foo: ...\n\n# Idiom UP003 (type-of-primitive)\n\nDefinition: Checks for uses of type that take a primitive as an argument.\n\nRationale: type() returns the type of a given object. A type of a primitive can\nalways be known in advance and accessed directly, which is more concise\nand explicit than using type().\n\nExample:\ntype(1)\n\n\n\nUse instead:\n\n\nint\n\n# Idiom UP004 (useless-object-inheritance)\n\nDefinition: Checks for classes that inherit from object.\n\nRationale: Since Python 3, all classes inherit from object by default, so object can\nbe omitted from the list of base classes.\n\nExample:\nclass Foo(object): ...\n\n\n\nUse instead:\n\n\nclass Foo: ...\n\n# Idiom UP005 (deprecated-unittest-alias)\n\nDefinition: Checks for uses of deprecated methods from the unittest module.\n\nRationale: The unittest module has deprecated aliases for some of its methods.\nThe deprecated aliases were removed in Python 3.12. Instead of aliases,\nuse their non-deprecated counterparts.\n\nExample:\nfrom unittest import TestCase\n\n\nclass SomeTest(TestCase):\n    def test_something(self):\n        self.assertEquals(1, 1)\n\n\n\nUse instead:\n\n\nfrom unittest import TestCase\n\n\nclass SomeTest(TestCase):\n    def test_something(self):\n        self.assertEqual(1, 1)\n\n# Idiom UP006 (non-pep585-annotation)\n\nDefinition: Checks for the use of generics that can be replaced with standard library\nvariants based on PEP 585.\n\nRationale: PEP 585 enabled collections in the Python standard library (like list)\nto be used as generics directly, instead of importing analogous members\nfrom the typing module (like typing.List).\n\n\nWhen available, the PEP 585 syntax should be used instead of importing\nmembers from the typing module, as it's more concise and readable.\nImporting those members from typing is considered deprecated as of PEP\n585.\n\n\nThis rule is enabled when targeting Python 3.9 or later (see:\ntarget-version). By default, it's also enabled for earlier Python\nversions if from __future__ import annotations is present, as\n__future__ annotations are not evaluated at runtime. If your code relies\non runtime type annotations (either directly or via a library like\nPydantic), you can disable this behavior for Python versions prior to 3.9\nby setting lint.pyupgrade.keep-runtime-typing to true.\n\nExample:\nfrom typing import List\n\nfoo: List[int] = [1, 2, 3]\n\n\n\nUse instead:\n\n\nfoo: list[int] = [1, 2, 3]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/E402-E701-E721-E741-E743",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom E402 (module-import-not-at-top-of-file)\n\nDefinition: Checks for imports that are not at the top of the file.\n\nRationale: According to PEP 8, \"imports are always put at the top of the file, just after any\nmodule comments and docstrings, and before module globals and constants.\"\n\n\nThis rule makes an exception for both sys.path modifications (allowing for\nsys.path.insert, sys.path.append, etc.) and os.environ modifications\nbetween imports.\n\nExample:\n\"One string\"\n\"Two string\"\na = 1\nimport os\nfrom sys import x\n\n\n\nUse instead:\n\n\nimport os\nfrom sys import x\n\n\"One string\"\n\"Two string\"\na = 1\n\n# Idiom E701 (multiple-statements-on-one-line-colon)\n\nDefinition: Checks for compound statements (multiple statements on the same line).\n\nRationale: According to PEP 8, \"compound statements are generally discouraged\".\n\nExample:\nif foo == \"blah\": do_blah_thing()\n\n\n\nUse instead:\n\n\nif foo == \"blah\":\n    do_blah_thing()\n\n# Idiom E721 (type-comparison)\n\nDefinition: Checks for object type comparisons using == and other comparison\noperators.\n\nRationale: Unlike a direct type comparison, isinstance will also check if an object\nis an instance of a class or a subclass thereof.\n\n\nIf you want to check for an exact type match, use is or is not.\n\nExample:\nif type(obj) == type(1):\n    pass\n\nif type(obj) == int:\n    pass\n\n\n\nUse instead:\n\n\nif isinstance(obj, int):\n    pass\n\n# Idiom E741 (ambiguous-variable-name)\n\nDefinition: Checks for the use of the characters 'l', 'O', or 'I' as variable names.\n\n\nNote: This rule is automatically disabled for all stub files\n(files with .pyi extensions). The rule has little relevance for authors\nof stubs: a well-written stub should aim to faithfully represent the\ninterface of the equivalent .py file as it exists at runtime, including any\nambiguously named variables in the runtime module.\n\nRationale: In some fonts, these characters are indistinguishable from the\nnumerals one and zero. When tempted to use 'l', use 'L' instead.\n\nExample:\nl = 0\nO = 123\nI = 42\n\n\n\nUse instead:\n\n\nL = 0\no = 123\ni = 42\n\n# Idiom E743 (ambiguous-function-name)\n\nDefinition: Checks for the use of the characters 'l', 'O', or 'I' as function names.\n\nRationale: In some fonts, these characters are indistinguishable from the\nnumerals one and zero. When tempted to use 'l', use 'L' instead.\n\nExample:\ndef l(x): ...\n\n\n\nUse instead:\n\n\ndef long_name(x): ...\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/F405-F501-F502-F601-F621",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom F405 (undefined-local-with-import-star-usage)\n\nDefinition: Checks for names that might be undefined, but may also be defined in a\nwildcard import.\n\nRationale: Wildcard imports (e.g., from module import *) make it hard to determine\nwhich symbols are available in the current namespace. If a module contains\na wildcard import, and a name in the current namespace has not been\nexplicitly defined or imported, then it's unclear whether the name is\nundefined or was imported by the wildcard import.\n\n\nIf the name is defined in via a wildcard import, that member should be\nimported explicitly to avoid confusion.\n\n\nIf the name is not defined in a wildcard import, it should be defined or\nimported.\n\nExample:\nfrom math import *\n\n\ndef area(radius):\n    return pi * radius**2\n\n\n\nUse instead:\n\n\nfrom math import pi\n\n\ndef area(radius):\n    return pi * radius**2\n\n# Idiom F501 (percent-format-invalid-format)\n\nDefinition: Checks for invalid printf-style format strings.\n\nRationale: Conversion specifiers are required for printf-style format strings. These\nspecifiers must contain a % character followed by a conversion type.\n\nExample:\n\"Hello, %\" % \"world\"\n\n\n\nUse instead:\n\n\n\"Hello, %s\" % \"world\"\n\n# Idiom F502 (percent-format-expected-mapping)\n\nDefinition: Checks for named placeholders in printf-style format strings without\nmapping-type values.\n\nRationale: When using named placeholders in printf-style format strings, the values\nmust be a map type (such as a dictionary). Otherwise, the expression will\nraise a TypeError.\n\nExample:\n\"%(greeting)s, %(name)s\" % (\"Hello\", \"World\")\n\n\n\nUse instead:\n\n\n\"%(greeting)s, %(name)s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n\n\n\nOr:\n\n\n\"%s, %s\" % (\"Hello\", \"World\")\n\n# Idiom F601 (multi-value-repeated-key-literal)\n\nDefinition: Checks for dictionary literals that associate multiple values with the\nsame key.\n\nRationale: Dictionary keys should be unique. If a key is associated with multiple values,\nthe earlier values will be overwritten. Including multiple values for the\nsame key in a dictionary literal is likely a mistake.\n\nExample:\nfoo = {\n    \"bar\": 1,\n    \"baz\": 2,\n    \"baz\": 3,\n}\nfoo[\"baz\"]  # 3\n\n\n\nUse instead:\n\n\nfoo = {\n    \"bar\": 1,\n    \"baz\": 2,\n}\nfoo[\"baz\"]  # 2\n\n# Idiom F621 (expressions-in-star-assignment)\n\nDefinition: Checks for the use of too many expressions in starred assignment statements.\n\nRationale: In assignment statements, starred expressions can be used to unpack iterables.\n\n\nIn Python 3, no more than 1 \\<< 8 assignments are allowed before a starred\nexpression, and no more than 1 \\<< 24 expressions are allowed after a starred\nexpression.\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    },
    {
        "id": "rull_linter/UP044-UP045-UP046-UP047-UP040",
        "prompt": "Look at the following list of code idiom specifications with definitions and examples:\n\n# Idiom UP044 (non-pep646-unpack)\n\nDefinition: Checks for uses of Unpack[] on Python 3.11 and above, and suggests\nusing * instead.\n\nRationale: PEP 646 introduced a new syntax for unpacking sequences based on the *\noperator. This syntax is more concise and readable than the previous\nUnpack[] syntax.\n\nExample:\nfrom typing import Unpack\n\n\ndef foo(*args: Unpack[tuple[int, ...]]) -> None:\n    pass\n\n\n\nUse instead:\n\n\ndef foo(*args: *tuple[int, ...]) -> None:\n    pass\n\n# Idiom UP045 (non-pep604-annotation-optional)\n\nDefinition: Check for typing.Optional annotations that can be rewritten based on PEP 604 syntax.\n\nRationale: PEP 604 introduced a new syntax for union type annotations based on the\n| operator. This syntax is more concise and readable than the previous\ntyping.Optional syntax.\n\n\nThis rule is enabled when targeting Python 3.10 or later (see:\ntarget-version). By default, it's also enabled for earlier Python\nversions if from __future__ import annotations is present, as\n__future__ annotations are not evaluated at runtime. If your code relies\non runtime type annotations (either directly or via a library like\nPydantic), you can disable this behavior for Python versions prior to 3.10\nby setting lint.pyupgrade.keep-runtime-typing to true.\n\nExample:\nfrom typing import Optional\n\nfoo: Optional[int] = None\n\n\n\nUse instead:\n\n\nfoo: int | None = None\n\n# Idiom UP046 (non-pep695-generic-class)\n\nDefinition: Checks for use of standalone type variables and parameter specifications in generic classes.\n\nRationale: Special type parameter syntax was introduced in Python 3.12 by PEP 695 for defining generic\nclasses. This syntax is easier to read and provides cleaner support for generics.\n\nExample:\nfrom typing import TypeVar\n\nT = TypeVar(\"T\")\n\n\nclass GenericClass(Generic[T]):\n    var: T\n\n\n\nUse instead:\n\n\nclass GenericClass[T]:\n    var: T\n\n# Idiom UP047 (non-pep695-generic-function)\n\nDefinition: Checks for use of standalone type variables and parameter specifications in generic functions.\n\nRationale: Special type parameter syntax was introduced in Python 3.12 by PEP 695 for defining generic\nfunctions. This syntax is easier to read and provides cleaner support for generics.\n\nExample:\nfrom typing import TypeVar\n\nT = TypeVar(\"T\")\n\n\ndef generic_function(var: T) -> T:\n    return var\n\n\n\nUse instead:\n\n\ndef generic_function[T](var: T) -> T:\n    return var\n\n# Idiom UP040 (non-pep695-type-alias)\n\nDefinition: Checks for use of TypeAlias annotations and TypeAliasType assignments\nfor declaring type aliases.\n\nRationale: The type keyword was introduced in Python 3.12 by PEP 695 for defining\ntype aliases. The type keyword is easier to read and provides cleaner\nsupport for generics.\n\nExample:\nListOfInt: TypeAlias = list[int]\nPositiveInt = TypeAliasType(\"PositiveInt\", Annotated[int, Gt(0)])\n\n\n\nUse instead:\n\n\ntype ListOfInt = list[int]\ntype PositiveInt = Annotated[int, Gt(0)]\n\nGiven these idioms compile an exhaustive list of code constructs that should be closely analyzed as well as conditions that should be applied and fixes to be suggested (if provided in the list). \nPlease note that for the conditions to be applied you should only include conditions explicitly mentioned in the definition. \nHowever you can try and extrapolate the examples provided to broaden the search of code constructs while strictly enforcing the definitions provided.\nRemember to make the conditions exactly as specific as the definitions no more and no less.\nFollow this format:\n\nIdiom B012: jump-statement-in-finally\nCode Constructs to Analyze: \n...\n\nCondition:\n...\n\nFix:\n...\n"
    }
]