{
    "what-it-does": "Checks for unnecessary list or set comprehensions passed to builtin functions that take an iterable.\n\n\nSet comprehensions are only a violation in the case where the builtin function does not care about\nduplication of elements in the passed iterable.",
    "why-is-this-bad": "Many builtin functions (this rule currently covers any and all in stable, along with min,\nmax, and sum in preview) accept any iterable, including a generator. Constructing a\ntemporary list via list comprehension is unnecessary and wastes memory for large iterables.\n\n\nany and all can also short-circuit iteration, saving a lot of time. The unnecessary\ncomprehension forces a full iteration of the input iterable, giving up the benefits of\nshort-circuiting. For example, compare the performance of all with a list comprehension\nagainst that of a generator in a case where an early short-circuit is possible (almost 40x\nfaster):\n\n\nIn [1]: %timeit all([i for i in range(1000)])\n8.14 \u00b5s \u00b1 25.4 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n\nIn [2]: %timeit all(i for i in range(1000))\n212 ns \u00b1 0.892 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\n\n\nThis performance improvement is due to short-circuiting. If the entire iterable has to be\ntraversed, the comprehension version may even be a bit faster: list allocation overhead is not\nnecessarily greater than generator overhead.\n\n\nApplying this rule simplifies the code and will usually save memory, but in the absence of\nshort-circuiting it may not improve performance. (It may even slightly regress performance,\nthough the difference will usually be small.)",
    "example": "any([x.id for x in bar])\nall([x.id for x in bar])\nsum([x.val for x in bar])\nmin([x.val for x in bar])\nmax([x.val for x in bar])\n\n\n\nUse instead:\n\n\nany(x.id for x in bar)\nall(x.id for x in bar)\nsum(x.val for x in bar)\nmin(x.val for x in bar)\nmax(x.val for x in bar)",
    "fix-safety": "This rule's fix is marked as unsafe, as it can change the behavior of the code if the iteration\nhas side effects (due to laziness and short-circuiting). The fix may also drop comments when\nrewriting some comprehensions.",
    "example-split": {
        "example-before": "any([x.id for x in bar])\nall([x.id for x in bar])\nsum([x.val for x in bar])\nmin([x.val for x in bar])\nmax([x.val for x in bar])\n\n",
        "example-after": "\nany(x.id for x in bar)\nall(x.id for x in bar)\nsum(x.val for x in bar)\nmin(x.val for x in bar)\nmax(x.val for x in bar)"
    }
}