{
    "what-it-does": "Checks for methods that are annotated with a fixed return type which\nshould instead be returning Self.",
    "why-is-this-bad": "If methods that generally return self at runtime are annotated with a\nfixed return type, and the class is subclassed, type checkers will not be\nable to infer the correct return type.\n\n\nFor example:\n\n\nclass Shape:\n    def set_scale(self, scale: float) -> Shape:\n        self.scale = scale\n        return self\n\nclass Circle(Shape):\n    def set_radius(self, radius: float) -> Circle:\n        self.radius = radius\n        return self\n\n# Type checker infers return type as `Shape`, not `Circle`.\nCircle().set_scale(0.5)\n\n# Thus, this expression is invalid, as `Shape` has no attribute `set_radius`.\nCircle().set_scale(0.5).set_radius(2.7)\n\n\n\nSpecifically, this check enforces that the return type of the following\nmethods is Self:\n\n\n\nIn-place binary-operation dunder methods, like __iadd__, __imul__, etc.\n__new__, __enter__, and __aenter__, if those methods return the\n    class name.\n__iter__ methods that return Iterator, despite the class inheriting\n    directly from Iterator.\n__aiter__ methods that return AsyncIterator, despite the class\n    inheriting directly from AsyncIterator.",
    "example": "class Foo:\n    def __new__(cls, *args: Any, **kwargs: Any) -> Foo: ...\n    def __enter__(self) -> Foo: ...\n    async def __aenter__(self) -> Foo: ...\n    def __iadd__(self, other: Foo) -> Foo: ...\n\n\n\nUse instead:\n\n\nfrom typing_extensions import Self\n\nclass Foo:\n    def __new__(cls, *args: Any, **kwargs: Any) -> Self: ...\n    def __enter__(self) -> Self: ...\n    async def __aenter__(self) -> Self: ...\n    def __iadd__(self, other: Foo) -> Self: ...",
    "fix-safety": "This rule's fix is marked as unsafe as it changes the meaning of your type annotations.",
    "example-split": {
        "example-before": "class Foo:\n    def __new__(cls, *args: Any, **kwargs: Any) -> Foo: ...\n    def __enter__(self) -> Foo: ...\n    async def __aenter__(self) -> Foo: ...\n    def __iadd__(self, other: Foo) -> Foo: ...\n\n",
        "example-after": "\nfrom typing_extensions import Self"
    }
}