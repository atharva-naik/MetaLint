{
    "what-it-does": "Checks for subclasses of collections.namedtuple or typing.NamedTuple\nthat lack a __slots__ definition.",
    "why-is-this-bad": "In Python, the __slots__ attribute allows you to explicitly define the\nattributes (instance variables) that a class can have. By default, Python\nuses a dictionary to store an object's attributes, which incurs some memory\noverhead. However, when __slots__ is defined, Python uses a more compact\ninternal structure to store the object's attributes, resulting in memory\nsavings.\n\n\nSubclasses of namedtuple inherit all the attributes and methods of the\nbuilt-in namedtuple class. Since tuples are typically immutable, they\ndon't require additional attributes beyond what the namedtuple class\nprovides. Defining __slots__ for subclasses of namedtuple prevents the\ncreation of a dictionary for each instance, reducing memory consumption.",
    "example": "from collections import namedtuple\n\n\nclass Foo(namedtuple(\"foo\", [\"str\", \"int\"])):\n    pass\n\n\n\nUse instead:\n\n\nfrom collections import namedtuple\n\n\nclass Foo(namedtuple(\"foo\", [\"str\", \"int\"])):\n    __slots__ = ()",
    "example-split": {
        "example-before": "from collections import namedtuple\n\n\nclass Foo(namedtuple(\"foo\", [\"str\", \"int\"])):\n    pass\n\n",
        "example-after": "\nfrom collections import namedtuple"
    }
}