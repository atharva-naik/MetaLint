code,name,what-it-does,why-is-this-bad,example,Implemented Filter?,Downstream Refactoring Needed?,Heuristics,Line Coverage,Span Coverage,Dhakshin Coverage
506,use-of-random-module-for-secrets,"Checks for usage of the random module in unsafe scenarios like password generation or secrets, such as account authentication, tokens, and similar.","The pseudo-random generators in the random module should NOT be used for security purposes as it is cryptographically insecure. The secrets module should be used to reliably generate cryptographically strong pseudo-random values suitable for managing secrets, such as account authentication, tokens, and similar.","characters = string.ascii_letters + string.punctuation  + string.digits
password =  """".join(random.choice(characters) for x in range(16))

Use instead:

characters = string.ascii_letters + string.punctuation  + string.digits
password =  """".join(secrets.choice(characters) for x in range(16))",Yes,,,Just the line using random.sample or random.choice,"function name only (e.g. random.sample, random.choice)",
557,dataclasses-not-used,Checks for cases where dataclasses can be used to simplify a custom class code,Creation of a custom class for a scenario that can be handled by dataclasses leads to unecessary duplication of code negatively affecting maintainability.,"class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return f""Point(x={self.x}, y={self.y})""

Use instead:

from dataclasses import dataclass

@dataclass
class Point:
    x: int
    y: int",Yes,,,All lines in the class definition,Class name only,
655,use-requirement-markings-for-typed-dict,Checks for cases where required or not required markings can be used to simplify TypedDict classes.,Creation of multiple subclasses to accomodate optional keys in TypedDict with a base class containing required keys leads to inefficient design and duplicated code that negatively impacts maintainability.,"class _MovieBase(TypedDict):  # implicitly total=True
    title: str

class Movie(_MovieBase, total=False):
    year: int

Use instead:

class Movie(TypedDict):
    title: str
    year: NotRequired[int]",Yes,Yes,"- Look at the presence of TypeDict used to create subclasses (IMP)
- Look for the TypedDict base class being sub-classed a lot!
- Check if total=False is used in class definition (IMP)",,,
634,use-structural-pattern-matching,Checks for cases where structural pattern matching can be used to simplify branching.,Having a complex if-else branching structure can lead to inefficient and unreadable code. Replacing it with an equivalent structural pattern matching or switch-case style structure can lead to more readable and efficient branching code.,"def handle_response(response):
    if isinstance(response, dict):
        if ""error"" in response:
            print(f""Error: {response['error']}"")
        elif ""data"" in response:
            print(f""Data: {response['data']}"")
        else:
            print(""Unknown response format"")
    elif isinstance(response, list):
        print(""List of items:"", response)
    else:
        print(""Invalid response type"")

Use instead:

def handle_response(response):
    match response:
        case {""error"": error_message}:
            print(f""Error: {error_message}"")
        case {""data"": data_content}:
            print(f""Data: {data_content}"")
        case list(items):
            print(""List of items:"", items)
        case _:
            print(""Invalid response type"")",Yes,,"Use AST analysis to determine if there is a complex if, else, elif ladder especially with nesting as well
- Length of ladder (number of conditons at the ""top level"" + one level in) >= 6
OR
- Depth of ladder (degree of nesting). If there is nesting depth of degree 3 then flag

E.g.:
if cond1:
    if cond2:
        if cond 3: pass",entire if else block,line corresponsing to first line number,
614,Relaxed Decorator Grammar,"Allows arbitrary expressions in decorator syntax, not just names, attribute references, or calls","temporary function or variable to use complex expressions as decorators, make code more verbose","def create_decorator(condition):
    return decorator_a if condition else decorator_b
decorator = create_decorator(some_condition)

@decorator
def func():
    pass

Use instead:

@(decorator_a if some_condition else decorator_b)
def func():
    pass

OR

time_check = lambda func: timed(threshold=0.5)(func)
@time_check
def heavy_calculation():

Use instead:

@lambda func: timed(threshold=0.5)(func)
def heavy_calculation():",Yes,, ,,,
616,String Prefix/Suffix Removal,Replaces manual slicing with dedicated methods,Manual slicing patterns are error-prone and obscure intent,"if s.startswith(prefix): s = s[len(prefix):]

Use instead:

s = s.removeprefix(prefix)

OR

s[:-len(suffix)]

Use instead:

s.removesuffix(suffix)",No,,"dysjunction of 2 conditions:
1. There is a ""check"" with startswith or endswith on a given variable x.
2. On the same variable x check if there is an ""edit"" using a program slicing syntax or using ""replace()"".",,,
584,Dictionary Union Operator,"Introduces | and |= operators for a more concise and intuitive syntax that mirrors set operations, providing a consistent and clear way to merge dictionaries.","Using dictionary unpacking ({**dict1, **dict2}), is verbose and creates a new dictionary each time, whereas using dict.update() modifies a dictionary in-place and returns None. Both methods pos challenges for readability and functional programming practices. ","d1 = {'a': 1, 'b': 2}
d2 = {'c': 3, 'd': 4}
merged = d1.copy()  
merged.update(d2)
d1 = {'a': 1, 'b': 2}
d2 = {'c': 3, 'd': 4}
merged = {**d1, **d2}
d1 = {'a': 1, 'b': 2}
d2 = {'c': 3, 'd': 4}
merged = dict(list(d1.items()) + list(d2.items()))

Use instead:

d1 = {'a': 1, 'b': 2}
d2 = {'c': 3, 'd': 4}
merged = d1 | d2

d1 = {'a': 1, 'b': 2}
d2 = {'c': 3, 'd': 4}
d1 |= d2  # d1 is now {'a': 1, 'b': 2, 'c': 3, 'd': 4}




",,,,,,
593,Type Metadata Annotation,"Allows adding context-specific metadata to type annotations without affecting the runtime type checker behavior, while Annotated provides a more structured way to include metadata, it doesn't automatically replace all comment-based annotations.","Manual metadata tracking via comments/custom classes and using custom container types or comment-based approaches for additional type metadata makes code harder to understand and maintain, is error-prone and couldn't capture complex metadata structures effectively","# Using comments or custom attributes for metadata
from typing import List

def process_data(data: List[int]):
    
    pass

Use instead:

from typing import Annotated, List

def process_data(data: List[Annotated[int, ""non-negative""]]):
    pass
",Yes,,"- There should be a function with at least one argument containing a type annotation OR an assignment statement with a type annotation
- The function or assignment statement should have a comment with one of the following keywords: ""non-negative"", ""range"" ...
OR
- The function should have a docstring with ...",,,
567,Context-Aware Variables,"introduces context variables that allow managing context-local state in a way that works well with asynchronous code, replacing or supplementing thread-local storage.","thread-local state does not propagate correctly across asynchronous tasks, leading to unexpected behavior and bugs. Violations occur when code continues to use thread-local variables instead of leveraging context variables,","import threading

_thread_local = threading.local()

def set_context(value):
    _thread_local.value = value

def get_context():
    return getattr(_thread_local, 'value', None)

Use instead:

# With PEP567: Using ContextVar for proper context-local state in asynchronous environments
from contextvars import ContextVar

context_var = ContextVar('value')

def set_context(value):
    context_var.set(value)

def get_context():
    return context_var.get()
",,,,,,Yes initial filter
530,Async Comprehension Optimization,Detects manual async loops that could be replaced with async for comprehensions,"Manual async loops using async for with append() obscure intent, create performance overhead by generating intermediate objects, risk improper await handling, and bypass Python 3.6+ async iterator protocols.","result = []
async for i in aiter():
if i % 2:
result.append(i)

Use instead:

result = [i async for i in aiter() if i % 2]",No,async fors,,entire block of for loop which is replaced by async fors,first line of the for lop in which async fors are applied,
525,Async Generator Opportunity,"Introduces asynchronous generator functions so that asynchronous iteration can be written using ""async for"" syntax.","asynchronous iteration was forced to use synchronous generators or manual event loop management. This led to verbose, error-prone code that was hard to read and maintain. Developers had to implement complex workarounds, which not only cluttered the codebase but also introduced subtle bugs and inefficiencies.","class Ticker:
    """"""Yield numbers from 0 to `to` every `delay` seconds.""""""

    def __init__(self, delay, to):
        self.delay = delay
        self.i = 0
        self.to = to

    def __aiter__(self):
        return self

    async def __anext__(self):
        i = self.i
        if i >= self.to:
            raise StopAsyncIteration
        self.i += 1
        if i:
            await asyncio.sleep(self.delay)
        return i

Use instead:

async def ticker(delay, to):
    """"""Yield numbers from 0 to `to` every `delay` seconds.""""""
    for i in range(to):
        yield i
        await asyncio.sleep(delay)
",,,,,,yes initial filter
498,f-string literals,Introduces a more concise and readable way to embed expressions inside string literals,"Using older string formatting methods creates more verbose, error-prone, and less readable code","name = ""Alice""
age = 30
greeting = ""Hello, "" + name + ""! You are "" + str(age) + "" years old.""

Use instead:

name = ""Alice""
age = 30
greeting = f""Hello, {name}! You are {age} years old.""

OR

value = 12.3456
formatted = ""The value is {:.2f}"".format(value)

Use instead:

value = 12.3456
formatted = f""The value is {value:.2f}""",,,,,,
487,simpler sub class creation customization,"Introduces ""__init_subclass__"" and descriptor ""__set_name__"" to simplify class customization without metaclasses",Using metaclasses for simple customization tasks makes code unnecessarily complex and harder to maintain,"class Meta(type):
    def __new__(meta, name, bases, namespace):
        for key, value in namespace.items():
            if isinstance(value, Descriptor):
                value.name = key
        return super().__new__(meta, name, bases, namespace)

class MyClass(metaclass=Meta):
    attr = Descriptor()

Use instead:

class Descriptor:
    def __set_name__(self, owner, name):
        self.name = name

class MyClass:
    attr = Descriptor()

OR

class PluginBase(type):
    plugins = {}

    def __new__(meta, name, bases, namespace):
        if name != 'Plugin':
            meta.plugins[name] = namespace['priority']
        return super().__new__(meta, name, bases, namespace)

class Plugin(metaclass=PluginBase):
    priority = 0

class HighPriority(Plugin):
    priority = 10


Use instead:

class Plugin:
    plugins = {}
    priority = 0

    def __init_subclass__(cls, **kwargs):
        super().__init_subclass__(**kwargs)
        cls.plugins[cls.__name__] = cls.priority

class HighPriority(Plugin):
    priority = 10


",,,,,,
526,Variable Annotations,Introduces a syntax for annotating variables with type hints,Using comments or docstrings for type information creates inconsistency with function annotations and makes it harder for static analyzers to work properly,"# type: List[int]
numbers = []

Use instead:

numbers: List[int] = []

OR

class Player:
# type: str<br>    name = ""Guest""

Use instead:

class Player:
    name: str = ""Guest""",,,,,,
572,Assignment Expressions," Introduces the := operator (the ""walrus operator"") to allow assignment of values to variables as part of an expression. This enables more concise and potentially more efficient code by combining assignment and evaluation, especially useful in conditions, comprehensions, and loops.","Before this PEP, Python required assignments to be standalone statements, which made some patterns unnecessarily verbose, duplicated computation, or introduced inefficiencies (like repeating the same function call). It also made certain idioms, such as filtering and transformation in comprehensions or reading in loops, harder to express concisely and clearly.","match = pattern.search(data)  
if match is not None:  
    process(match)

Use instead:

if (match := pattern.search(data)) is not None:  
    process(match)",,,,,,