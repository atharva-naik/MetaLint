{
    "what-it-does": "Checks for uses of except handling via try-except within for and\nwhile loops.",
    "why-is-this-bad": "Exception handling via try-except blocks incurs some performance\noverhead, regardless of whether an exception is raised.\n\n\nTo optimize your code, two techniques are possible:\n\n\n\nRefactor your code to put the entire loop into the try-except block,\n    rather than wrapping each iteration in a separate try-except block.\nUse \"Look Before You Leap\" idioms that attempt to avoid exceptions\n    being raised in the first place, avoiding the need to use try-except\n    blocks in the first place.\n\n\n\nThis rule is only enforced for Python versions prior to 3.11, which\nintroduced \"zero-cost\" exception handling. However, note that even on\nPython 3.11 and newer, refactoring your code to avoid exception handling in\ntight loops can provide a significant speedup in some cases, as zero-cost\nexception handling is only zero-cost in the \"happy path\" where no exception\nis raised in the try-except block.\n\n\nAs with all perflint rules, this is only intended as a\nmicro-optimization. In many cases, it will have a negligible impact on\nperformance.",
    "example": "string_numbers: list[str] = [\"1\", \"2\", \"three\", \"4\", \"5\"]\n\n# `try`/`except` that could be moved out of the loop:\nint_numbers: list[int] = []\nfor num in string_numbers:\n    try:\n        int_numbers.append(int(num))\n    except ValueError as e:\n        print(f\"Couldn't convert to integer: {e}\")\n        break\n\n# `try`/`except` used when \"look before you leap\" idioms could be used:\nnumber_names: dict[int, str] = {1: \"one\", 3: \"three\", 4: \"four\"}\nfor number in range(5):\n    try:\n        name = number_names[number]\n    except KeyError:\n        continue\n    else:\n        print(f\"The name of {number} is {name}\")\n\n\n\nUse instead:\n\n\nstring_numbers: list[str] = [\"1\", \"2\", \"three\", \"4\", \"5\"]\n\nint_numbers: list[int] = []\ntry:\n    for num in string_numbers:\n        int_numbers.append(int(num))\nexcept ValueError as e:\n    print(f\"Couldn't convert to integer: {e}\")\n\nnumber_names: dict[int, str] = {1: \"one\", 3: \"three\", 4: \"four\"}\nfor number in range(5):\n    name = number_names.get(number)\n    if name is not None:\n        print(f\"The name of {number} is {name}\")",
    "example-split": {
        "example-before": "string_numbers: list[str] = [\"1\", \"2\", \"three\", \"4\", \"5\"]\n\n# `try`/`except` that could be moved out of the loop:\nint_numbers: list[int] = []\nfor num in string_numbers:\n    try:\n        int_numbers.append(int(num))\n    except ValueError as e:\n        print(f\"Couldn't convert to integer: {e}\")\n        break\n\n# `try`/`except` used when \"look before you leap\" idioms could be used:\nnumber_names: dict[int, str] = {1: \"one\", 3: \"three\", 4: \"four\"}\nfor number in range(5):\n    try:\n        name = number_names[number]\n    except KeyError:\n        continue\n    else:\n        print(f\"The name of {number} is {name}\")\n\n",
        "example-after": "\nstring_numbers: list[str] = [\"1\", \"2\", \"three\", \"4\", \"5\"]"
    }
}