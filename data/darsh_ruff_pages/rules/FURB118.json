{
    "what-it-does": "Checks for lambda expressions and function definitions that can be replaced with a function from\nthe operator module.",
    "why-is-this-bad": "The operator module provides functions that implement the same functionality as the\ncorresponding operators. For example, operator.add is often equivalent to lambda x, y: x + y.\nUsing the functions from the operator module is more concise and communicates the intent of\nthe code more clearly.",
    "example": "import functools\n\nnums = [1, 2, 3]\ntotal = functools.reduce(lambda x, y: x + y, nums)\n\n\n\nUse instead:\n\n\nimport functools\nimport operator\n\nnums = [1, 2, 3]\ntotal = functools.reduce(operator.add, nums)",
    "fix-safety": "The fix offered by this rule is always marked as unsafe. While the changes the fix would make\nwould rarely break your code, there are two ways in which functions from the operator module\ndiffer from user-defined functions. It would be non-trivial for Ruff to detect whether or not\nthese differences would matter in a specific situation where Ruff is emitting a diagnostic for\nthis rule.\n\n\nThe first difference is that operator functions cannot be called with keyword arguments, but\nmost user-defined functions can. If an add function is defined as add = lambda x, y: x + y,\nreplacing this function with operator.add will cause the later call to raise TypeError if\nthe function is later called with keyword arguments, e.g. add(x=1, y=2).\n\n\nThe second difference is that user-defined functions are descriptors, but this is not true of\nthe functions defined in the operator module. Practically speaking, this means that defining\na function in a class body (either by using a def statement or assigning a lambda function\nto a variable) is a valid way of defining an instance method on that class; monkeypatching a\nuser-defined function onto a class after the class has been created also has the same effect.\nThe same is not true of an operator function: assigning an operator function to a variable\nin a class body or monkeypatching one onto a class will not create a valid instance method.\nRuff will refrain from emitting diagnostics for this rule on function definitions in class\nbodies; however, it does not currently have sophisticated enough type inference to avoid\nemitting this diagnostic if a user-defined function is being monkeypatched onto a class after\nthe class has been constructed.",
    "example-split": {
        "example-before": "import functools\n\nnums = [1, 2, 3]\ntotal = functools.reduce(lambda x, y: x + y, nums)\n\n",
        "example-after": "\nimport functools\nimport operator"
    }
}