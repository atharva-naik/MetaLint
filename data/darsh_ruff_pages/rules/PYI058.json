{
    "what-it-does": "Checks for simple __iter__ methods that return Generator, and for\nsimple __aiter__ methods that return AsyncGenerator.",
    "why-is-this-bad": "Using (Async)Iterator for these methods is simpler and more elegant. More\nimportantly, it also reflects the fact that the precise kind of iterator\nreturned from an __iter__ method is usually an implementation detail that\ncould change at any time. Type annotations help define a contract for a\nfunction; implementation details should not leak into that contract.\n\n\nFor example:\n\n\nfrom collections.abc import AsyncGenerator, Generator\nfrom typing import Any\n\n\nclass CustomIterator:\n    def __iter__(self) -> Generator:\n        yield from range(42)\n\n\nclass CustomIterator2:\n    def __iter__(self) -> Generator[str, Any, None]:\n        yield from \"abcdefg\"\n\n\n\nUse instead:\n\n\nfrom collections.abc import Iterator\n\n\nclass CustomIterator:\n    def __iter__(self) -> Iterator:\n        yield from range(42)\n\n\nclass CustomIterator2:\n    def __iter__(self) -> Iterator[str]:\n        yield from \"abdefg\"",
    "fix-safety": "This rule tries hard to avoid false-positive errors, and the rule's fix\nshould always be safe for .pyi stub files. However, there is a slightly\nhigher chance that a false positive might be emitted by this rule when\napplied to runtime Python (.py files). As such, the fix is marked as\nunsafe for any __iter__ or __aiter__ method in a .py file that has\nmore than two statements (including docstrings) in its body."
}