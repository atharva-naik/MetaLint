{
    "what-it-does": "Checks the following constructs, all of which can be replaced by\nnext(iter(...)):\n\n\n\nlist(...)[0]\ntuple(...)[0]\nlist(i for i in ...)[0]\n[i for i in ...][0]\nlist(...).pop(0)",
    "why-is-this-bad": "Calling e.g. list(...) will create a new list of the entire collection,\nwhich can be very expensive for large collections. If you only need the\nfirst element of the collection, you can use next(...) or\nnext(iter(...) to lazily fetch the first element. The same is true for\nthe other constructs.",
    "example": "head = list(x)[0]\nhead = [x * x for x in range(10)][0]\n\n\n\nUse instead:\n\n\nhead = next(iter(x))\nhead = next(x * x for x in range(10))",
    "fix-safety": "This rule's fix is marked as unsafe, as migrating from (e.g.) list(...)[0]\nto next(iter(...)) can change the behavior of your program in two ways:\n\n\n\nFirst, all above-mentioned constructs will eagerly evaluate the entire\n    collection, while next(iter(...)) will only evaluate the first\n    element. As such, any side effects that occur during iteration will be\n    delayed.\nSecond, accessing members of a collection via square bracket notation\n    [0] of the pop() function will raise IndexError if the collection\n    is empty, while next(iter(...)) will raise StopIteration.",
    "example-split": {
        "example-before": "head = list(x)[0]\nhead = [x * x for x in range(10)][0]\n\n",
        "example-after": "\nhead = next(iter(x))\nhead = next(x * x for x in range(10))"
    }
}