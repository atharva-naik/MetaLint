{
    "what-it-does": "Checks for lambda definitions that consist of a single function call\nwith the same arguments as the lambda itself.",
    "why-is-this-bad": "When a lambda is used to wrap a function call, and merely propagates\nthe lambda arguments to that function, it can typically be replaced with\nthe function itself, removing a level of indirection.",
    "example": "df.apply(lambda x: str(x))\n\n\n\nUse instead:\n\n\ndf.apply(str)",
    "fix-safety": "This rule's fix is marked as unsafe for two primary reasons.\n\n\nFirst, the lambda body itself could contain an effect.\n\n\nFor example, replacing lambda x, y: (func()(x, y)) with func() would\nlead to a change in behavior, as func() would be evaluated eagerly when\ndefining the lambda, rather than when the lambda is called.\n\n\nHowever, even when the lambda body itself is pure, the lambda may\nchange the argument names, which can lead to a change in behavior when\ncallers pass arguments by name.\n\n\nFor example, replacing foo = lambda x, y: func(x, y) with foo = func,\nwhere func is defined as def func(a, b): return a + b, would be a\nbreaking change for callers that execute the lambda by passing arguments by\nname, as in: foo(x=1, y=2). Since func does not define the arguments\nx and y, unlike the lambda, the call would raise a TypeError.",
    "example-split": {
        "example-before": "df.apply(lambda x: str(x))\n\n",
        "example-after": "\ndf.apply(str)"
    }
}