{
    "what-it-does": "Checks for methods that define a custom TypeVar for their return type\nannotation instead of using Self.",
    "why-is-this-bad": "While the semantics are often identical, using Self is more intuitive\nand succinct (per PEP 673) than a custom TypeVar. For example, the\nuse of Self will typically allow for the omission of type parameters\non the self and cls arguments.\n\n\nThis check currently applies to instance methods that return self,\nclass methods that return an instance of cls, and __new__ methods.",
    "example": "class Foo:\n    def __new__(cls: type[_S], *args: str, **kwargs: int) -> _S: ...\n    def foo(self: _S, arg: bytes) -> _S: ...\n    @classmethod\n    def bar(cls: type[_S], arg: int) -> _S: ...\n\n\n\nUse instead:\n\n\nfrom typing import Self\n\nclass Foo:\n    def __new__(cls, *args: str, **kwargs: int) -> Self: ...\n    def foo(self, arg: bytes) -> Self: ...\n    @classmethod\n    def bar(cls, arg: int) -> Self: ...",
    "fix-safety": "The fix is only available in stub files.\nIt will try to remove all usages and declarations of the custom type variable.\nPre-[PEP-695]-style declarations will not be removed.\n\n\nIf a variable's annotation is too complex to handle,\nthe fix will be marked as display only.\nOtherwise, it will be marked as safe.",
    "example-split": {
        "example-before": "class Foo:\n    def __new__(cls: type[_S], *args: str, **kwargs: int) -> _S: ...\n    def foo(self: _S, arg: bytes) -> _S: ...\n    @classmethod\n    def bar(cls: type[_S], arg: int) -> _S: ...\n\n",
        "example-after": "\nfrom typing import Self"
    }
}