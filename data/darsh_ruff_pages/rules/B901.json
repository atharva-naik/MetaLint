{
    "what-it-does": "Checks for return {value} statements in functions that also contain yield\nor yield from statements.",
    "why-is-this-bad": "Using return {value} in a generator function was syntactically invalid in\nPython 2. In Python 3 return {value} can be used in a generator; however,\nthe combination of yield and return can lead to confusing behavior, as\nthe return statement will cause the generator to raise StopIteration\nwith the value provided, rather than returning the value to the caller.\n\n\nFor example, given:\n\n\nfrom collections.abc import Iterable\nfrom pathlib import Path\n\n\ndef get_file_paths(file_types: Iterable[str] | None = None) -> Iterable[Path]:\n    dir_path = Path(\".\")\n    if file_types is None:\n        return dir_path.glob(\"*\")\n\n    for file_type in file_types:\n        yield from dir_path.glob(f\"*.{file_type}\")\n\n\n\nReaders might assume that get_file_paths() would return an iterable of\nPath objects in the directory; in reality, though, list(get_file_paths())\nevaluates to [], since the return statement causes the generator to raise\nStopIteration with the value dir_path.glob(\"*\"):\n\n\n>>> list(get_file_paths(file_types=[\"cfg\", \"toml\"]))\n[PosixPath('setup.cfg'), PosixPath('pyproject.toml')]\n>>> list(get_file_paths())\n[]\n\n\n\nFor intentional uses of return in a generator, consider suppressing this\ndiagnostic.",
    "example": "from collections.abc import Iterable\nfrom pathlib import Path\n\n\ndef get_file_paths(file_types: Iterable[str] | None = None) -> Iterable[Path]:\n    dir_path = Path(\".\")\n    if file_types is None:\n        return dir_path.glob(\"*\")\n\n    for file_type in file_types:\n        yield from dir_path.glob(f\"*.{file_type}\")\n\n\n\nUse instead:\n\n\nfrom collections.abc import Iterable\nfrom pathlib import Path\n\n\ndef get_file_paths(file_types: Iterable[str] | None = None) -> Iterable[Path]:\n    dir_path = Path(\".\")\n    if file_types is None:\n        yield from dir_path.glob(\"*\")\n    else:\n        for file_type in file_types:\n            yield from dir_path.glob(f\"*.{file_type}\")",
    "example-split": {
        "example-before": "from collections.abc import Iterable\nfrom pathlib import Path\n\n\ndef get_file_paths(file_types: Iterable[str] | None = None) -> Iterable[Path]:\n    dir_path = Path(\".\")\n    if file_types is None:\n        return dir_path.glob(\"*\")\n\n    for file_type in file_types:\n        yield from dir_path.glob(f\"*.{file_type}\")\n\n",
        "example-after": "\nfrom collections.abc import Iterable\nfrom pathlib import Path"
    }
}