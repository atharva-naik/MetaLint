JEP 147: Reduce Class Metadata FootprintJEP 147: Reduce Class Metadata FootprintOwnerJiangli ZhouTypeFeatureScopeImplementationStatusClosed / DeliveredRelease8Componenthotspot / runtimeDiscussionhotspot dash runtime dash dev at openjdk dot java dot netEffortLDurationLReviewed byBob VandetteEndorsed byMikael VidstedtCreated2011/10/17 20:00Updated2014/08/08 20:54Issue8046137Summary
Reduce HotSpot's class metadata memory footprint in order to improve
performance on small devices.
Success Metrics
Reduce class, method, and field metadata memory footprint by 25% as
measured by calculating the space used by the relevant data structures
(but excluding the space used for bytecodes and interned strings).
The startup and runtime performance of typical applications must not
regress by more than 1%.
Description
Many of the memory-reduction techniques used in CVM, an embedded JVM for
Java ME CDC, can be applied to HotSpot.  For example:


Keep rarely-used fields out of the class, method, and field data
structures.


Make all struct fields as small as possible.


Encode some fields so that they fit into smaller types.


Don't mix field sizes in such a way that causes unnecessary padding
(i.e., group types of similar sizes).


Use 16-bit offsets for some types of data rather than 32-bit
pointers.


Use unions for groups of fields when no more than one is ever in use
at the same time. Some fields will have different meanings based on
the state the class is in.


Avoid storing the cb* in each fb and mb.


Methods are either abstract, native, or Java. Any data specific to
one of these three types is kept in a separate struct, so the method
data structure does not carry fields that are not always needed.


Data related to compiled methods is not allocated until the method is
compiled.


Retaining Java debugging information is optional and usually disabled
in production builds.


Constant pool entries (including type information) are 40 bits.


Compact the GC bitmap for describing which fields in a class are
reference types.  This usually fits in just 32 bits.


Limit the number of mallocs, and the resultant per-malloc block
overhead, when allocating memory for a loaded class. Most of the
class is laid out in one large malloc allocation.


As an example, the following four boolean fields in instanceKlass.hpp
can be combined into a single u1 field:
bool _is_marked_dependent;   // used for marking during flushing & deopt
bool _rewritten;             // methods rewritten
bool _has_nonstatic_fields;  // for sizing with UseCompressedOops
bool _should_verify_class;   // allow caching of preverification
Impact

Other JDK components: Tools that have knowledge of of class metadata
formats

InstallingContributingSponsoringDevelopers' GuideVulnerabilitiesJDK GA/EA BuildsMailing listsWiki
                      · IRCBylaws · CensusLegalWorkshopJEP ProcessSource codeMercurialGitHubToolsGitjtreg harnessGroups(overview)AdoptionBuildClient LibrariesCompatibility & Specification ReviewCompilerConformanceCore LibrariesGoverning BoardHotSpotIDE Tooling & SupportInternationalizationJMXMembersNetworkingPortersQualitySecurityServiceabilityVulnerabilityWebProjects(overview,
      archive)AmberBabylonCRaCCaciocavalloClosuresCode ToolsCoinCommon VM InterfaceCompiler GrammarDetroitDevelopers' GuideDevice I/ODukeGalahadGraalIcedTeaJDK 7JDK 8JDK 8 UpdatesJDK 9JDK
      (…,
       21,
       22,
       23)JDK UpdatesJavaDoc.NextJigsawKonaKullaLambdaLanaiLeydenLilliputLocale EnhancementLoomMemory Model UpdateMetropolisMission ControlMulti-Language VMNashornNew I/OOpenJFXPanamaPenrosePort: AArch32Port: AArch64Port: BSDPort: HaikuPort: Mac OS XPort: MIPSPort: MobilePort: PowerPC/AIXPort: RISC-VPort: s390xPortolaSCTPShenandoahSkaraSumatraTiered AttributionTsanType AnnotationsValhallaVeronaVisualVMWakefieldZeroZGC

        © 2024 Oracle Corporation and/or its affiliates
        Terms of Use
        ·
        
            License: GPLv2
        · Privacy
        · Trademarks
