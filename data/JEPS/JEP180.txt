JEP 180: Handle Frequent HashMap Collisions with Balanced TreesJEP 180: Handle Frequent HashMap Collisions with Balanced TreesAuthorMike DuigouOwnerBrent ChristianTypeFeatureScopeImplementationStatusClosed / DeliveredRelease8Componentcore-libsDiscussioncore dash libs dash dev at openjdk dot java dot netEffortMDurationMReviewed byAlan BatemanEndorsed byBrian GoetzCreated2013/02/08 20:00Updated2017/06/14 18:44Issue8046170Summary
Improve the performance of java.util.HashMap under high hash-collision
conditions by using balanced trees rather than linked lists to store map
entries.  Implement the same improvement in the LinkedHashMap class.
Motivation
Earlier work in this area in JDK 8, namely the
alternative string-hashing implementation, improved collision
performance for string-valued keys only, and it did so at the cost of
adding a new (private) field to every String instance.
The changes proposed here will improve collision performance for any key
type that implements Comparable.  The alternative string-hashing
mechanism, including the private hash32 field added to the String
class, can then be removed.
Description
The principal idea is that once the number of items in a hash bucket
grows beyond a certain threshold, that bucket will switch from using a
linked list of entries to a balanced tree.  In the case of high hash
collisions, this will improve worst-case performance from O(n) to O(log
n).
This technique has already been implemented in the latest version of the
java.util.concurrent.ConcurrentHashMap class, which is also slated for
inclusion in JDK 8 as part of JEP 155.  Portions of that code will
be re-used to implement the same idea in the HashMap and LinkedHashMap
classes.  Only the implementations will be changed; no
interfaces or specifications will be modified.  Some user-visible
behaviors, such as iteration order, will change within the bounds of
their current specifications.
We will not implement this technique in the legacy Hashtable class.
That class has been part of the platform since Java 1.0, and some legacy
code that uses it is known to depend upon iteration order.  Hashtable
will be reverted to its state prior to the introduction of the
alternative string-hashing implementation, and will maintain its
historical iteration order.
We also will not implement this technique in WeakHashMap.  An attempt was
made, but the complexity of having to account for weak keys resulted in an
unacceptable drop in microbenchmark performance.  WeakHashMap will also
be reverted to its prior state.
There is no need to implement this technique in the IdentityHashMap
class.  It uses System.identityHashCode() to generate hash codes, so
collisions are generally rare.
Testing

Run Map tests from Doug Lea's JSR 166 CVS workspace (includes a couple
microbenchmarks)
Run performance tests of standard workloads
Possibly develop new microbenchmarks

Risks and Assumptions
This change will introduce some overhead for the addition and management
of the balanced trees; we expect that overhead to be negligible.
This change will likely result in a change to the iteration order of the
HashMap class.  The HashMap specification
explicitly makes no guarantee  about iteration order.  The iteration order of
the LinkedHashMap class will be maintained.
InstallingContributingSponsoringDevelopers' GuideVulnerabilitiesJDK GA/EA BuildsMailing listsWiki
                      · IRCBylaws · CensusLegalWorkshopJEP ProcessSource codeMercurialGitHubToolsGitjtreg harnessGroups(overview)AdoptionBuildClient LibrariesCompatibility & Specification ReviewCompilerConformanceCore LibrariesGoverning BoardHotSpotIDE Tooling & SupportInternationalizationJMXMembersNetworkingPortersQualitySecurityServiceabilityVulnerabilityWebProjects(overview,
      archive)AmberBabylonCRaCCaciocavalloClosuresCode ToolsCoinCommon VM InterfaceCompiler GrammarDetroitDevelopers' GuideDevice I/ODukeGalahadGraalIcedTeaJDK 7JDK 8JDK 8 UpdatesJDK 9JDK
      (…,
       21,
       22,
       23)JDK UpdatesJavaDoc.NextJigsawKonaKullaLambdaLanaiLeydenLilliputLocale EnhancementLoomMemory Model UpdateMetropolisMission ControlMulti-Language VMNashornNew I/OOpenJFXPanamaPenrosePort: AArch32Port: AArch64Port: BSDPort: HaikuPort: Mac OS XPort: MIPSPort: MobilePort: PowerPC/AIXPort: RISC-VPort: s390xPortolaSCTPShenandoahSkaraSumatraTiered AttributionTsanType AnnotationsValhallaVeronaVisualVMWakefieldZeroZGC

        © 2024 Oracle Corporation and/or its affiliates
        Terms of Use
        ·
        
            License: GPLv2
        · Privacy
        · Trademarks
