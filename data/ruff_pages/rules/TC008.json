{
    "what-it-does": "Checks for unnecessary quotes in PEP 613 explicit type aliases\nand PEP 695 type statements.",
    "why-is-this-bad": "Unnecessary string forward references can lead to additional overhead\nin runtime libraries making use of type hints. They can also have bad\ninteractions with other runtime uses like PEP 604 type unions.\n\n\nPEP-613 type aliases are only flagged by the rule if Ruff can have high\nconfidence that the quotes are unnecessary. Specifically, any PEP-613\ntype alias where the type expression on the right-hand side contains\nsubscripts or attribute accesses will not be flagged. This is because\ntype aliases can reference types that are, for example, generic in stub\nfiles but not at runtime. That can mean that a type checker expects the\nreferenced type to be subscripted with type arguments despite the fact\nthat doing so would fail at runtime if the type alias value was not\nquoted. Similarly, a type alias might need to reference a module-level\nattribute that exists in a stub file but not at runtime, meaning that\nthe type alias value would need to be quoted to avoid a runtime error.",
    "example": "Given:\n\n\nOptInt: TypeAlias = \"int | None\"\n\n\n\nUse instead:\n\n\nOptInt: TypeAlias = int | None\n\n\n\nGiven:\n\n\ntype OptInt = \"int | None\"\n\n\n\nUse instead:\n\n\ntype OptInt = int | None",
    "fix-safety": "This rule's fix is marked as safe, unless the type annotation contains comments.",
    "example-split": {
        "example-before": "Given:\n\n\nOptInt: TypeAlias = \"int | None\"\n\n",
        "example-after": "\ntype OptInt = int | None"
    }
}