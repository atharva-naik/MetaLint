{
    "what-it-does": "Checks for printf-style string formatting, and offers to replace it with\nstr.format calls.",
    "why-is-this-bad": "printf-style string formatting has a number of quirks, and leads to less\nreadable code than using str.format calls or f-strings. In general, prefer\nthe newer str.format and f-strings constructs over printf-style string\nformatting.",
    "example": "\"%s, %s\" % (\"Hello\", \"World\")  # \"Hello, World\"\n\n\n\nUse instead:\n\n\n\"{}, {}\".format(\"Hello\", \"World\")  # \"Hello, World\"\n\n\n\nf\"{'Hello'}, {'World'}\"  # \"Hello, World\"",
    "fix-safety": "In cases where the format string contains a single generic format specifier\n(e.g. %s), and the right-hand side is an ambiguous expression,\nwe cannot offer a safe fix.\n\n\nFor example, given:\n\n\n\"%s\" % val\n\n\n\nval could be a single-element tuple, or a single value (not\ncontained in a tuple). Both of these would resolve to the same\nformatted string when using printf-style formatting, but\nresolve differently when using f-strings:\n\n\nval = 1\nprint(\"%s\" % val)  # \"1\"\nprint(\"{}\".format(val))  # \"1\"\n\nval = (1,)\nprint(\"%s\" % val)  # \"1\"\nprint(\"{}\".format(val))  # \"(1,)\"",
    "example-split": {
        "example-before": "\"%s, %s\" % (\"Hello\", \"World\")  # \"Hello, World\"\n\n",
        "example-after": "\n\"{}, {}\".format(\"Hello\", \"World\")  # \"Hello, World\""
    }
}