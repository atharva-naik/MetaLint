{
    "what-it-does": "Checks for parameter annotations that contain redundant unions between\nbuiltin numeric types (e.g., int | float).",
    "why-is-this-bad": "The typing specification states:\n\n\n\nPython\u2019s numeric types complex, float and int are not subtypes of\neach other, but to support common use cases, the type system contains a\nstraightforward shortcut: when an argument is annotated as having type\nfloat, an argument of type int is acceptable; similar, for an\nargument annotated as having type complex, arguments of type float or\nint are acceptable.\n\n\n\nAs such, a union that includes both int and float is redundant in the\nspecific context of a parameter annotation, as it is equivalent to a union\nthat only includes float. For readability and clarity, unions should omit\nredundant elements.",
    "example": "def foo(x: float | int | str) -> None: ...\n\n\n\nUse instead:\n\n\ndef foo(x: float | str) -> None: ...",
    "fix-safety": "This rule's fix is marked as safe, unless the type annotation contains comments.\n\n\nNote that while the fix may flatten nested unions into a single top-level union,\nthe semantics of the annotation will remain unchanged.",
    "example-split": {
        "example-before": "def foo(x: float | int | str) -> None: ...\n\n",
        "example-after": "\ndef foo(x: float | str) -> None: ..."
    }
}